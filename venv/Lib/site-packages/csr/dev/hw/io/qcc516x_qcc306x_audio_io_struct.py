# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
# Automatically-generated memory-mapped registers IO file
#------------------------------------------------------------------------------

class c_enum(object):
   def __init__(self, parent, value, text, reg):
      self.parent = parent
      self.value  = value
      self.text   = text
      self.reg    = reg

class c_value(object):
   def __init__(self, parent, name, value, text):
      self.parent = parent
      self.name   = name
      self.value  = value
      self.text   = text

class c_bits(object):
   def __init__(self, parent, lsb, msb, mask, width, rw_flags, text):
      self.parent   = parent
      self.lsb      = lsb
      self.msb      = msb
      self.mask     = mask
      self.rw_flags = rw_flags
      self.width    = width
      self.text     = text

class c_reg(object):
   def __init__(self, addr, r, w, m, rw_flags, width, reset, local, ext_read, mod_name, group, text, locked_by, unlock_value, typedefd_io, safe_to_load, is_bank_ctrl, bank_ctrl_reg, constant):
      self.addr          = addr
      self.r             = r            # Readable
      self.w             = w            # Writeable
      self.m             = m            # Mixed register type
      self.rw_flags      = rw_flags     # RW flags
      self.width         = width
      self.local         = local
      self.ext_read      = ext_read
      self.mod_name      = mod_name
      self.text          = text
      self.group         = group
      self.reset         = reset
      self.locked_by     = locked_by
      self.unlock_value  = unlock_value
      self.safe_to_load  = safe_to_load
      self.typedefd_io   = typedefd_io
      self.is_bank_ctrl  = is_bank_ctrl
      self.bank_ctrl_reg = bank_ctrl_reg
      self.constant      = constant

class c_regarray(object):
   def __init__(self, addr, num_elements, element):
      self.addr = addr
      self.num_elements  = num_elements
      self.element = element


ARITHMETIC_MODE                                                                  = c_reg(0xffffe014, 1, 1, 0, "RW", 5, 0, 0, 0, "k32_core", "", "Configures some arithmetic features of Kalimba's ALU.", "", "", 0, 1, "", "", 0)
ARITHMETIC_MODE.ADDSUB_SATURATE_ON_OVERFLOW                                      = c_bits(ARITHMETIC_MODE, 0, 0, 0x1, 1, "RW", "Enables saturation on overflow for addition or subtraction in the ALU. For example, 0x7FFFFFF0 + 0x15 saturates to 0x7FFFFFFF rather than wrapping around to 0x80000005.")
ARITHMETIC_MODE.ARITHMETIC_16BIT_MODE                                            = c_bits(ARITHMETIC_MODE, 1, 1, 0x2, 1, "RW", "Unsupported on KALIMBA_ARCH 4 &#38; 5")
ARITHMETIC_MODE.DISABLE_UNBIASED_ROUNDING                                        = c_bits(ARITHMETIC_MODE, 2, 2, 0x4, 1, "RW", "Disables unbiased rounding of all internal double-precision values when converting them to 32 bits. Unbiased rounding rounds odd midpoint values away from zero and even midpoint values towards zero. 20.5 (0x00_00000014_80000000) is an example of an even midpoint value, and so would round to 20. -1.5 (0xFF_FFFFFFFE_80000000) is an example of an odd midpoint value, and so would round to -2. Unbiased rounding yields a zero large-sample bias, assuming uniformly distributed values.")
ARITHMETIC_MODE.DISABLE_FRAC_MULT_ROUNDING                                       = c_bits(ARITHMETIC_MODE, 3, 3, 0x8, 1, "RW", "Disables rounding of the result of a fractional multiply when storing to a 32-bit register. With rounding disabled, truncation occurs. For example, 10.75 (0x00_0000000A_C0000000) would round to 11 but be truncated to 10.")
ARITHMETIC_MODE.DISABLE_RMAC_STORE_ROUNDING                                      = c_bits(ARITHMETIC_MODE, 4, 4, 0x10, 1, "RW", "Disables rounding of the rMAC72 value when it is written to memory or a 32-bit register.")
BITREVERSE_ADDR                                                                  = c_reg(0xffffe038, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A read of this register will return the bitreverse of the bottom 31 bits of the data in BITREVERSE_VAL and will copy the MS bit.  This is a useful operation for bit reversing addresses as is required for a radix-2 FFT implementation.", "", "", 0, 1, "", "", 0)
BITREVERSE_ADDR.BITREVERSE_ADDR                                                  = c_bits(BITREVERSE_ADDR, 0, 31, 0xffffffff, 32, "R", "")
BITREVERSE_DATA                                                                  = c_reg(0xffffe030, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A read of this register will return a full 32-bit bitreverse of the data previously written to the  BITREVERSE_VAL register.", "", "", 0, 1, "", "", 0)
BITREVERSE_DATA.BITREVERSE_DATA                                                  = c_bits(BITREVERSE_DATA, 0, 31, 0xffffffff, 32, "R", "")
BITREVERSE_DATA16                                                                = c_reg(0xffffe034, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A read of this register will return the bitreverse of the LS 16 bits of BITREVERSE_VAL. The 16-bit value is then sign extended to 32 bits.", "", "", 0, 1, "", "", 0)
BITREVERSE_DATA16.BITREVERSE_DATA16                                              = c_bits(BITREVERSE_DATA16, 0, 31, 0xffffffff, 32, "R", "")
BITREVERSE_VAL                                                                   = c_reg(0xffffe02c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "Data written to this register is passed to the bitreverser hardware. (See BITREVERSE_XXX registers below). This register can be read in order to do context saving (eg during ISR).", "", "", 0, 1, "", "", 0)
BITREVERSE_VAL.BITREVERSE_VAL                                                    = c_bits(BITREVERSE_VAL, 0, 31, 0xffffffff, 32, "RW", "")
DBG_COUNTERS_EN                                                                  = c_reg(0xffffe050, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_core", "", "When set to 1, enables the operation of the NUM_RUN_CLKS, NUM_INSTRS and NUM_STALLS registers.  By default it is disabled to slightly reduce Kalimba's current consumption.", "", "", 0, 1, "", "", 0)
DBG_COUNTERS_EN.DBG_COUNTERS_EN                                                  = c_bits(DBG_COUNTERS_EN, 0, 0, 0x1, 1, "RW", "")
FRAME_POINTER                                                                    = c_reg(0xffffe028, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Memory mapped version of the current frame pointer. Also accessable from the bank 3 register FP.", "", "", 0, 1, "", "", 0)
FRAME_POINTER.FRAME_POINTER                                                      = c_bits(FRAME_POINTER, 0, 31, 0xffffffff, 32, "RW", "")
MM_DOLOOP_END                                                                    = c_reg(0xffffe004, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "End address of the zero overhead loop. This register is set by executing a \"do\" instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_DOLOOP_END.MM_DOLOOP_END                                                      = c_bits(MM_DOLOOP_END, 0, 31, 0xffffffff, 32, "RW", "")
MM_DOLOOP_START                                                                  = c_reg(0xffffe000, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Start address of the zero overhead loop. This register is set by executing a \"do\" instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_DOLOOP_START.MM_DOLOOP_START                                                  = c_bits(MM_DOLOOP_START, 0, 31, 0xffffffff, 32, "RW", "")
MM_QUOTIENT                                                                      = c_reg(0xffffe008, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Quotient result of division instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_QUOTIENT.MM_QUOTIENT                                                          = c_bits(MM_QUOTIENT, 0, 31, 0xffffffff, 32, "RW", "")
MM_REM                                                                           = c_reg(0xffffe00c, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Remainder result of division instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_REM.MM_REM                                                                    = c_bits(MM_REM, 0, 31, 0xffffffff, 32, "RW", "")
MM_RINTLINK                                                                      = c_reg(0xffffe010, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "The return PC address stored in this register is used by the rti instruction. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_RINTLINK.MM_RINTLINK                                                          = c_bits(MM_RINTLINK, 0, 31, 0xffffffff, 32, "RW", "")
NUM_CORE_STALLS                                                                  = c_reg(0xffffe044, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor core stalls that have occured (this covers instruction decoding related stalls only and does not include stalls due to DM and PM memory bus waits or delays within the prefetch logic).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_CORE_STALLS.NUM_CORE_STALLS                                                  = c_bits(NUM_CORE_STALLS, 0, 31, 0xffffffff, 32, "R", "")
NUM_INSTRS                                                                       = c_reg(0xffffe040, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor instructions that have been executed.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_INSTRS.NUM_INSTRS                                                            = c_bits(NUM_INSTRS, 0, 31, 0xffffffff, 32, "R", "")
NUM_INSTR_EXPAND_STALLS                                                          = c_reg(0xffffe04c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor stalls due to expanding of compressed instructions (either: Maxim Push/Pop multiple; or large Minim instructions).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_INSTR_EXPAND_STALLS.NUM_INSTR_EXPAND_STALLS                                  = c_bits(NUM_INSTR_EXPAND_STALLS, 0, 31, 0xffffffff, 32, "R", "")
NUM_MEM_ACCESS_STALLS                                                            = c_reg(0xffffe048, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor stalls due to memory acccesses (either: DM1/DM2 bus waits; IAG1/IAG2/MAIN DM bus overlap waits; or core stalls due to DM address forwarding).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_MEM_ACCESS_STALLS.NUM_MEM_ACCESS_STALLS                                      = c_bits(NUM_MEM_ACCESS_STALLS, 0, 31, 0xffffffff, 32, "R", "")
NUM_RUN_CLKS                                                                     = c_reg(0xffffe03c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor clock cycles that have occured whilst running.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_RUN_CLKS.NUM_RUN_CLKS                                                        = c_bits(NUM_RUN_CLKS, 0, 31, 0xffffffff, 32, "R", "")
PC_STATUS                                                                        = c_reg(0xffffe054, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "Current value of the processor's program counter. This register still exists for legacy reasons but shouldn't be needed as there are alternative methods of obtaining the current PC.", "", "", 0, 1, "", "", 0)
PC_STATUS.PC_STATUS                                                              = c_bits(PC_STATUS, 0, 31, 0xffffffff, 32, "R", "")
STACK_END_ADDR                                                                   = c_reg(0xffffe01c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "Write to this register to set the Stack end address.  Note: It must be greater than the STACK_START_ADDR as stack builds upwards, and must also be word aligned. ", "", "", 0, 1, "", "", 0)
STACK_END_ADDR.STACK_END_ADDR                                                    = c_bits(STACK_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
STACK_OVERFLOW_PC                                                                = c_reg(0xffffe024, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "Address of the last instruction which generated a stack overflow event. (See INT_EVENT_ERROR).", "", "", 0, 1, "", "", 0)
STACK_OVERFLOW_PC.STACK_OVERFLOW_PC                                              = c_bits(STACK_OVERFLOW_PC, 0, 31, 0xffffffff, 32, "R", "")
STACK_POINTER                                                                    = c_reg(0xffffe020, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Memory mapped version of the current stack pointer. Also accessable from the bank 3 register SP.", "", "", 0, 1, "", "", 0)
STACK_POINTER.STACK_POINTER                                                      = c_bits(STACK_POINTER, 0, 31, 0xffffffff, 32, "RW", "")
STACK_START_ADDR                                                                 = c_reg(0xffffe018, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "Write to this register to set the Stack start address.  Note: The stack must be located at a word boundary (not at a half-word or byte offset).", "", "", 0, 1, "", "", 0)
STACK_START_ADDR.STACK_START_ADDR                                                = c_bits(STACK_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_0                                                                       = c_reg(0xffffe058, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_0.TEST_REG_0                                                            = c_bits(TEST_REG_0, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_1                                                                       = c_reg(0xffffe05c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_1.TEST_REG_1                                                            = c_bits(TEST_REG_1, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_2                                                                       = c_reg(0xffffe060, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_2.TEST_REG_2                                                            = c_bits(TEST_REG_2, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_3                                                                       = c_reg(0xffffe064, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_3.TEST_REG_3                                                            = c_bits(TEST_REG_3, 0, 31, 0xffffffff, 32, "RW", "")

# -- Kalimba 32-bit Program Flow Debug Control registers. Note: All these registers are only accessable from SPI and T-Bus, not from Kalimba core itself. --

DEBUG                                                                            = c_reg(0xfffffe30, 1, 1, 0, "RW", 19, 0, 0, 0, "k32_debug_prog_flow", "", "A control register for configuring debugger operations.", "", "", 0, 1, "", "", 0)
DEBUG.DEBUG_RUN                                                                  = c_bits(DEBUG, 0, 0, 0x1, 1, "RW", "Setting this bit causes Kalimba to run.  Clearing this bit causes Kalimba to stop.  When running breakpoints being hit will pause execution.")
DEBUG.DEBUG_STEP                                                                 = c_bits(DEBUG, 1, 1, 0x2, 1, "RW", "Provide single stepping operation: To single step this bit must be first set.  After a clock tick the bit can be cleared and a debugger should wait until the STATUS_SINGSTEPCOMP bit goes high, which means that the single step operation has completed.")
DEBUG.DEBUG_DUMMY                                                                = c_bits(DEBUG, 2, 2, 0x4, 1, "RW", "Unused bit (there for legacy purposes).")
DEBUG.DEBUG_PM_BREAK0                                                            = c_bits(DEBUG, 3, 3, 0x8, 1, "RW", "Setting this bit enables Program Breakpoint 0 configured by PM_BREAK0_ADDR.")
DEBUG.DEBUG_PM_BREAK1                                                            = c_bits(DEBUG, 4, 4, 0x10, 1, "RW", "Setting this bit enables Program Breakpoint 1 configured by PM_BREAK1_ADDR.")
DEBUG.DEBUG_PM_BREAK2                                                            = c_bits(DEBUG, 5, 5, 0x20, 1, "RW", "Setting this bit enables Program Breakpoint 2 configured by PM_BREAK2_ADDR.")
DEBUG.DEBUG_PM_BREAK3                                                            = c_bits(DEBUG, 6, 6, 0x40, 1, "RW", "Setting this bit enables Program Breakpoint 3 configured by PM_BREAK3_ADDR.")
DEBUG.DEBUG_PM_BREAK4                                                            = c_bits(DEBUG, 7, 7, 0x80, 1, "RW", "Setting this bit enables Program Breakpoint 4 configured by PM_BREAK4_ADDR.")
DEBUG.DEBUG_PM_BREAK5                                                            = c_bits(DEBUG, 8, 8, 0x100, 1, "RW", "Setting this bit enables Program Breakpoint 5 configured by PM_BREAK5_ADDR.")
DEBUG.DEBUG_PM_BREAK6                                                            = c_bits(DEBUG, 9, 9, 0x200, 1, "RW", "Setting this bit enables Program Breakpoint 6 configured by PM_BREAK6_ADDR.")
DEBUG.DEBUG_PM_BREAK7                                                            = c_bits(DEBUG, 10, 10, 0x400, 1, "RW", "Setting this bit enables Program Breakpoint 7 configured by PM_BREAK7_ADDR.")
DEBUG.DEBUG_DM_WRITE_BREAK0                                                      = c_bits(DEBUG, 11, 11, 0x800, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit on memory writes (see DM_BREAK0_START_ADDR).")
DEBUG.DEBUG_DM_READ_BREAK0                                                       = c_bits(DEBUG, 12, 12, 0x1000, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit on memory reads (see DM_BREAK0_START_ADDR).")
DEBUG.DEBUG_DM_WRITE_BREAK1                                                      = c_bits(DEBUG, 13, 13, 0x2000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit on memory writes (see DM_BREAK1_START_ADDR).")
DEBUG.DEBUG_DM_READ_BREAK1                                                       = c_bits(DEBUG, 14, 14, 0x4000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit on memory reads (see DM_BREAK1_START_ADDR).")
DEBUG.DEBUG_DM_BYTE_MATCH_EN_BREAK0                                              = c_bits(DEBUG, 15, 15, 0x8000, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit only if memory access byte-enables overlap DM_BREAK0_BYTE_SELECT as well.")
DEBUG.DEBUG_DM_DATA_MATCH_EN_BREAK0                                              = c_bits(DEBUG, 16, 16, 0x10000, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit only if memory read or write data ANDed with DM_BREAK0_DATA_MASK equal DM_BREAK0_DATA_VALUE as well.")
DEBUG.DEBUG_DM_BYTE_MATCH_EN_BREAK1                                              = c_bits(DEBUG, 17, 17, 0x20000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit only if memory access byte-enables overlap DM_BREAK1_BYTE_SELECT as well.")
DEBUG.DEBUG_DM_DATA_MATCH_EN_BREAK1                                              = c_bits(DEBUG, 18, 18, 0x40000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit only if memory read or write data ANDed with DM_BREAK1_DATA_MASK equal DM_BREAK1_DATA_VALUE as well.")
DEBUG_PM_BREAK7_ENABLED                                                          = c_reg(0xfffffe60, 1, 1, 0, "RW", 7, 0, 1, 1, "k32_debug_prog_flow", "", "A status register indicating which of the other PM breakpoints triggered the enabling of PM breakpoint 7. Clear this by writing bits to zero.", "", "", 0, 1, "", "", 0)
DEBUG_PM_BREAK7_ENABLED.DEBUG_PM_BREAK7_ENABLED                                  = c_bits(DEBUG_PM_BREAK7_ENABLED, 0, 6, 0x7f, 7, "RW", "")
DEBUG_PM_BREAK7_ENABLES                                                          = c_reg(0xfffffe5c, 1, 1, 0, "RW", 7, 0, 0, 0, "k32_debug_prog_flow", "", "A control register for configuring additional enables for PM breakpoint 7. When this register is non-zero, and PM breakpoint 7 is enabled via DEBUG_PM_BREAK7, this breakpoint only becomes enabled once a breakpoint selected by this register has been hit. Note that a breakpoint selected as an enable for breakpoint 7 will not cause a break when it is hit, rather will trigger a write to its corresponding bit in DEBUG_PM_BREAK7_ENABLED. As soon as any bits in DEBUG_PM_BREAK7_ENABLED are set by their corresponding PM breakpoint, then breakpoint 7 is armed and will trigger a breakpoint as per normal operation. When this register is zero then PM breakpoint 7 has no special behaviour.", "", "", 0, 1, "", "", 0)
DEBUG_PM_BREAK7_ENABLES.DEBUG_PM_BREAK7_ENABLES                                  = c_bits(DEBUG_PM_BREAK7_ENABLES, 0, 6, 0x7f, 7, "RW", "")
DM_BREAK0_BYTE_SELECT                                                            = c_reg(0xfffffe40, 1, 1, 0, "RW", 4, 0, 0, 0, "k32_debug_prog_flow", "", "Byte-enables to check for when DEBUG_DM_BYTE_MATCH_EN_BREAK0 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK0_BYTE_SELECT.DM_BREAK0_BYTE_SELECT                                      = c_bits(DM_BREAK0_BYTE_SELECT, 0, 3, 0xf, 4, "RW", "")
DM_BREAK0_DATA_MASK                                                              = c_reg(0xfffffe48, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Mask value (for read data and write data) when DEBUG_DM_DATA_MATCH_EN_BREAK0 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK0_DATA_VALUE                                                             = c_reg(0xfffffe44, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Read data or write data value to check for when DEBUG_DM_DATA_MATCH_EN_BREAK0 is set. Note that data value is always 32-bit so for example to hit on byte value 0xAA at offset 0x1, DM_BREAK0_BYTE_SELECT, DM_BREAK0_DATA_VALUE  and DM_BREAK0_DATA_MASK should be configured to 0x2, 0xAA00 and 0xFF00 respectively.", "", "", 0, 1, "", "", 0)
DM_BREAK0_DATA_VALUE.DM_BREAK0_DATA_VALUE                                        = c_bits(DM_BREAK0_DATA_VALUE, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK0_END_ADDR                                                               = c_reg(0xfffffe04, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "See comments under DM_BREAK0_START_ADDR.", "", "", 0, 1, "", "", 0)
DM_BREAK0_END_ADDR.DM_BREAK0_END_ADDR                                            = c_bits(DM_BREAK0_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK0_START_ADDR                                                             = c_reg(0xfffffe00, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Along with DM_BREAK0_END_ADDR and the control bits in DEBUG these allow a debugger to configure a Data breakpoint that will be fired on data accesses in the address range DM_BREAK0_START_ADDR -> DM_BREAK0_END_ADDR (inclusive). The data breakpoint may be fired on memory reads, memory writes, or either.  This is selected by the appropriate bits (DEBUG_DM_WRITE_BREAK0 and DEBUG_DM_READ_BREAK0) in the DEBUG register.  The LS 2-bits of these address registers must be zero (but you can still trap on an individual byte or halfword using DEBUG_DM_BYTE_MATCH_EN_BREAK0 feature).", "", "", 0, 1, "", "", 0)
DM_BREAK0_START_ADDR.DM_BREAK0_START_ADDR                                        = c_bits(DM_BREAK0_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK1_BYTE_SELECT                                                            = c_reg(0xfffffe4c, 1, 1, 0, "RW", 4, 0, 0, 0, "k32_debug_prog_flow", "", "Byte-enables to check for when when DEBUG_DM_BYTE_MATCH_EN_BREAK1 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK1_BYTE_SELECT.DM_BREAK1_BYTE_SELECT                                      = c_bits(DM_BREAK1_BYTE_SELECT, 0, 3, 0xf, 4, "RW", "")
DM_BREAK1_DATA_MASK                                                              = c_reg(0xfffffe54, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Mask value (for read data and write data) when DEBUG_DM_DATA_MATCH_EN_BREAK1 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK1_DATA_VALUE                                                             = c_reg(0xfffffe50, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Read data or write data value to check for when DEBUG_DM_DATA_MATCH_EN_BREAK1 is set. Note that data value is always 32-bit so for example to hit on halfword value 0xBBBB at offset 0x2, DM_BREAK1_BYTE_SELECT, DM_BREAK1_DATA_VALUE and DM_BREAK1_DATA_MASK should be configured to 0xC, 0xBBBB0000 and 0xFFFF0000 respectively.", "", "", 0, 1, "", "", 0)
DM_BREAK1_DATA_VALUE.DM_BREAK1_DATA_VALUE                                        = c_bits(DM_BREAK1_DATA_VALUE, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK1_END_ADDR                                                               = c_reg(0xfffffe0c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "See comments under DM_BREAK1_END_ADDR.", "", "", 0, 1, "", "", 0)
DM_BREAK1_END_ADDR.DM_BREAK1_END_ADDR                                            = c_bits(DM_BREAK1_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK1_START_ADDR                                                             = c_reg(0xfffffe08, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "This allows a second data breakpoint to be configured.  See comments under DM_BREAK0_START_ADDR.", "", "", 0, 1, "", "", 0)
DM_BREAK1_START_ADDR.DM_BREAK1_START_ADDR                                        = c_bits(DM_BREAK1_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
EXTERNAL_BREAK                                                                   = c_reg(0xfffffe38, 1, 1, 0, "RW", 2, 0, 0, 0, "k32_debug_prog_flow", "", "External breakpoint send/receive enables.", "", "", 0, 1, "", "", 0)
EXTERNAL_BREAK.EXTERNAL_BREAK_RECEIVE_EN                                         = c_bits(EXTERNAL_BREAK, 0, 0, 0x1, 1, "RW", "Enable receiving external breakpoints. When set, the EXTERNAL_BREAK_STATUS register will become set when an external breakpoint event occurs.")
EXTERNAL_BREAK.EXTERNAL_BREAK_SEND_EN                                            = c_bits(EXTERNAL_BREAK, 1, 1, 0x2, 1, "RW", "Enable sending external breakpoints.")
EXTERNAL_BREAK_STATUS                                                            = c_reg(0xfffffe58, 1, 1, 0, "RW", 1, 0, 1, 0, "k32_debug_prog_flow", "", "Status of external breakpoint logic (read only), if set this means the core has received an external breakpoint indication. Whether the core will actually stop depends on EXTERNAL_BREAK_RECEIVE_EN. Write 1 to this bit to clear the status, unstalling the core if it was stalled due to this.", "", "", 0, 1, "", "", 0)
EXTERNAL_BREAK_STATUS.EXTERNAL_BREAK_STATUS                                      = c_bits(EXTERNAL_BREAK_STATUS, 0, 0, 0x1, 1, "RW", "")
INTERPROC_BREAK                                                                  = c_reg(0xfffffe3c, 1, 1, 0, "RW", 2, 0, 0, 0, "k32_debug_prog_flow", "", "Interprocessor breakpoint send/receive enables.", "", "", 0, 1, "", "", 0)
INTERPROC_BREAK.INTERPROC_BREAK_RECEIVE_EN                                       = c_bits(INTERPROC_BREAK, 0, 0, 0x1, 1, "RW", "Enable receiving interprocessor breakpoints.")
INTERPROC_BREAK.INTERPROC_BREAK_SEND_EN                                          = c_bits(INTERPROC_BREAK, 1, 1, 0x2, 1, "RW", "Enable sending interprocessor breakpoints.")
PM_BREAK0_ADDR                                                                   = c_reg(0xfffffe10, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Sets the address (in bytes) of program breakpoint 0.  The breakpoint is enabled by the DEBUG_PM_BREAK0 control bit in the DEBUG register.", "", "", 0, 1, "", "", 0)
PM_BREAK0_ADDR.PM_BREAK0_ADDR                                                    = c_bits(PM_BREAK0_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK1_ADDR                                                                   = c_reg(0xfffffe14, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 1, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK1_ADDR.PM_BREAK1_ADDR                                                    = c_bits(PM_BREAK1_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK2_ADDR                                                                   = c_reg(0xfffffe18, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 2, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK2_ADDR.PM_BREAK2_ADDR                                                    = c_bits(PM_BREAK2_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK3_ADDR                                                                   = c_reg(0xfffffe1c, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 3, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK3_ADDR.PM_BREAK3_ADDR                                                    = c_bits(PM_BREAK3_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK4_ADDR                                                                   = c_reg(0xfffffe20, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 4, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK4_ADDR.PM_BREAK4_ADDR                                                    = c_bits(PM_BREAK4_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK5_ADDR                                                                   = c_reg(0xfffffe24, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 5, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK5_ADDR.PM_BREAK5_ADDR                                                    = c_bits(PM_BREAK5_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK6_ADDR                                                                   = c_reg(0xfffffe28, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 6, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK6_ADDR.PM_BREAK6_ADDR                                                    = c_bits(PM_BREAK6_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK7_ADDR                                                                   = c_reg(0xfffffe2c, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 7, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK7_ADDR.PM_BREAK7_ADDR                                                    = c_bits(PM_BREAK7_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_PC                                                                       = c_reg(0xffffff00, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Reading this register returns the current Program Counter (PC) of Kalimba (as a byte address). Writing to this register will set Kalimba's PC so that execution will commence from that address when it is started.", "", "", 0, 1, "", "", 0)
REGFILE_PC.REGFILE_PC                                                            = c_bits(REGFILE_PC, 0, 31, 0xffffffff, 32, "RW", "")
STATUS                                                                           = c_reg(0xfffffe34, 1, 0, 0, "R", 17, 0, 0, 0, "k32_debug_prog_flow", "", "A status register for the debugger to find out the state of the Processor.", "", "", 0, 1, "", "", 0)
STATUS.STATUS_RUNNING                                                            = c_bits(STATUS, 0, 0, 0x1, 1, "R", "If set indicates that Kalimba is Runing.")
STATUS.STATUS_PM_BREAK                                                           = c_bits(STATUS, 1, 1, 0x2, 1, "R", "If set indicates that Kalimba has hit a Program Memory breakpoint: PM_BREAK0_ADDR to PM_BREAK7_ADDR.")
STATUS.STATUS_DM_BREAK0                                                          = c_bits(STATUS, 2, 2, 0x4, 1, "R", "If set indicates that Data Breakpoint 0 has been hit. See DM_BREAK0_START_ADDR and friends.")
STATUS.STATUS_DM_BREAK1                                                          = c_bits(STATUS, 3, 3, 0x8, 1, "R", "If set indicates that Data Breakpoint 1 has been hit. See DM_BREAK1_START_ADDR and friends.")
STATUS.STATUS_DUMMY                                                              = c_bits(STATUS, 4, 4, 0x10, 1, "R", "Unused bit (there for legacy purposes).")
STATUS.STATUS_PM_WAIT_IN                                                         = c_bits(STATUS, 5, 5, 0x20, 1, "R", "If set indicates that a WAIT signal is being input to Kalimba core on the PM bus.")
STATUS.STATUS_DM1_WAIT_IN                                                        = c_bits(STATUS, 6, 6, 0x40, 1, "R", "If set indicates that a WAIT signal is being input to Kalimba core on the DM1 bus.")
STATUS.STATUS_DM2_WAIT_IN                                                        = c_bits(STATUS, 7, 7, 0x80, 1, "R", "If set indicates that a WAIT signal is being input to Kalimba core on the DM2 bus.")
STATUS.STATUS_RETRYPMREAD                                                        = c_bits(STATUS, 8, 8, 0x100, 1, "R", "Low level debug information: Indicates state of RetryPmRead signal.")
STATUS.STATUS_DLYRUNNING                                                         = c_bits(STATUS, 9, 9, 0x200, 1, "R", "Low level debug information: Indicates state of DlyRunning signal.")
STATUS.STATUS_SINGSTEPCOMP                                                       = c_bits(STATUS, 10, 10, 0x400, 1, "R", "If set indicates that a single step operation has completed. See DEBUG_STEP bit in DEBUG register for more info.")
STATUS.STATUS_PROCESSING                                                         = c_bits(STATUS, 11, 11, 0x800, 1, "R", "Low level debug information: Indicates state of Processing signal.")
STATUS.STATUS_EXECUTING                                                          = c_bits(STATUS, 12, 12, 0x1000, 1, "R", "Low level debug information: Indicates state of Executing signal.")
STATUS.STATUS_STALLEDPM                                                          = c_bits(STATUS, 13, 13, 0x2000, 1, "R", "Low level debug information: Indicates state of StalledPM signal.")
STATUS.STATUS_EXCEPTION_BREAK                                                    = c_bits(STATUS, 14, 14, 0x4000, 1, "R", "If set indicates that an Exception Breakpoint has occured.  This can be cleared by clearing (and re-enabling) the EXCEPTION_EN register.")
STATUS.STATUS_EXTERNAL_BREAK                                                     = c_bits(STATUS, 15, 15, 0x8000, 1, "R", "If set indicates that external subsystem Breakpoint has occured.  This is the same as EXTERNAL_BREAK_STATUS. This can be cleared by writing to EXTERNAL_BREAK_STATUS.")
STATUS.STATUS_INTERPROC_BREAK                                                    = c_bits(STATUS, 16, 16, 0x10000, 1, "R", "If set indicates that interprocessor Breakpoint has occured.  This can be cleared by clearing the breakpoint on the source processor.")

# -- Kalimba 32-bit Register File Debug Control registers.  Note: All these registers are only accessable from SPI and T-Bus, not from Kalimba core itself. --

REGFILE_B0                                                                       = c_reg(0xffffffa4, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B0 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B0.REGFILE_B0                                                            = c_bits(REGFILE_B0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_B1                                                                       = c_reg(0xffffffa8, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B1 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B1.REGFILE_B1                                                            = c_bits(REGFILE_B1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_B4                                                                       = c_reg(0xffffffac, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B4 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B4.REGFILE_B4                                                            = c_bits(REGFILE_B4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_B5                                                                       = c_reg(0xffffffb0, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B5 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B5.REGFILE_B5                                                            = c_bits(REGFILE_B5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_FP                                                                       = c_reg(0xffffffb4, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "FP register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_FP.REGFILE_FP                                                            = c_bits(REGFILE_FP, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I0                                                                       = c_reg(0xffffff4c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I0 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I0.REGFILE_I0                                                            = c_bits(REGFILE_I0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I1                                                                       = c_reg(0xffffff50, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I1 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I1.REGFILE_I1                                                            = c_bits(REGFILE_I1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I2                                                                       = c_reg(0xffffff54, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I2 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I2.REGFILE_I2                                                            = c_bits(REGFILE_I2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I3                                                                       = c_reg(0xffffff58, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I3 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I3.REGFILE_I3                                                            = c_bits(REGFILE_I3, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I4                                                                       = c_reg(0xffffff5c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I4 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I4.REGFILE_I4                                                            = c_bits(REGFILE_I4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I5                                                                       = c_reg(0xffffff60, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I5 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I5.REGFILE_I5                                                            = c_bits(REGFILE_I5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I6                                                                       = c_reg(0xffffff64, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I6 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I6.REGFILE_I6                                                            = c_bits(REGFILE_I6, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I7                                                                       = c_reg(0xffffff68, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I7 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I7.REGFILE_I7                                                            = c_bits(REGFILE_I7, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L0                                                                       = c_reg(0xffffff7c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L0 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L0.REGFILE_L0                                                            = c_bits(REGFILE_L0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L1                                                                       = c_reg(0xffffff80, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L1 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L1.REGFILE_L1                                                            = c_bits(REGFILE_L1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L4                                                                       = c_reg(0xffffff84, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L4 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L4.REGFILE_L4                                                            = c_bits(REGFILE_L4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L5                                                                       = c_reg(0xffffff88, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L5 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L5.REGFILE_L5                                                            = c_bits(REGFILE_L5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M0                                                                       = c_reg(0xffffff6c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M0 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M0.REGFILE_M0                                                            = c_bits(REGFILE_M0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M1                                                                       = c_reg(0xffffff70, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M1 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M1.REGFILE_M1                                                            = c_bits(REGFILE_M1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M2                                                                       = c_reg(0xffffff74, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M2 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M2.REGFILE_M2                                                            = c_bits(REGFILE_M2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M3                                                                       = c_reg(0xffffff78, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M3 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M3.REGFILE_M3                                                            = c_bits(REGFILE_M3, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_NUM_CORE_STALLS                                                          = c_reg(0xffffff94, 1, 0, 0, "R", 32, 0, 0, 0, "k32_debug_regfile", "", "A debugging register than reports the number of processor core stalls that have occured (this covers instruction decoding related stalls only and does not include stalls due to DM and PM memory bus waits or delays within the prefetch logic).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
REGFILE_NUM_CORE_STALLS.REGFILE_NUM_CORE_STALLS                                  = c_bits(REGFILE_NUM_CORE_STALLS, 0, 31, 0xffffffff, 32, "R", "")
REGFILE_NUM_INSTRS                                                               = c_reg(0xffffff90, 1, 0, 0, "R", 32, 0, 0, 0, "k32_debug_regfile", "", "A debugging register than reports the number of processor instructions that have been executed.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
REGFILE_NUM_INSTRS.REGFILE_NUM_INSTRS                                            = c_bits(REGFILE_NUM_INSTRS, 0, 31, 0xffffffff, 32, "R", "")
REGFILE_NUM_RUNCLKS                                                              = c_reg(0xffffff8c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_debug_regfile", "", "A debugging register than reports the number of processor clock cycles that have occured whilst running.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
REGFILE_NUM_RUNCLKS.REGFILE_NUM_RUNCLKS                                          = c_bits(REGFILE_NUM_RUNCLKS, 0, 31, 0xffffffff, 32, "R", "")
REGFILE_R0                                                                       = c_reg(0xffffff14, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r0 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R0.REGFILE_R0                                                            = c_bits(REGFILE_R0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R1                                                                       = c_reg(0xffffff18, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r1 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R1.REGFILE_R1                                                            = c_bits(REGFILE_R1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R10                                                                      = c_reg(0xffffff3c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r10 register in Bank 1", "", "", 0, 1, "", "", 0)
REGFILE_R10.REGFILE_R10                                                          = c_bits(REGFILE_R10, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R2                                                                       = c_reg(0xffffff1c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r2 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R2.REGFILE_R2                                                            = c_bits(REGFILE_R2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R3                                                                       = c_reg(0xffffff20, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r3 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R3.REGFILE_R3                                                            = c_bits(REGFILE_R3, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R4                                                                       = c_reg(0xffffff24, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r4 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R4.REGFILE_R4                                                            = c_bits(REGFILE_R4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R5                                                                       = c_reg(0xffffff28, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r5 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R5.REGFILE_R5                                                            = c_bits(REGFILE_R5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R6                                                                       = c_reg(0xffffff2c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r6 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R6.REGFILE_R6                                                            = c_bits(REGFILE_R6, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R7                                                                       = c_reg(0xffffff30, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r7 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R7.REGFILE_R7                                                            = c_bits(REGFILE_R7, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R8                                                                       = c_reg(0xffffff34, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r8 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R8.REGFILE_R8                                                            = c_bits(REGFILE_R8, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R9                                                                       = c_reg(0xffffff38, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r9 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R9.REGFILE_R9                                                            = c_bits(REGFILE_R9, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RFLAGS                                                                   = c_reg(0xffffff44, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "rFlags register in Bank 1", "", "", 0, 1, "", "", 0)
REGFILE_RFLAGS.N_FLAG                                                            = c_bits(REGFILE_RFLAGS, 0, 0, 0x1, 1, "RW", "Negative flag (N).  This is set if the result of the instruction is negative, i.e. if the most significant bit is set, and cleared otherwise.")
REGFILE_RFLAGS.Z_FLAG                                                            = c_bits(REGFILE_RFLAGS, 1, 1, 0x2, 1, "RW", "Zero flag (Z).  This is set if the result of the instruction is zero, and cleared otherwise.")
REGFILE_RFLAGS.C_FLAG                                                            = c_bits(REGFILE_RFLAGS, 2, 2, 0x4, 1, "RW", "Carry flag (C).  The state of the carry flag is: For an addition, C is set if the addition produced a carry, i.e. an unsigned overflow, and is cleared otherwise; For a subtraction, C is cleared if the subtraction produces a borrow, i.e. an unsigned underflow, and is set otherwise.  For other operations (including multiply accumulate), C is cleared.")
REGFILE_RFLAGS.V_FLAG                                                            = c_bits(REGFILE_RFLAGS, 3, 3, 0x8, 1, "RW", "oVerflow flag (V).  The state of the overflow flag is: For addition, subtraction, arithmetic shifts, integer multiplies and multiply accumulates, V is set if signed overflow occurred, regarding the operands and result as 2's complement signed integers, and is cleared otherwise; The setting/clearing of the V flag for the rMAC and/or rMACB registers occurs if there is overflow past the 72nd bit, whereas for the 32-bit registers it is if overflow occurs past the 32nd bit; V cleared for other operations.")
REGFILE_RFLAGS.UD_FLAG                                                           = c_bits(REGFILE_RFLAGS, 4, 4, 0x10, 1, "RW", "User Definable flag (UD).  A special USERDEF condition code is TRUE if this flag is set and FALSE if this flag is clear. Use it in code sections to improve speed and code clarity where a particular instruction needs to be executed conditionally.")
REGFILE_RFLAGS.SV_FLAG                                                           = c_bits(REGFILE_RFLAGS, 5, 5, 0x20, 1, "RW", "Sticky oVerflow flag (SV).  Set whenever V is set but can only be cleared by software explicitly writing to the rFlags register.")
REGFILE_RFLAGS.BR_FLAG                                                           = c_bits(REGFILE_RFLAGS, 6, 6, 0x40, 1, "RW", "Bit Reverse flag (BR).  If set, the output of AG1 (index registers I0 to I3) is bit-reversed before being driven to the address bus. Here bitreversing applies to the least significant 31 bits. The most significant bit selects the data memory used so it stays in place.")
REGFILE_RFLAGS.UM_FLAG                                                           = c_bits(REGFILE_RFLAGS, 7, 7, 0x80, 1, "RW", "User Mode flag (UM).  If set, interrupts are serviced. On entry to the interrupt service routine (default PC address 0x0002), this flag is cleared so no further interrupts are serviced unless the flag is manually set, for example to support interrupt priority. Execution of a rti instruction sets this flag to the value of INT_UM_FLAG (normally set unless altered in software).")
REGFILE_RFLAGS.INT_N_FLAG                                                        = c_bits(REGFILE_RFLAGS, 8, 8, 0x100, 1, "RW", "Just before entering the interrupt service routine, each element of rFlags is copied into its interrupt duplicate.  E.g. UM_FLAG is copied into INT_UM_FLAG. With the exception of the UM_FLAG, all bits remain unchanged. UM_FLAG is cleared and remains cleared unless software enables it. When returning from interrupt, using the rti instruction, the interrupt bits are copied back, over-writing the non-interrupt values.")
REGFILE_RFLAGS.INT_Z_FLAG                                                        = c_bits(REGFILE_RFLAGS, 9, 9, 0x200, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_C_FLAG                                                        = c_bits(REGFILE_RFLAGS, 10, 10, 0x400, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_V_FLAG                                                        = c_bits(REGFILE_RFLAGS, 11, 11, 0x800, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_UD_FLAG                                                       = c_bits(REGFILE_RFLAGS, 12, 12, 0x1000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_SV_FLAG                                                       = c_bits(REGFILE_RFLAGS, 13, 13, 0x2000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_BR_FLAG                                                       = c_bits(REGFILE_RFLAGS, 14, 14, 0x4000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_UM_FLAG                                                       = c_bits(REGFILE_RFLAGS, 15, 15, 0x8000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.UNUSED                                                            = c_bits(REGFILE_RFLAGS, 16, 31, 0xffff0000, 16, "RW", "Ununsed field in rFLAGS register")
REGFILE_RLINK                                                                    = c_reg(0xffffff40, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "rLink register in Bank 1", "", "", 0, 1, "", "", 0)
REGFILE_RLINK.REGFILE_RLINK                                                      = c_bits(REGFILE_RLINK, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC0                                                                    = c_reg(0xffffff0c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "LS 32-bits (bits 31:0) of the full 72-bit rMAC register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC0.REGFILE_RMAC0                                                      = c_bits(REGFILE_RMAC0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC1                                                                    = c_reg(0xffffff08, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "Middle 32-bits (bits 63:32) of the full 72-bit rMAC register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC1.REGFILE_RMAC1                                                      = c_bits(REGFILE_RMAC1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC2                                                                    = c_reg(0xffffff04, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "MS 8-bits (bits 71:64) of the full 72-bit rMAC register.  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC2.REGFILE_RMAC2                                                      = c_bits(REGFILE_RMAC2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC24                                                                   = c_reg(0xffffff10, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "A rounded and saturated 32-bit version of the rMAC register.  This is a bank 1 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC24.REGFILE_RMAC24                                                    = c_bits(REGFILE_RMAC24, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB0                                                                   = c_reg(0xffffffa0, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "LS 32-bits (bits 31:0) of the full 72-bit rMACB register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB0.REGFILE_RMACB0                                                    = c_bits(REGFILE_RMACB0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB1                                                                   = c_reg(0xffffff9c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "Middle 32-bits (bits 63:32) of the full 72-bit rMACB register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB1.REGFILE_RMACB1                                                    = c_bits(REGFILE_RMACB1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB2                                                                   = c_reg(0xffffff98, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "MS 8-bits (bits 71:64) of the full 72-bit rMACB register.  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB2.REGFILE_RMACB2                                                    = c_bits(REGFILE_RMACB2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB24                                                                  = c_reg(0xffffff48, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "A rounded and saturated 32-bit version of the rMACB register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB24.REGFILE_RMACB24                                                  = c_bits(REGFILE_RMACB24, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_SP                                                                       = c_reg(0xffffffb8, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "SP register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_SP.REGFILE_SP                                                            = c_bits(REGFILE_SP, 0, 31, 0xffffffff, 32, "RW", "")

# -- Kalimba 32-bit DoLoop Cache Control registers. --

DOLOOP_CACHE_CONFIG                                                              = c_reg(0xffffe130, 1, 1, 0, "RW", 2, 3, 0, 0, "k32_doloop_cache", "", "Configures the DoLoop cache for Kalimba.", "", "", 0, 1, "", "", 0)
DOLOOP_CACHE_CONFIG.DOLOOP_CACHE_CONFIG_DOLOOP_EN                                = c_bits(DOLOOP_CACHE_CONFIG, 0, 0, 0x1, 1, "RW", "Enables the flip-flop based caching of the first 32 instructions of do loops.  This should lower power consumption for programs that make heavy use of do loops.")
DOLOOP_CACHE_CONFIG.DOLOOP_CACHE_CONFIG_COUNTERS_EN                              = c_bits(DOLOOP_CACHE_CONFIG, 1, 1, 0x2, 1, "RW", "Enables the cache performance counters (HIT and MISS counts) for use during debugging.")
DOLOOP_CACHE_FILL_COUNT                                                          = c_reg(0xffffe138, 1, 0, 0, "R", 32, 0, 0, 0, "k32_doloop_cache", "", "A debugging register that counts the number of DoLoop cache instruction fills.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will always read as zero if the DOLOOP_CACHE_CONFIG_COUNTERS_EN bit of DOLOOP_CACHE_CONFIG has not been enabled.", "", "", 0, 1, "", "", 0)
DOLOOP_CACHE_FILL_COUNT.DOLOOP_CACHE_FILL_COUNT                                  = c_bits(DOLOOP_CACHE_FILL_COUNT, 0, 31, 0xffffffff, 32, "R", "")
DOLOOP_CACHE_HIT_COUNT                                                           = c_reg(0xffffe134, 1, 0, 0, "R", 32, 0, 0, 0, "k32_doloop_cache", "", "A debugging register that counts the number of DoLoop cache instruction hits.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will always read as zero if the DOLOOP_CACHE_CONFIG_COUNTERS_EN bit of DOLOOP_CACHE_CONFIG has not been enabled.", "", "", 0, 1, "", "", 0)
DOLOOP_CACHE_HIT_COUNT.DOLOOP_CACHE_HIT_COUNT                                    = c_bits(DOLOOP_CACHE_HIT_COUNT, 0, 31, 0xffffffff, 32, "R", "")

AUDIO_PCM_REG_BANK_SELECT                                                        = c_reg(0xffff8de8, 1, 1, 0, "RW", 2, 0, 0, 0, "audio", "", "", "", "", 0, 1, "", "", 0)
AUDIO_SPDIF_REG_BANK_SELECT                                                      = c_reg(0xffff8dec, 1, 1, 0, "RW", 2, 0, 0, 0, "audio", "", "", "", "", 0, 1, "", "", 0)
