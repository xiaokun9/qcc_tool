r"""
%(prog)s <command> [parameters]

A Python environment management tool that allows a `workspace` to
be created and used for the duration of the current python session.
The workspace extends the set of python packages and scripts available in the
python environment without affecting the base environment or virtual environment.

There are 3 supported methods of workspace discovery

Explicit:
    This will operate on a workspace defined by the users requirements file

    CLI: workspace <command> [-r my_dir/my_requirements.txt]
    API: workspace.<method>("my_dir/my_requirements.txt")

Environment-driven:
    This will operate on workspace requirements defined by the environment variable
    workspace.ENV_VAR_NAME

    $env:_ADK_WORKSPACE_PYTHON37="C:/env_dir/env_requiremnts.txt"
    CLI: workspace <command>
    API: workspace.<method>()

Automatic:
    This will attempt to find an expected stem "tools/python_workspace/requirements.txt" (default)
    in, beside or above the current working directory path

    CLI: workspace <command>
    would find a workspace located at C:/chipcode/tools/python_workspace/requirements.txt
    from:
    C:/chipcode
    C:/chipcode/tools/my_tool/my_dir
    C:/chipcode/other_stuff/somewhere_else/on/the/same/root

CLI:
    install - install a workspace
    delete - remove a workspace
    locate - get location of a workspace requirements file
    scripts - get location of workspace executables suitable for adding to PATH variable
    packages - get location of workspace packages suitable for adding to PYTHONPATH variable
    status - get the current status of a workspace
    documents - list locations of embedded documentation

API:
    workspace = ADKWorkspace(requirements_txt="")
    workspace.install()
    workspace.load()
    workspace.delete()
    workspace.status()
    status = workspace.status(use_stdout=False)
    pth = workspace.requirements()
    pth = workspace.scripts()
    pths = workspace.documents()

e.g.
    import workspace
    workspace.load()
    ..
    import workspace_package

"""

#
# Copyright Qualcomm Technologies Inc, 2022.
# All Rights Reserved
#

# Python imports
import argparse
import html
import logging
import os
from pathlib import Path
from pprint import pprint
import re
import sys
import shutil
import subprocess
from threading import Thread, Event
import time
import traceback
from types import SimpleNamespace
from typing import Iterator, Tuple
from xml.etree.ElementTree import ElementTree
import pkgutil
import pkg_resources

# Module data
_VERSION = "1.0.0"
PYENV = str(sys.version_info.major) + str(sys.version_info.minor)
ENV_VAR_NAME = "_ADK_WORKSPACE_PYTHON" + PYENV
WORKSPACE_DIR = "workspace_env" + PYENV
LOG = logging.getLogger("workspace")
DEFAULT_WORKSPACE_PATTERN = "tools/python_workspace/requirements.txt"
FAMILY_WORKSPACE_PATTERN = "tools/python_workspace/*/requirements.txt"
OPTIONS = SimpleNamespace(FAMILY="", SHOW_DEBUG=False, HIDE_INFO=False)
CHOICES = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
TOOLKIT_ROOT = Path(os.environ.get("VIRTUAL_ENV", '.')).parent.parent.absolute()

class WorkspaceNotFound(FileNotFoundError):
    """No workspace could be found."""

class WorkspaceNotInstalled(RuntimeError):
    """An error occurred while installing the workspace."""

def _arg_parser():
    """Perform the command line parsing."""
    parser = argparse.ArgumentParser(
        prog="workspace", usage=__doc__)
    parser.add_argument(
        "-v", "--verbose", dest="SHOW_DEBUG", action="store_true",
        help='Show debug messages')
    parser.add_argument(
        "-q", "--quiet", dest="HIDE_INFO", action="store_true",
        help='Hide info messages')
    parser.add_argument(
        "--version", dest="SHOW_VERSION", action="store_true",
        help="Show version")
    parser.add_argument(
        "-r", "--requirement",
        help="requirements file path")
    parser.add_argument(
        "-f", "--family", dest="FAMILY", default="",
        help='Optional family-specific workspace name')

    subparsers = parser.add_subparsers(
        help="command", dest="command")

    commands = [
        ("status", "Show workspace status"),
        ("install", "Install the workspace from a requirements file"),
        ("delete", "Delete the current workspace"),
        ("locate", "Find the workspace requirements file"),
        ("scripts", "Find the workspace executable script location"),
        ("documents", "Find any documentation in the workspace packages"),
        ("packages", "Find the workspace packages' location"),
    ]

    subparser = {}

    for command, help_text in commands:
        subparser[command] = subparsers.add_parser(command, help=help_text)

    subparser["install"].add_argument(
        "-U", "--upgrade", dest="FORCE_INSTALL", action="store_true", default=False,
        help="use pip install --upgrade to force package reinstall")

    for cmd in ("locate", "scripts", "packages", "documents"):
        subparser[cmd].add_argument(
            "-o", "--output", dest="OUTPUT", default="",
            help='Return the result in a file', type=Path)

    return parser

class KeepStdoutActive(Thread):
    """
    A Thread subclass designed to provide regular updates
    to stdout, preventing a potentially long-running pip install subprocess
    from being mis-characterized as dead

    done: threading.Event used to end thread
    delay: delay in seconds
    """
    def __init__(self, done: Event, message, delay=60):
        Thread.__init__(self)
        # prevent this process from blocking main python process termination
        self.daemon = True  # Thread property
        self.done = done
        self.delay = delay
        self.msg = message

    def run(self):
        """poke stdout until event is set from main process"""
        start = time.time()
        # wait for delay before first message
        time.sleep(self.delay)
        # end Thread when done event is received
        while not self.done.is_set():
            # let user know we are still working
            duration = time.time() - start
            logging.info("\n%s (%.0fs)", self.msg, duration)
            time.sleep(self.delay)

# Let Path instance determine OS Specific Path parent class
class RequirementsPath(Path().__class__):
    """Path to a requirements file"""

class EnvVarPth(RequirementsPath):
    """Path from environment variable"""
    @property
    def source(self):
        return "Environment variable " + ENV_VAR_NAME

class UserSpecifiedPath(RequirementsPath):
    """Path from command line -r option"""
    source = "Command line parameter"

class DiscoveredPath(RequirementsPath):
    """Path discovered from working directory"""
    source = "Discovered by default from current working directory"

class UserSelectedPath(RequirementsPath):
    """Path selected by user"""
    source = "Chosen by user from current working directory"

class ADKWorkspace:
    """
    An ADK workspace object
    """
    def __init__(self, requirements_txt=""):
        if requirements_txt:
            self._rpth = UserSpecifiedPath(requirements_txt)
            if not self._rpth.is_file():
                raise WorkspaceNotFound(f"No such file {self.rpth}")
        else:
            self._rpth = None

    @property
    def rpth(self):
        """Workspace requirements.txt file path property"""
        # if we already have a requirements path just return it
        # otherwise try to find one and return that
        if self._rpth is None:
            self.find_requirements_by_envvar()
        if self._rpth is None:
            self.find_requirements_by_search()
        if self._rpth is None:
            raise WorkspaceNotFound("No ADK workspace requirements were found")
        if OPTIONS.SHOW_DEBUG:
            print(f"Using {repr(self._rpth)}")
        return self._rpth.absolute()

    @property
    def workspace_root(self) -> Path:
        """
        The directory where workspace-specific packages will be installed
        forma

        NOTE: The path will not exist until the workspace is installed.
        """
        return self.rpth.parent / WORKSPACE_DIR

    @property
    def packages(self) -> str:
        """
        The directory where modules for PYTHONPATH will be installed (OS)

        NOTE: The path will not exist until the workspace is installed.
        """
        return str(self.workspace_root)

    @property
    def scripts(self) -> str:
        """
        The directory where executables for PATH will be installed (OS)

        NOTE: The path will not exist until the workspace is installed.
        """
        return str(self.workspace_root / 'bin')

    @property
    def requirements(self) -> str:
        """
        The posix-format path to workspace requirements.txt
        """
        return self.rpth.as_posix()

    def install(self, upgrade=False):
        """Install a workspace environment defined by a requirements file."""

        # identify the workspace requirements and install location
        workspace_stamp = self.workspace_root / '.workspace_installed'
        toolkit_wheels = TOOLKIT_ROOT / "tools" / "python" / "wheels"
        toolkit_sdk_xml = TOOLKIT_ROOT / "sdk.xml"
        if toolkit_sdk_xml.exists():
            etree = ElementTree(file=toolkit_sdk_xml)
            toolkit_uuid = etree.find("id/uuid").text
        else:
            toolkit_uuid = "unknown"

        # Create the pip command to perform installation
        cmd = [
            sys.executable,
            "-m", "pip", "install",
            "--disable-pip-version-check",
            "--progress-bar", "off",
            "--target", self.workspace_root.as_posix(),
            "-f", toolkit_wheels.as_posix(),
            "--requirement", self.requirements]

        if workspace_stamp.exists():
            workspace_uuid = workspace_stamp.read_text()

            if toolkit_uuid != workspace_uuid:
                self.delete()
            elif upgrade:
                workspace_stamp.unlink()
                cmd.append("--upgrade")
            else:
                return

        # Let the user know it may take some time and perform install
        LOG.info("Installing %s...", self.requirements)
        LOG.debug("PIP command:\n%s", ' '.join(cmd))

        stop_event = Event()
        thread = KeepStdoutActive(stop_event, "ADK Workspace install in progress...")

        try:
            thread.start()
            proc = subprocess.run(
                cmd,
                check=False,
                cwd=self.rpth.parent,
                env=dict(os.environ),
                stdout=sys.stdout,
                stderr=sys.stderr,
                bufsize=1)
        finally:
            stop_event.set()

        if proc.returncode:
            raise WorkspaceNotInstalled(self.requirements)

        workspace_stamp.write_text(toolkit_uuid)


    def load(self, upgrade=False):
        """
        Load a workspace for a into the current python environment.

        If a workspace is not currently installed, the workspace will be
        installed first then loaded.
        """
        # Install the workspace if necessary
        if not self.workspace_root.exists() or upgrade:
            self.install()

        # Activate the workspace
        pkg_resources.working_set.add_entry(self.workspace_root)
        for dist in pkg_resources.find_distributions(self.workspace_root, True):
            LOG.info("Loaded %s", dist)

        # Add installed scripts to os.path
        # This does not propagate to the command line environment unfortunately
        scripts_txt = str(self.scripts)
        if scripts_txt not in os.environ["PATH"]:
            LOG.debug("Adding %s to path", self.scripts)
            os.environ["PATH"] = scripts_txt + os.pathsep + os.environ["PATH"]

        # Return the location of scripts so command line environment can add it
        # to their own path
        return scripts_txt


    def status(self, use_stdout=True):
        """
        Report the current status of a discovered or specified workspace
        to stdout or optionally, with use_stdout=False, via a status string
        as ("NOT AVAILABLE", "AVAILABLE", "INSTALLED").

        workspaces are either not available, available or installed
        """
        try:
            self.rpth
        except WorkspaceNotFound:
            if use_stdout:
                print("Workspace not available")
            status_description = "NOT AVAILABLE"
        else:
            if self.workspace_root.exists():
                if use_stdout:
                    print(
                        "Workspace installed with following packages:\n\n    " +
                        "\n    ".join(
                            map(str,
                                pkg_resources.find_distributions(
                                    self.workspace_root, True))) +
                        "\n")
                status_description = "INSTALLED"
            else:
                if use_stdout:
                    print("Workspace not installed\n")
                status_description = "AVAILABLE"

            print(f"Location method: {self.rpth.source}")
            print(f"Requirements:    {self.requirements}")
            print(f"Workspace:       {self.workspace_root.as_posix()}")
            print(f"Scripts:         {self.scripts}")
            print("Documents:")
            for doc in self.documents():
                print(f"   {self.doc_str(doc)}")

        return status_description

    def delete(self) -> None:
        """
        Delete a workspace.

        If a workspace is installed this will *try* to delete the
        installed files and workspace directory.

        The workspace requirements file will not be deleted.
        """
        if self.workspace_root.exists():
            LOG.info("Deleting %s...", self.workspace_root)
            shutil.rmtree(self.workspace_root)

    @staticmethod
    def doc_str(doc_dict):
        """Convert a document dictionary to a string in the form:
        module [rank] 'title' (path)

        example:
        pyversions [2] 'My Documentation' (C:/Users/xyz/AppData/Local/Temp/tmp1bhfyst5.html)
        """
        return "{module} [{rank}] '{title}' ({location})".format(**doc_dict)

    def documents(self) -> Iterator[Path]:
        """
        Return an iterator that lists the embedded documentation folders
        for all of the packages in the current WorkingSet if this resource
        exists.
        """
        LOG.debug("Listing documents in %s...", self.workspace_root)
        # find docs that have documents as package data
        for dist in pkg_resources.working_set:  # pylint:disable=not-an-iterable
            prj = dist.key

            index_html = 'docs/html/index.html'
            LOG.debug("%s", dist)
            try:
                text = pkgutil.get_data(prj, index_html).decode(encoding="utf8", errors="ignore")
                text = html.unescape(text)
                match = re.search('<title>(.*)</title>', text)
                if match:
                    html_title = match.group(1)
                else:
                    html_title = ''
                yield dict(module=prj,
                           title=html_title,
                           rank=0,
                           location=str(Path(dist.location) / index_html))
            except (FileNotFoundError, AttributeError):
                pass

            for name in dist.get_entry_map('html_documents'):
                LOG.debug("Get documents from this module '%s'.", prj)
                try:
                    func = dist.load_entry_point('html_documents', name)
                    html_document = func()  # call the entry-point function
                    if html_document:
                        rdict = dict(module=prj, rank=1, title="")
                        rdict.update(html_document)
                        yield rdict
                # we have no idea what exception a module may throw
                except:  # pylint:disable=bare-except
                    logging.error("%s", traceback.format_exc())

    def choose_workspace(self, matches):
        """Automatically or manually choose a family or default workspace.
        """
        # Create an option list
        opts = []
        for opt in matches:
            if OPTIONS.FAMILY:
                family = opt.parts[-2]
                if family.upper() == OPTIONS.FAMILY.upper():
                    self._rpth = DiscoveredPath(opt)
                    return
                opts.append(f"{family} ({opt})")
            else:
                opts.append(opt)

        # Check we can use interactive select
        if not sys.stdin.isatty():
            raise RuntimeError("Ambiguous workspace used in a non-interactive environment")

        # Show options
        print("Choose a workspace", file=sys.stderr)
        cancel = "Cancel"
        for idx, opt in enumerate(opts + [cancel]):
            print(f"{CHOICES[idx]} - {opt}", file=sys.stderr)

        # Get the chosen workspace ID
        key = ""
        while key not in CHOICES[:len(opts)+1] or len(key) != 1:
            key = input("Enter a workspace letter or number: ").upper()
            try:
                choice = matches[CHOICES.index(key)]
            except IndexError:
                pass
            else:
                # Select the workspace matching the input
                self._rpth = UserSelectedPath(choice)

    def find_requirements_by_envvar(self):
        """If the environment variable is set try to use that
        """
        if not OPTIONS.FAMILY:
            envvar = os.getenv(ENV_VAR_NAME)
            if envvar:
                rpth = EnvVarPth(envvar)
                if rpth.is_file():
                    self._rpth = rpth
                else:
                    raise WorkspaceNotFound(f"{ENV_VAR_NAME} = {envvar}")

    def find_requirements_by_search(self):
        """Search for a family > generic requirements file
        at, 1 below, or any above the current working directory.
        """
        pth = Path(os.getcwd())
        patterns = [FAMILY_WORKSPACE_PATTERN]
        if not OPTIONS.FAMILY:
            patterns += [DEFAULT_WORKSPACE_PATTERN]
        matches = []
        for pattern in patterns:
            matches += pth.glob("*/" + pattern)
        while pth.parent != pth:
            for pattern in patterns:
                matches += pth.glob(pattern)
            pth = pth.parent
        if matches:
            if len(matches) == 1:
                self._rpth = DiscoveredPath(matches[0])
            else:
                self.choose_workspace(matches)


# compatibility API v0.9 - deprecated
def install(req=""):
    return ADKWorkspace(req).install()

def load(req="", upgrade=False):
    return ADKWorkspace(req).load(upgrade)

def delete(req=""):
    return ADKWorkspace(req).delete()

def status(req="", use_stdout=True):
    return ADKWorkspace(req).status(use_stdout)

def requirements(req=""):
    return ADKWorkspace(req).requirements

def scripts(req=""):
    return ADKWorkspace(req).scripts

def packages(req=""):
    return ADKWorkspace(req).packages

def documents(req=""):
    return ADKWorkspace(req).documents()

def main(args=None):  # pylint: disable=too-many-branches
    """Main entry point for CLI."""
    logging.basicConfig(format='%(levelname)s:%(name)s:%(message)s', level=logging.DEBUG)

    # Parse the command line
    parser = _arg_parser()
    parser.parse_args(args=args, namespace=OPTIONS)

    if OPTIONS.SHOW_DEBUG:
        LOG.setLevel("DEBUG")
    elif OPTIONS.HIDE_INFO:
        LOG.setLevel("WARNING")
    else:
        LOG.setLevel("INFO")

    # handle output to file options
    if hasattr(OPTIONS, "OUTPUT") and OPTIONS.OUTPUT.name:
        # delete the output file to ensure activate fails on error
        try:
            OPTIONS.OUTPUT.unlink()
        except OSError:
            pass

        def _print(txt):
            """write to file"""
            OPTIONS.OUTPUT.write_text(txt)

    else:
        _print = print

    try:

        # Show version and exit
        if OPTIONS.SHOW_VERSION:
            print(_VERSION)
            return 0

        workspace = ADKWorkspace(OPTIONS.requirement)

        # Install a workspace
        if OPTIONS.command == "install":
            if OPTIONS.FORCE_INSTALL:
                workspace.install(upgrade=True)
            else:
                workspace.install(upgrade=False)

        # Return information on a workspace
        elif OPTIONS.command == "status":
            workspace.status()

        # Delete the workspace only
        elif OPTIONS.command == "delete":
            workspace.delete()

        # Return the workspace path
        elif OPTIONS.command == "packages":
            _print(workspace.packages)

        # Return the workspace executables path
        elif OPTIONS.command == "scripts":
            _print(workspace.scripts)

        elif OPTIONS.command == "locate":
            _print(workspace.requirements)

        elif OPTIONS.command == "documents":
            _print("\n".join([workspace.doc_str(doc) for doc in workspace.documents()]))
        else:
            parser.print_usage()
            return 1
        # Return a success status
        return 0

    except BaseException as exc:  # pylint:disable=broad-except
        if OPTIONS.SHOW_DEBUG:
            LOG.exception(exc)
        else:
            print("%s: %s" % (type(exc).__name__, exc))

    # Return a failure status
    return 1
