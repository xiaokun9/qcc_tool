############################################################################
# CONFIDENTIAL
#
# Copyright (c) 2014 - 2016 Qualcomm Technologies International, Ltd.
#   %%version
#
############################################################################
"""
AppCmd Firmware Component (Interface and Implementations)

CS-216183-SP : CuCmd spec
CS-208980-DD : Service records description

Uses:-
- Slt            To lookup device's cucmd field addresses.
- AddressSpace   To interact with the devices CuCmd firmware. 
"""

from .polling_cmd import PollingCmd
from csr.wheels.global_streams import iprint
from csr.wheels.subarray import SubArray
from csr.dev.hw.mmu import MMUPagedBuffer, MMUPageTable, MMUSize
from csr.wheels.bitsandbobs import bytes_to_dwords, dwords_to_bytes, \
                                    create_reverse_lookup, timeout_clock
from csr.interface import mibdb
from csr.dwarf.read_dwarf import DwarfNoSymbol

class AppCmd(PollingCmd):
            
    def __init__(self, fw_env, core, trigger_field):
        """
        Construct AppCmd interface.
        """
        self._core = core
        self._fw_env = fw_env
        self._command = fw_env.globalvars["appcmd_cmd"]
        self._response = fw_env.globalvars["appcmd_rsp"]
        self._parameters = fw_env.globalvars["appcmd_parameters"]
        self._results =    fw_env.globalvars["appcmd_results"]
        self._trigger = trigger_field
        
        type_list = [ "APPCMD_COMMAND_ID", "APPCMD_TEST_ID", "APPCMD_RESPONSE" ]
        self.interface = self._lookup_types_from_elf(type_list)
        self.create_reverse_lookup(self.interface, "APPCMD_RESPONSE", 
                                                "APPCMD_RESPONSE_rev")
        
        rsp_map = {"INVALID_PARAMETERS" : self.AppcmdInvalidParametersError,
                   "INVALID_STATE" : self.AppcmdInvalidStateError,
                   "UNKNOWN_COMMAND" : self.AppCmdUnknownCommandError,
                   "UNIMPLEMENTED" : self.AppCmdUnimplementedError,
                   "INVALID_PARAMETER_MASK" : self.AppcmdInvalidParameterMaskError,
                   "UNSPECIFIED" : self.AppcmdUnspecifiedError,
                   "RESULT_PENDING" : self.AppCmdResponsePending}
        self.response_exception_mapping = {}
        for rsp_name, rsp_excep in rsp_map.items():
            try:
                self.response_exception_mapping\
                            [self.interface["APPCMD_RESPONSE"][rsp_name]] = \
                                            rsp_excep
            except KeyError:
                pass

        #Add a special case to cover apps not responding
        self.response_exception_mapping[0] = self.AppCmdNeverResponded
        self._result_success_value = self.interface["APPCMD_RESPONSE"]["SUCCESS"]
        try:
            self._result_pending_value = self.interface["APPCMD_RESPONSE"]["RESULT_PENDING"]
        except KeyError:
            # For superficial backwards compatibility
            self._result_pending_value = None
        self.mibdb = fw_env.build_info.mibdb
        self.appcmd_test_ids = self.interface["APPCMD_TEST_ID"]
        
        self._test_rsp_buf_cache = {}
        self._last_total_time = 0
        self._last_time_in_sleep= 0

        self._total_scratch_space = self._parameters.size
        self._call_scratch_space_used = 0

    @property
    def mmu(self):
        return self._core.subsystem.mmu
        
    def get_appcmd_dict_from_xml(self, type_list):
        return self._lookup_types_from_elf(type_list)

    def create_reverse_lookup(self, interface_dict, name, reverse_name):
        ''' Given an interface dictionary, get the named dictionary and create
        a reverse lookup one and add that to the interface dictionary using 
        the reverse_name. 
        '''
        d = interface_dict[name]
        interface_dict[reverse_name] = create_reverse_lookup(d)
    
    def _lookup_types_from_elf(self, enum_list):
        ''' If the interface xml isn't available then we can use
        symbols from the Elf instead for most cases. These have slightly 
        different names to the xml because of the way the prim files
        are autogenerated so this method does some attempt at translating
        them back so they look alike.
        '''
        interface= dict()
        for enum_name in enum_list:
            try:
                enum_dict = dict(self._fw_env.enums[enum_name])
                for key in list(enum_dict.keys()):
                    if key.startswith(enum_name):
                        enum_dict[key.split(enum_name + "_")[1]] = enum_dict[key]
            except DwarfNoSymbol:
                enum_dict = dict()
            interface[enum_name] = enum_dict
        return interface
            
    class AppcmdInvalidParametersError(Exception):
        pass
    class AppcmdInvalidStateError(Exception):
        pass
    class AppCmdUnknownCommandError(Exception):
        pass
    class AppCmdUnimplementedError(Exception):
        pass
    class AppcmdInvalidParameterMaskError(Exception):
        pass
    class AppcmdUnspecifiedError(Exception):
        pass
    class AppCmdResponsePending(Exception):
        pass
    class AppCmdNeverResponded(Exception):
        pass
   
    # ------------------------------------------------------------------------
    # Command codes
    # ------------------------------------------------------------------------
    
    def _cmd_code(self, cmdname):
        return self.interface['APPCMD_COMMAND_ID']["APPCMD_" + cmdname]

    def _send_cmd(self, command, parameters=[], timeout=0, blocking=True,
                  pending_excep=True):
        """ Sends the given appcmd setting the toggle bit appropriately and
        waiting for the result.
        The command parameter can be the command number, the test name as
        "APPCMD_START_TEST" or the name as "START_TEST". The function returns
        the result of the command.
        """
        if not isinstance(command, int):
            if command.startswith("APPCMD_"):
                command = command.lstrip("APPCMD_")
            command = self._cmd_code(command)
                
        if len(parameters) > 0:
            PollingCmd._write_params(self, parameters)
        PollingCmd._send_cmd(self, command, timeout, blocking)
        if blocking:
            self._read_response(pending_excep=pending_excep)

    def _read_response(self, pending_excep=True):
        response = PollingCmd._read_response(self)
        if (response != self._result_success_value and 
            (pending_excep or response != self._result_pending_value)):
            raise self.response_exception_mapping[response]
        return response
    
    def _test(self, params, timeout=0, blocking=True):
        if params and isinstance(params[0], str):
            params[0] = self.appcmd_test_ids[params[0]]
        self._send_cmd("START_TEST", params, timeout=timeout, blocking=blocking)
        return self._read_result(0)
    
    def get_results(self, number_of_results):
        return self._read_results(number_of_results)
    
    def test(self, params):
        iprint("Test Result = 0x%04x" % self._test(params))    

    class RspBufEntry(object):
        
        FROM_P1_FLAG = 0x80000000
        
        def __init__(self, raw):
            self.testid = bytes_to_dwords(raw[0:4])[0]
            self.proc_id = 1 if (self.testid & self.FROM_P1_FLAG != 0) else 0
            self.testid &= ~self.FROM_P1_FLAG
            self.response = bytes_to_dwords(raw[4:8])[0]
            self.results = bytes_to_dwords(raw[8:]) 

    def start_test(self, test_name, test_params, timeout=0):
        test_id = self.interface["APPCMD_TEST_ID"][test_name]
        params = [test_id] + test_params
        self._send_cmd("START_TEST", params, timeout=timeout, 
                       pending_excep=False)
        return PollingCmd._read_response(self)

    def _get_next_rsp_buf_msg(self):
        
        try:
            self._test_rsp_buf
        except AttributeError:
            self._send_cmd("GET_RSP_BUFFER")
            self._test_rsp_buf = AppCmdBufferReader(self, self._read_result(0))
            
        if self._test_rsp_buf.num_msgs == 0:
            return None
        return self.RspBufEntry(self._test_rsp_buf.read_msg())

    def poll_rsp_buf(self, test_name, timeout=0):
        """
        Read messages first out of cache and then out of the response buffer
        until one is found from the requested test
        """
        test_id = self.interface["APPCMD_TEST_ID"][test_name]
        if test_id in self._test_rsp_buf_cache and self._test_rsp_buf_cache[test_id]: 
            next = self._test_rsp_buf_cache[test_id][0]
            self._test_rsp_buf_cache[test_id] = self._test_rsp_buf_cache[test_id][1:]
            return next

        start_time = timeout_clock()
        while 1:
            msg = self._get_next_rsp_buf_msg()
            if msg is not None:
                if msg.testid != test_id:
                    self._test_rsp_buf_cache.setdefault(msg.testid, []).append(msg)
                else:
                    return msg
            
            if timeout != 0 and timeout_clock() - start_time > timeout:
                return None
        
    def buf_msg_handle_req(self, bptr):
        """
        Returns the local MMU handle index of the supplied BUFFER_MSG
        """
        self._send_cmd("BUF_MSG_HANDLE_REQ", [bptr])
        return self._read_result(0)

    def buf_msg_free_space_req(self, bptr):
        """
        Returns two values: the number of bytes free in the buffer, and the
        number of messages free in the BUFFER_MSG.
        """
        self._send_cmd("BUF_MSG_FREE_SPACE_REQ", [bptr])
        return (self._read_result(0), self._read_result(1)) 
        
    def buf_msg_page_req(self, bptr, num_pages):
        """
        Causes the firmware to ensure the requested number of pages are paged
        in after the current index page.
        """
        self._send_cmd("BUF_MSG_PAGE_REQ", [ bptr, num_pages])
        
    def buf_msg_write_msg_ind(self, bptr, length, metadata_bytes= []):
        """
        Indicates to firmware that a message of the specified length has been
        physically written into the MMU pages.
        """
        if metadata_bytes:
            self._send_cmd("BUF_MSG_WRITE_MSG_IND", 
                               [bptr, length | (len(metadata_bytes) <<16)] 
                                        + bytes_to_dwords(metadata_bytes))
        else:
            self._send_cmd("BUF_MSG_WRITE_MSG_IND", [bptr, length])

    def buf_msg_num_msg_req(self, bptr):
        """
        Returns the number of unread messages that are currently present in the
        BUFFER_MSG
        """
        self._send_cmd("BUF_MSG_NUM_MSG_REQ", [bptr])
        return self._read_result(0)

    def buf_msg_read_msg_req(self, bptr, metadata_len=0):
        """
        Returns the length of the next message in the BUFFER_MSG. As a 
        side-effect, causes the firmware to consider the message read (hence
        functions like the firmware's buf_get_msgfrag).
        """
        self._send_cmd("BUF_MSG_READ_MSG_REQ", [bptr, metadata_len])
        if metadata_len == 0:
            return self._read_result()
        return self._read_result(), dwords_to_bytes(
                    self._read_results(2+metadata_len//4))[4:metadata_len+4]

    def buf_msg_consumed_msg_ind(self, bptr):
        """
        Indicates to firmware that the "behind" message should be cleared (hence
        functions like the firmware's buf_clear_msgfrag).
        """
        self._send_cmd("BUF_MSG_CONSUMED_MSG_IND",[bptr])

    def buf_msg_test_create_buf_req(self, 
                                    size_code = MMUSize.MMU_BUFFER_SIZE_1024):
        """
        Test-only function to create a BUFFER_MSG locally within the Appcmd
        firmware module.  Returns the memory pointer to the BUFFER_MSG.  This
        can then be used as a handle for the main Appcmd BUFFER_MSG interface.
        The only way this memory is freed is by a call to
        buf_msg_test_destroy_buf_req.
        """
        self._send_cmd("BUF_MSG_TEST_CREATE_BUF_REQ", [size_code])
        return self._read_result()
        
    def buf_msg_test_destroy_buf_req(self, bptr):
        """
        Test-only function to destroy a BUFFER_MSG pointed to by bptr.  Only for
        use on bptrs created by buf_msg_test_create_buf_req.
        """
        self._send_cmd("BUF_MSG_TEST_DESTROY_BUF_REQ", [bptr])
    
    def get_buffer_size(self):
        '''Get Buffer Size - None
        This is used to find out the appcmd buffer size in firmware.
        '''
        self._send_cmd("APPCMD_GET_BUFFER_SIZE");
        return self._read_result()
    
    def mib_set(self, mib_name, mib_value):
        '''MIB Set - The MIB name, then a container of the key values as VLINT.
        '''
        mib_id = self.mibdb[mib_name].psid()
        self.mib_set_id(mib_id, mib_value)
   
    def mib_set_id(self, mib_id, mib_value):
        '''MIB Set ID - The MIB ID and a container of the key values as VLINT.
        Sets an integer MIB key.
        '''
        params = []
        params.append(mib_id)
        #The number of word parameters sent is enough to pack all the octets.
        length = (len(mib_value) + 1)//2;

        params.append(length)
        ctr = 4
        for i in mib_value:
            if (ctr % 2 == 0):
                params.append(i)
            else:
                params[ctr//2] |= i << 8
            ctr = ctr + 1
        self._send_cmd("APPCMD_SET_MIB_KEY", params);
   
    def mib_get(self, mib_name):
        '''MIB Get - The MIB name.
        '''
        mib_id = self.mibdb[mib_name].psid()
        return self.mib_get_id(mib_id)

    def mib_get_id(self, mib_id):
        '''MIB Get ID - The MIB ID.
        Gets an integer MIB key.
        '''
        vlint = []
        self._send_cmd("APPCMD_GET_MIB_KEY",[mib_id]);
        
        len = self._read_result(1)
        for i in range(0, len):
            val = self._read_result(2 + i)
            vlint += [val & 0xff]
            vlint += [val >> 8]
 
        if((vlint[0]+1) % 2 == 1):
            vlint.pop()
        
        return vlint
    
    def mib_octet_set(self, mib_name, octet_offset, mib_value):
        '''MIB Set Octet String - The MIB name, the octet offset, then the value
        '''
        mib_id = self.mibdb[mib_name].psid()
        self.mib_octet_set_id(mib_id, octet_offset, mib_value);
 
    def mib_octet_set_id(self, mib_id, octet_offset, mib_value):
        '''MIB Set Octet String ID - The MIB ID, the offset, then the value
        Sets an octet in an octet string MIB key. This is mainly used to set
        octets one at a time starting from high indexes. When setting the last
        octet, the one with index 0, the whole string is pushed in the MIB
        database.
        '''
        self._send_cmd("APPCMD_SET_MIB_OCTET_KEY",
                      [mib_id, octet_offset, mib_value]);
 
    def mib_octet_get(self, mib_name, octet_offset):
        '''MIB Octet Get - The MIB name, then the octet offset.
        '''
        mib_id = self.mibdb[mib_name].psid()
        return self.mib_octet_get_id(mib_id, octet_offset);
 
    def mib_octet_get_id(self, mib_id, octet_offset):
        '''MIB Octet Get ID - The MIB ID, then the octet offset.
        Gets an octet from an octet string MIB key.
        '''
        self._send_cmd("APPCMD_GET_MIB_OCTET_KEY",
                      [mib_id, octet_offset]);
        return self._read_result(2)

    def mib_octet_get_length(self, mib_name):
        '''MIB Octet Get Length - The MIB name
        '''
        mib_id = self.mibdb[mib_name].psid()
        return self.mib_octet_get_length_id(mib_id)

    def mib_octet_get_length_id(self, mib_id):
        '''MIB Octet Get Length ID - The MIB ID.
        Gets the length of an octet string MIB key.
        '''
        self._send_cmd("APPCMD_GET_MIB_OCTET_LENGTH",
                      [mib_id]);
        return self._read_result(1)

    def mib_octet_set_v(self, mib_name, mib_values=[], offset=0):
        '''
        Set the named mib key (of octet type) to the values given in the
        mib_values parameter. This parameter is a list of integers in
        conventional order starting form index offset (defaulting to zero).
        The values are written to the chip in reverse order with the write
        to index zero triggering the firmware to set the array.
        '''
        #Potential extension:: I could probably add sanity error checking here
        mib_id = self.mibdb[mib_name].psid()

        for (i, v) in reversed([ j for j in enumerate(mib_values, start=offset)]):
            self.mib_octet_set_id(mib_id, i, v)
        # If there is an offset then write element zero to zero (the default) to
        # trigger the firmware to do the mib set of the array we have just written
        if offset:
            self.mib_octet_set_id(mib_id, 0, 0)

    def mib_octet_get_v(self, mib_name):
        '''
        Get the value of the named MIB key of octet type.
        '''
        mib_id = self.mibdb[mib_name].psid()
        len = self.mib_octet_get_length_id(mib_id)

        return [self.mib_octet_get_id(mib_id, i) for i in range(len)]

    def call_total_arg_size(self, total_arg_size):
        """
        Called by Call.__call__ before any argument scratch allocations are
        attempted to ensure that the scratch space needed for arguments is
        not taken for referent space.
        """
        self._call_scratch_space_start = self._parameters.address + total_arg_size

    def call_request_scratch_space(self, size):
        """
        Request scratch space for a pointer to be passed in.  This follows
        the simplest possible allocation model: the next <size> bytes are
        taken
        """
        scratch_space_remaining = (self._parameters.address + self._parameters.size - 
                                        self._call_scratch_space_start)
        if scratch_space_remaining < size:
            return None
        allocated = self._call_scratch_space_start
        self._call_scratch_space_start += size
        return allocated

    def call_function(self, func_name, args = None, timeout=0, blocking=True):
        """
        Issue APPCMD_CALL_FUNCTION for the given function and arguments, 
        checking that the number of args is correct and that none of the 
        function's parameters are more than 32 bits wide, as the underlying
        assembly code doesn't know how to set function calls like that up.
        """
        if args is None:
            args_ = []
        else:
            args_ = args

        func_raw_addr = self._fw_env.functions[func_name]
        _, _, func_sym = self._fw_env.functions.get_function_of_pc(func_raw_addr)
        # Getting the address this way ensure that the appropriate high and low
        # bit mungery is performed 
        func_addr = self._fw_env.functions.get_call_address(func_name)
        params = [p for p in func_sym.params]
        if len(params) > 8: # = APPCMD_MISC_VALUES_CMD_BUF_LEN - 2
            raise TypeError("Can't call '%s': takes %d args, but appcmd can "
                            "only support 8" % (func_name, len(params)))
        if len(params) != len(args_):
            raise TypeError("Can't call '%s': %d args supplied but takes %d" %
                            (func_name, len(args_), len(params)))
        for name, param in params:
            if param.byte_size > 4:
                raise TypeError("Can't call '%s': parameter %s too wide (%d "
                                "bytes)" % (func_name, name, 
                                            param.struct_dict["byte_size"]))
        ret_type = func_sym.return_type
        if ret_type is not None and ret_type.struct_dict["byte_size"] > 4:
            raise TypeError("Can't call '%s': return type is too big for normal "
                            "register return")

        # All good; let's go
        return self.call_raw_function(func_addr, args, ret_type, timeout,
                                      blocking=blocking)

    def call_raw_function(self, func_addr, args=None, ret_type=None, timeout=0,
                          blocking=True):
        self._send_cmd("CALL_FUNCTION", [func_addr, len(args)] + args,
                       timeout=timeout, blocking=blocking)
        # Get the return value or don't...
        if ret_type is None:
            return None
        return self.get_results(1)[0]

    def mmu_handles(self):
        """
        Returns the MMU handles used by the AppCmd firmware
        """
        results = []
        buf_name = "appcmd_rsp_buf"
        try:
            handles = [self._fw_env.gv[buf_name].deref["buf"]["handle"].value & 0xff]  
            ss_handles = [buf_name, handles]
            results.append(ss_handles)
        except KeyError:
            # Apps p1 doesn't have the buffer so will trigger this exception
            pass
        return results
    def get_cpu_usage(self, timeout = 0):
        self._send_cmd("GET_CPU_USAGE", timeout = timeout)
        total_time, time_in_sleep = self.get_results(2)
        delta = total_time - self._last_total_time
        delta_sleep = time_in_sleep - self._last_time_in_sleep
        self._last_total_time = total_time
        self._last_time_in_sleep= time_in_sleep
        return (100.0 * (total_time - time_in_sleep) / total_time,
                100.0 * (delta - delta_sleep) / delta)

class AppCmdBuffer(object):
    def __init__(self, appcmd, buffer_ptr):
        
        self._appcmd = appcmd
        self._bptr = buffer_ptr
        self._page_size = appcmd.mmu.page_size
        
        # Do a handle_req to get the required handle
        self._hdl = self._appcmd.buf_msg_handle_req(self._bptr)
        handleRecord = appcmd.mmu.handleTable[self._hdl]
        handleRecord.refresh()
        # Create an MMUPagedBuffer set up for "hardware" to write at the 
        # hardware offset.
        self._buffer = MMUPagedBuffer(appcmd.mmu, handleRecord.pageTable)
        
        # Offsets into the BUFFER_MSG structure 
        # Potential extension:: get these in a better way that might involve some extension
        # to the DWARF interface
        self._buf_struct_offset = { "index":2, "outdex":4, "tail":6, "size_mask":8}
        
    @property
    def index(self):
        addr = self._bptr + self._buf_struct_offset["index"]
        bytes = self._appcmd._core.data[addr: addr+2]
        return bytes[0] | bytes[1] << 8

    @property
    def outdex(self):
        addr = self._bptr + self._buf_struct_offset["outdex"]
        bytes = self._appcmd._core.data[addr: addr+2]
        return bytes[0] | bytes[1] << 8
    
class AppCmdBufferWriter(AppCmdBuffer):
    '''
    Interface to write to a buffer as if we were a hardware data source
    '''

    class OverflowError(RuntimeError):
        pass
    
    @property
    def free_space(self):
        '''
        How many bytes and messages can we write to the buffer?
        '''
        return self._appcmd.buf_msg_free_space_req(self._bptr)
        
    
    def write_msg(self, msg, metadata_bytes = []):
        '''
        Write the specified message bytes to the buffer,
        requesting the appropriate number of pages to be mapped first.  Then
        tell AppCmd that a new message has appeared
        '''
        
        # First, check there's enough space in the buffer
        bytes, msgs = self.free_space 
        if msgs == 0 or len(msg) > bytes:
            raise self.OverflowError
        
        # Get the current handle offset to figure out how much space is left in
        # the current page
        cur_page_remaining = ((self._page_size - (self.index % self._page_size)) 
                                                            % self._page_size)
        
        num_pages = (len(msg) - cur_page_remaining + 
                                        self._page_size - 1) / self._page_size
                          
        self._appcmd.buf_msg_page_req(self._bptr, num_pages)
        offset = self.index
        self._buffer[offset: offset + len(msg)] = msg
        self._appcmd.buf_msg_write_msg_ind(self._bptr, len(msg), metadata_bytes)
        
        
class AppCmdBufferReader(AppCmdBuffer):
    '''
    Interface to read from a buffer as if we were a hardware data sink
    '''

    class UnderflowError(RuntimeError):
        pass
    
    @property
    def num_msgs(self):
        '''
        Ask Appcmd how many messages are available
        '''
        return self._appcmd.buf_msg_num_msg_req(self._bptr)
        
    def read_msg(self, metadata_len=0):
        '''
        Read the specified number of bytes from the buffer and
        then tell AppCmd the message has been consumed
        '''
        if self.num_msgs == 0:
            raise self.UnderflowError
        
        offset = self.outdex
        if metadata_len:
            length, metadata = self._appcmd.buf_msg_read_msg_req(
                                                     self._bptr, metadata_len)
        else:
            length = self._appcmd.buf_msg_read_msg_req(self._bptr)
        data = self._buffer[offset: offset + length]
        self._appcmd.buf_msg_consumed_msg_ind(self._bptr)
        
        if metadata_len:
            return data, metadata
        else:
            return data
    

class AppCmdTestTunnel(object):
    """
    This class takes is a layer on top of appcmd's test commands.
    It takes care of tunnelling test commands and data through appcmd.
    It uses the generated appcmd enums to figure out to which test interface to
    send the packet. The interface works mainly with byte lists and then fills
    in the params firmware buffer and similarly it reads and unpacks the 
    results buffer. Packet boundaries are given by the size of the byte list in
    question. Headers are not propagated to or requested from the callers.
    Fields in appcmd test packets will differ form module to module. This is 
    handled by the callers. 
    """
    
    def __init__(self, appcmd, com_enum, test_name, log=None):
        """
        @brief Stores external interfaces locally and retrieves some 
        parameters.
        
        @par appcmd 
        Reference to the appcmd object used for interfacing to the DUT.
        
        @par com_enum
        The name of the enum holding the command IDs.
        
        @par test_name
        The test name of which to grab the ID.
        
        @par log
        Reference to the log object used to log errors in greater detail. 
        Basically a data sink for logging.
        """
        self.appcmd = appcmd
        if log:
            self.log = log
        else:
            self.log = self._null
        self.commands = appcmd.get_appcmd_dict_from_xml(
                                                      [com_enum])[com_enum]
        self.testid =  appcmd.get_appcmd_dict_from_xml(
                           ["APPCMD_TEST_ID"])["APPCMD_TEST_ID"][test_name]
    
    def _null(self, data):
        """
        @brief Null data sink for log.
        
        @par data
        Data to be thrown away.
        """
        pass
    
    def _pack(self, command, data = []):
        """
        @brief Returns a packed appcmd packet.
        
        @par command 
        Appcmd test command under which the data will be sent.
        
        @par data 
        Data to be sent as an 8 bit integer list.
        
        Packs an appcmd packet in a list of 32 bit integers. It also adds a
        header which encodes information about where appcmd should pass 
        this packet to.
        """
        return ([self.testid, (len(data) << 16) + command] + 
                                                         bytes_to_dwords(data))
    
    def _unpack(self, payload):
        """
        @brief Returns an unpacked appcmd packet.
        
        @par payload
        Payload to unpack. This is a 32 bit integer list.
        
        Unpacks an appcmd packet into a list of 8 bit integers. It also 
        strips the header.
        """
        unpacked = dwords_to_bytes(payload)
        length = (unpacked[1] << 8) + unpacked[0] # Decodes the length
        unpacked = unpacked[4:] # Strips header
        return unpacked[:length] # Returns just the data
    
    @property
    def rx_max_size(self):
        """
        @brief Returns the maximum data size that fits into an appcmd RX 
        packet.
        """
        try:
            self._rx_max_size
        except AttributeError:
            self._rx_max_size = self.appcmd.get_buffer_size() - 4#hide header
        return self._rx_max_size
    
    @property
    def tx_max_size(self):
        """
        @brief Returns the maximum data size that fits into an appcmd TX 
        packet.
        """
        try:
            self._tx_max_size
        except AttributeError:
            self._tx_max_size = self.appcmd.get_buffer_size() - 8#hide header
        return self._tx_max_size
    
    def get(self):
        """
        @brief Decodes and returns the RX data.
        """
        return self._unpack(self.appcmd.get_results(self.rx_max_size//4))
    
    def send(self, strcommand, params=[], timeout=0):
        """
        @brief Encodes a command with parameters, sends the packet and 
        returns true/false as a pass/fail status. 
        
        @par strcommand
        Command represented as a string. This is decoded here.
        
        @par params
        These are optional parameters as a list of 8 bit integers. These 
        are parameters used by appcmd and often, actual data.
        
        Encodes a command with parameters and sends the packet to appcmd.
        Parameters are expressed as a list of 8 bit integers.
        """
        if len(params) > self.tx_max_size:
            self.log("Appcmd test tunnel: payload too long")
            return False
        payloadout = self._pack(self.commands[strcommand], params)
        try:
            self.appcmd._test(payloadout, timeout)
        except self.appcmd.TimeoutError:
            self.log("Appcmd test tunnel: timeout")
            return False
        except self.appcmd.AppcmdInvalidParametersError:
            self.log("Appcmd test tunnel: parameters error")
            return False
        except self.appcmd.AppcmdInvalidStateError:
            self.log("Appcmd test tunnel: invalid state")
            return False
        except self.appcmd.AppCmdUnknownCommandError:
            self.log("Appcmd test tunnel: unknown command")
            return False
        except self.appcmd.AppCmdUnimplementedError:
            self.log("Appcmd test tunnel: unimplemented")
            return False
        except self.appcmd.AppcmdInvalidParameterMaskError:
            self.log("Appcmd test tunnel: parameter mask error")
            return False
        except self.appcmd.AppcmdUnspecifiedError:
            self.log("Appcmd test tunnel: unspecified error")
            return False
        return True
