# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
# Automatically-generated memory-mapped registers IO file
#------------------------------------------------------------------------------

class c_enum(object):
   def __init__(self, parent, value, text, reg):
      self.parent = parent
      self.value  = value
      self.text   = text
      self.reg    = reg

class c_value(object):
   def __init__(self, parent, name, value, text):
      self.parent = parent
      self.name   = name
      self.value  = value
      self.text   = text

class c_bits(object):
   def __init__(self, parent, lsb, msb, mask, width, rw_flags, text):
      self.parent   = parent
      self.lsb      = lsb
      self.msb      = msb
      self.mask     = mask
      self.rw_flags = rw_flags
      self.width    = width
      self.text     = text

class c_reg(object):
   def __init__(self, addr, r, w, m, rw_flags, width, reset, local, ext_read, mod_name, group, text, locked_by, unlock_value, typedefd_io, safe_to_load, is_bank_ctrl, bank_ctrl_reg, constant):
      self.addr          = addr
      self.r             = r            # Readable
      self.w             = w            # Writeable
      self.m             = m            # Mixed register type
      self.rw_flags      = rw_flags     # RW flags
      self.width         = width
      self.local         = local
      self.ext_read      = ext_read
      self.mod_name      = mod_name
      self.text          = text
      self.group         = group
      self.reset         = reset
      self.locked_by     = locked_by
      self.unlock_value  = unlock_value
      self.safe_to_load  = safe_to_load
      self.typedefd_io   = typedefd_io
      self.is_bank_ctrl  = is_bank_ctrl
      self.bank_ctrl_reg = bank_ctrl_reg
      self.constant      = constant


class c_regarray(object):
   def __init__(self, addr, num_elements, element):
      self.addr = addr
      self.num_elements  = num_elements
      self.element = element



APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL                                            = c_reg(0xffff99cc, 1, 1, 0, "RW", 4, 15, 0, 0, "apps_banked_exceptions_p1", "", "Access control", "", "", 0, 1, "", "", 0)
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_PERMISSION = c_bits(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, 0, 0, 0x1, 1, "RW", "Access permission for P0")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_BLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_BLOCKED", 0, "P0 does not have read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_UNBLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_UNBLOCKED", 1, "P0 has read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_PERMISSION = c_bits(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, 1, 1, 0x2, 1, "RW", "Access permission for P1")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_BLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_BLOCKED", 0, "P1 does not have read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_UNBLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_UNBLOCKED", 1, "P1 has read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_PERMISSION = c_bits(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, 2, 2, 0x4, 1, "RW", "Access permission for P2")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_BLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_BLOCKED", 0, "P2 does not have read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_UNBLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_UNBLOCKED", 1, "P2 has read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_PERMISSION = c_bits(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, 3, 3, 0x8, 1, "RW", "Access permission for P3")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_BLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_BLOCKED", 0, "P3 does not have read/write access")
APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL.APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_PERMISSION.APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_UNBLOCKED = c_value(APPS_BANKED_EXCEPTIONS_P1_ACCESS_CTRL, "APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_UNBLOCKED", 1, "P3 has read/write access")
APPS_BANKED_EXCEPTIONS_P1_ENABLES                                                = c_reg(0xffff99c4, 1, 1, 0, "RW", 20, 262269, 0, 0, "apps_banked_exceptions_p1", "", "Enable masks (set to 1 to enable exceptions).", "", "", 0, 1, "", "", 0)
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_REGISTERS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 0, "Registers bus access exception. This will only trigger for the CPU doing the access.", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_CPU0 = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 1, "VM lookup for CPU0 exception", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_CPU1 = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 2, "VM lookup for CPU1 exception", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_TBUS_REMOTE = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 3, "VM lookup for remote TBus guy exception", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_DMAC = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 4, "VM lookup for DMAC", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VM_CPU1_REMOTE_REQ = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 5, "VM access to remote source by CPU1 unallowed exception", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU1_ACCESS_FAULT = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 6, "CPU1 access to prohibited memory region", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_RAM0_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 9, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_RAM1_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 10, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_TAG_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 11, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_RAM0_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 12, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_RAM1_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 13, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_TAG_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 14, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SQIF0_TBUS_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 15, "Non-OK status returned for SQIF0 Tbus fetch", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SQIF1_TBUS_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 16, "Non-OK status returned for SQIF1 Tbus fetch", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU0_VM_BUFFER_MAP = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 17, "Error while performing a VM request due to buffer mapping (no free pages, etc.)", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU1_VM_BUFFER_MAP = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 18, "Error while performing a VM request due to buffer mapping (no free pages, etc.)", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_REMOTE_REGISTERS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 19, "Remote registers bus access exception. This will only trigger for the CPU doing the access.", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_MAX = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 20, "Number of last exception plus one.", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_WIDTH_SPOILER = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 2147483647, "Number of last exception plus one.", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_ENABLES.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SDIO_HOST_DM0_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_ENABLES, 8, "SDIO host DMA access to DM0 while prohibited", "APPS_BANKED_EXCEPTIONS_P1_ENABLES")
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK                                             = c_reg(0xffff99c8, 1, 1, 0, "RW", 4, 15, 0, 0, "apps_banked_exceptions_p1", "", "Mutex lock", "", "", 0, 1, "", "", 0)
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK.APPS_BANKED_EXCEPTIONS_P1__MUTEX_AVAILABLE  = c_enum(APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK, 0, "4'b0000 means mutex available, claim it to access the resouce", "APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK")
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK.APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P0 = c_enum(APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK")
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK.APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P1 = c_enum(APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK")
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK.APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P2 = c_enum(APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK")
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK.APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P3 = c_enum(APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK")
APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK.APPS_BANKED_EXCEPTIONS_P1__MUTEX_DISABLED   = c_enum(APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "APPS_BANKED_EXCEPTIONS_P1_MUTEX_LOCK")
APPS_BANKED_EXCEPTIONS_P1_STATUS                                                 = c_reg(0xffff99c0, 1, 1, 0, "RW", 20, 0, 1, 1, "apps_banked_exceptions_p1", "", "Exceptions status register. Write bits with '1' to clear them (multiple may be cleared simultaneously).", "", "", 0, 1, "", "", 0)
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_REGISTERS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 0, "Registers bus access exception. This will only trigger for the CPU doing the access.", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_CPU0 = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 1, "VM lookup for CPU0 exception", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_CPU1 = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 2, "VM lookup for CPU1 exception", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_TBUS_REMOTE = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 3, "VM lookup for remote TBus guy exception", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_DMAC = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 4, "VM lookup for DMAC", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VM_CPU1_REMOTE_REQ = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 5, "VM access to remote source by CPU1 unallowed exception", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU1_ACCESS_FAULT = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 6, "CPU1 access to prohibited memory region", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_RAM0_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 9, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_RAM1_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 10, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_TAG_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 11, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_RAM0_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 12, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_RAM1_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 13, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_TAG_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 14, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SQIF0_TBUS_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 15, "Non-OK status returned for SQIF0 Tbus fetch", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SQIF1_TBUS_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 16, "Non-OK status returned for SQIF1 Tbus fetch", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU0_VM_BUFFER_MAP = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 17, "Error while performing a VM request due to buffer mapping (no free pages, etc.)", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU1_VM_BUFFER_MAP = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 18, "Error while performing a VM request due to buffer mapping (no free pages, etc.)", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_REMOTE_REGISTERS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 19, "Remote registers bus access exception. This will only trigger for the CPU doing the access.", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_MAX = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 20, "Number of last exception plus one.", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_WIDTH_SPOILER = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 2147483647, "Number of last exception plus one.", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1_STATUS.APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SDIO_HOST_DM0_ACCESS = c_enum(APPS_BANKED_EXCEPTIONS_P1_STATUS, 8, "SDIO host DMA access to DM0 while prohibited", "APPS_BANKED_EXCEPTIONS_P1_STATUS")
APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_PERMISSION                                  = c_enum(None, 0, "Access permission for P0", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_BLOCKED                                     = c_enum(None, 0, "P0 does not have read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P0_ACCESS_UNBLOCKED                                   = c_enum(None, 1, "P0 has read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_PERMISSION                                  = c_enum(None, 1, "Access permission for P1", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_BLOCKED                                     = c_enum(None, 0, "P1 does not have read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P1_ACCESS_UNBLOCKED                                   = c_enum(None, 1, "P1 has read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_PERMISSION                                  = c_enum(None, 2, "Access permission for P2", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_BLOCKED                                     = c_enum(None, 0, "P2 does not have read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P2_ACCESS_UNBLOCKED                                   = c_enum(None, 1, "P2 has read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_PERMISSION                                  = c_enum(None, 3, "Access permission for P3", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_BLOCKED                                     = c_enum(None, 0, "P3 does not have read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__P3_ACCESS_UNBLOCKED                                   = c_enum(None, 1, "P3 has read/write access", "APPS_BANKED_EXCEPTIONS_P1__ACCESS_CTRL_ENUM")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_REGISTERS                            = c_enum(None, 0, "Registers bus access exception. This will only trigger for the CPU doing the access.", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_CPU0                             = c_enum(None, 1, "VM lookup for CPU0 exception", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_CPU1                             = c_enum(None, 2, "VM lookup for CPU1 exception", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_TBUS_REMOTE                      = c_enum(None, 3, "VM lookup for remote TBus guy exception", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VML_DMAC                             = c_enum(None, 4, "VM lookup for DMAC", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_VM_CPU1_REMOTE_REQ                   = c_enum(None, 5, "VM access to remote source by CPU1 unallowed exception", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU1_ACCESS_FAULT                    = c_enum(None, 6, "CPU1 access to prohibited memory region", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_RAM0_ACCESS                   = c_enum(None, 9, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_RAM1_ACCESS                   = c_enum(None, 10, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE0_TAG_ACCESS                    = c_enum(None, 11, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_RAM0_ACCESS                   = c_enum(None, 12, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_RAM1_ACCESS                   = c_enum(None, 13, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CACHE1_TAG_ACCESS                    = c_enum(None, 14, "Access to a cache RAM while it is enabled", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SQIF0_TBUS_ACCESS                    = c_enum(None, 15, "Non-OK status returned for SQIF0 Tbus fetch", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SQIF1_TBUS_ACCESS                    = c_enum(None, 16, "Non-OK status returned for SQIF1 Tbus fetch", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU0_VM_BUFFER_MAP                   = c_enum(None, 17, "Error while performing a VM request due to buffer mapping (no free pages, etc.)", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_CPU1_VM_BUFFER_MAP                   = c_enum(None, 18, "Error while performing a VM request due to buffer mapping (no free pages, etc.)", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_REMOTE_REGISTERS                     = c_enum(None, 19, "Remote registers bus access exception. This will only trigger for the CPU doing the access.", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_MAX                                  = c_enum(None, 20, "Number of last exception plus one.", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_WIDTH_SPOILER                        = c_enum(None, 2147483647, "Number of last exception plus one.", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE_SDIO_HOST_DM0_ACCESS                 = c_enum(None, 8, "SDIO host DMA access to DM0 while prohibited", "APPS_BANKED_EXCEPTIONS_P1__EXCEPTION_SOURCE")
APPS_BANKED_EXCEPTIONS_P1__MUTEX_AVAILABLE                                       = c_enum(None, 0, "4'b0000 means mutex available, claim it to access the resouce", "APPS_BANKED_EXCEPTIONS_P1__MUTEX_LOCK_ENUM")
APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P0                                   = c_enum(None, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "APPS_BANKED_EXCEPTIONS_P1__MUTEX_LOCK_ENUM")
APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P1                                   = c_enum(None, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "APPS_BANKED_EXCEPTIONS_P1__MUTEX_LOCK_ENUM")
APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P2                                   = c_enum(None, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "APPS_BANKED_EXCEPTIONS_P1__MUTEX_LOCK_ENUM")
APPS_BANKED_EXCEPTIONS_P1__MUTEX_CLAIMED_BY_P3                                   = c_enum(None, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "APPS_BANKED_EXCEPTIONS_P1__MUTEX_LOCK_ENUM")
APPS_BANKED_EXCEPTIONS_P1__MUTEX_DISABLED                                        = c_enum(None, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "APPS_BANKED_EXCEPTIONS_P1__MUTEX_LOCK_ENUM")

VM_CPU1_REQUESTS_WRITE                                                           = c_enum(None, 0, "", "VM_CPU1_REQUESTS_ENUM")
VM_CPU1_REQUESTS_READ                                                            = c_enum(None, 1, "", "VM_CPU1_REQUESTS_ENUM")

# -- Memory maps for the CPUs in the APPS SYS --

P0D_SQIF0_CACHED_LOWER                                                           = c_enum(None, 1879048192, "Lowest address for block    'SQIF0 CACHED'.", "APPS_SYS_CPU0_DM")
P0D_SQIF0_CACHED_UPPER                                                           = c_enum(None, 1887436800, "Highest address for block   'SQIF0 CACHED'.", "APPS_SYS_CPU0_DM")
P0D_SQIF1_CACHED_LOWER                                                           = c_enum(None, 2013265920, "Lowest address for block    'SQIF1 CACHED'.", "APPS_SYS_CPU0_DM")
P0D_SQIF1_CACHED_UPPER                                                           = c_enum(None, 2021654528, "Highest address for block   'SQIF1 CACHED'.", "APPS_SYS_CPU0_DM")
P0D_SQIF_RAM_LOWER                                                               = c_enum(None, 2147483648, "Lowest address for block    'SQIF RAM WINDOW'.", "APPS_SYS_CPU0_DM")
P0D_SQIF_RAM_UPPER                                                               = c_enum(None, 2155872256, "Highest address for block   'SQIF RAM WINDOW'.", "APPS_SYS_CPU0_DM")
P0D_SQIF0_DIRECT_LOWER                                                           = c_enum(None, 2952790016, "Lowest address for block    'SQIF0 DIRECT ACCESS'.", "APPS_SYS_CPU0_DM")
P0D_SQIF0_DIRECT_UPPER                                                           = c_enum(None, 3489660928, "Highest address for block   'SQIF0 DIRECT ACCESS'.", "APPS_SYS_CPU0_DM")
P0D_SQIF01_DIRECT_LOWER                                                          = c_enum(None, 3489660928, "Lowest address for block    'SQIF0/1 DIRECT ACCESS'.", "APPS_SYS_CPU0_DM")
P0D_SQIF01_DIRECT_UPPER                                                          = c_enum(None, 4026531840, "Highest address for block   'SQIF0/1 DIRECT ACCESS'.", "APPS_SYS_CPU0_DM")
P0D_P1_DM_RAM_LOWER                                                              = c_enum(None, 131072, "Lowest address for block    'P1 DATA RAM'.", "APPS_SYS_CPU0_DM")
P0D_P1_DM_RAM_UPPER                                                              = c_enum(None, 212992, "Highest address for block   'P1 DATA RAM'.", "APPS_SYS_CPU0_DM")
P0D_P0_DM_RAM_LOWER                                                              = c_enum(None, 0, "Lowest address for block    'P0 DATA RAM'.", "APPS_SYS_CPU0_DM")
P0D_P0_DM_RAM_UPPER                                                              = c_enum(None, 49152, "Highest address for block   'P0 DATA RAM'.", "APPS_SYS_CPU0_DM")
P0P_SQIF0_CACHED_LOWER                                                           = c_enum(None, 0, "Lowest address for block    'SQIF0 CACHED'.", "APPS_SYS_CPU0_PM")
P0P_SQIF0_CACHED_UPPER                                                           = c_enum(None, 8388608, "Highest address for block   'SQIF0 CACHED'.", "APPS_SYS_CPU0_PM")
P1D_SQIF0_CACHED_LOWER                                                           = c_enum(None, 1879048192, "Lowest address for block    'SQIF0 CACHED'.", "APPS_SYS_CPU1_DM")
P1D_SQIF0_CACHED_UPPER                                                           = c_enum(None, 1887436800, "Highest address for block   'SQIF0 CACHED'.", "APPS_SYS_CPU1_DM")
P1D_SQIF1_CACHED_LOWER                                                           = c_enum(None, 2013265920, "Lowest address for block    'SQIF1 CACHED'.", "APPS_SYS_CPU1_DM")
P1D_SQIF1_CACHED_UPPER                                                           = c_enum(None, 2021654528, "Highest address for block   'SQIF1 CACHED'.", "APPS_SYS_CPU1_DM")
P1D_SQIF_RAM_LOWER                                                               = c_enum(None, 2281701376, "Lowest address for block    'SQIF RAM WINDOW'.", "APPS_SYS_CPU1_DM")
P1D_SQIF_RAM_UPPER                                                               = c_enum(None, 2290089984, "Highest address for block   'SQIF RAM WINDOW'.", "APPS_SYS_CPU1_DM")
P1D_SQIF01_DIRECT_LOWER                                                          = c_enum(None, 3489660928, "Lowest address for block    'SQIF0/1 DIRECT ACCESS'.", "APPS_SYS_CPU1_DM")
P1D_SQIF01_DIRECT_UPPER                                                          = c_enum(None, 4026531840, "Highest address for block   'SQIF0/1 DIRECT ACCESS'.", "APPS_SYS_CPU1_DM")
P1D_P0_DM_RAM_LOWER                                                              = c_enum(None, 0, "Lowest address for block    'P0 DATA RAM'.", "APPS_SYS_CPU1_DM")
P1D_P0_DM_RAM_UPPER                                                              = c_enum(None, 49152, "Highest address for block   'P0 DATA RAM'.", "APPS_SYS_CPU1_DM")
P1D_P1_DM_RAM_LOWER                                                              = c_enum(None, 131072, "Lowest address for block    'P1 DATA RAM'.", "APPS_SYS_CPU1_DM")
P1D_P1_DM_RAM_UPPER                                                              = c_enum(None, 212992, "Highest address for block   'P1 DATA RAM'.", "APPS_SYS_CPU1_DM")
P1P_SQIF1_CACHED_LOWER                                                           = c_enum(None, 0, "Lowest address for block    'SQIF0 CACHED'.", "APPS_SYS_CPU1_PM")
P1P_SQIF1_CACHED_UPPER                                                           = c_enum(None, 8388608, "Highest address for block   'SQIF0 CACHED'.", "APPS_SYS_CPU1_PM")
PxD_CROSS_CPU_REGS_LOWER                                                         = c_enum(None, 1342177280, "Lowest address for remapped register area of the other CPU.", "APPS_SYS_CPUx_DM")
PxD_CROSS_CPU_REGS_UPPER                                                         = c_enum(None, 1476395008, "Highest address for remapped register area of the other CPU.", "APPS_SYS_CPUx_DM")
PxD_CROSS_CPU_REGS_ADDR_MASK                                                     = c_enum(None, 134217727, "Mask to logically AND the P1 register address with (which you then logically OR with PxD_CROSS_CPU_REGS_LOWER) to create the cross-CPU access address.", "APPS_SYS_CPUx_DM")
PxD_REMOTE_REGISTER_SPACE_LOWER                                                  = c_enum(None, 1610612736, "Lowest address for block    'REMOTE REGISTER SPACE'.", "APPS_SYS_CPUx_DM")
PxD_REMOTE_REGISTER_SPACE_UPPER                                                  = c_enum(None, 1610940416, "Highest address for block   'REMOTE REGISTER SPACE.", "APPS_SYS_CPUx_DM")
PxD_SQIF0_RAM_LOWER                                                              = c_enum(None, 2147483648, "Lowest address for block    'SQIF0 RAM'.", "APPS_SYS_CPUx_DM")
PxD_SQIF0_RAM_UPPER                                                              = c_enum(None, 2155872256, "Highest address for block   'SQIF0 RAM'.", "APPS_SYS_CPUx_DM")
PxD_SQIF1_RAM_LOWER                                                              = c_enum(None, 2281701376, "Lowest address for block    'SQIF1 RAM'.", "APPS_SYS_CPUx_DM")
PxD_SQIF1_RAM_UPPER                                                              = c_enum(None, 2290089984, "Highest address for block   'SQIF1 RAM'.", "APPS_SYS_CPUx_DM")
PxD_REMOTE_SS_ACCESS0_LOWER                                                      = c_enum(None, 2415919104, "Lowest address for block    'REMOTE SUBSYSTEM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_REMOTE_SS_ACCESS0_UPPER                                                      = c_enum(None, 2550136832, "Highest address for block   'REMOTE SUBSYSTEM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_REMOTE_SS_ACCESS1_LOWER                                                      = c_enum(None, 2550136832, "Lowest address for block    'REMOTE SUBSYSTEM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_REMOTE_SS_ACCESS1_UPPER                                                      = c_enum(None, 2684354560, "Highest address for block   'REMOTE SUBSYSTEM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_VM_BUFFER_LOWER                                                              = c_enum(None, 2684354560, "Lowest address for block    'VM BUFFER SPACE'.", "APPS_SYS_CPUx_DM")
PxD_VM_BUFFER_UPPER                                                              = c_enum(None, 2952790016, "Highest address for block   'VM BUFFER SPACE'.", "APPS_SYS_CPUx_DM")
PxD_P0_DM_RAM_LOWER                                                              = c_enum(None, 0, "Lowest address for block    'P0 DATA RAM'.", "APPS_SYS_CPUx_DM")
PxD_P0_DM_RAM_UPPER                                                              = c_enum(None, 49152, "Highest address for block   'P0 DATA RAM'.", "APPS_SYS_CPUx_DM")
PxD_P1_DM_RAM_LOWER                                                              = c_enum(None, 131072, "Lowest address for block    'P1 DATA RAM'.", "APPS_SYS_CPUx_DM")
PxD_P1_DM_RAM_UPPER                                                              = c_enum(None, 212992, "Highest address for block   'P1 DATA RAM'.", "APPS_SYS_CPUx_DM")
PxD_SHARED_DM_RAM_LOWER                                                          = c_enum(None, 268435456, "Lowest address for block    'SHARED DATA RAM'.", "APPS_SYS_CPUx_DM")
PxD_SHARED_DM_RAM_UPPER                                                          = c_enum(None, 268500992, "Highest address for block   'SHARED DATA RAM'.", "APPS_SYS_CPUx_DM")
PxD_TCM0_LOWER                                                                   = c_enum(None, 536870912, "Lowest address for block    'TCM0'.", "APPS_SYS_CPUx_DM")
PxD_TCM0_UPPER                                                                   = c_enum(None, 536903680, "Highest address for block   'TCM0'.", "APPS_SYS_CPUx_DM")
PxD_TCM1_LOWER                                                                   = c_enum(None, 536903680, "Lowest address for block    'TCM1'.", "APPS_SYS_CPUx_DM")
PxD_TCM1_UPPER                                                                   = c_enum(None, 536936448, "Highest address for block   'TCM1'.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_DATA_RAM_LOWER                                                      = c_enum(None, 805306368, "Lowest address for P0 cache data RAM.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_DATA_RAM_UPPER                                                      = c_enum(None, 805339136, "Highest address for P0 cache Data RAM.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_DATA_RAM0_LOWER                                                     = c_enum(None, 805306368, "Lowest address for P0 cache data RAM 0.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_DATA_RAM0_UPPER                                                     = c_enum(None, 805322752, "Highest address for P0 cache Data RAM 0.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_DATA_RAM1_LOWER                                                     = c_enum(None, 805322752, "Lowest address for P0 cache data RAM 1.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_DATA_RAM1_UPPER                                                     = c_enum(None, 805339136, "Highest address for P0 cache Data RAM 1.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_TAG_RAM_LOWER                                                       = c_enum(None, 805339136, "Lowest address for P0 cache tag RAM.", "APPS_SYS_CPUx_DM")
PxD_P0_CACHE_TAG_RAM_UPPER                                                       = c_enum(None, 805341184, "Highest address for P0 cache tag RAM.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_DATA_RAM_LOWER                                                      = c_enum(None, 805502976, "Lowest address for block    'P1 Cache Data RAM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_DATA_RAM_UPPER                                                      = c_enum(None, 805535744, "Highest address for block   'P1 Cache Data RAM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_DATA_RAM0_LOWER                                                     = c_enum(None, 805502976, "Lowest address for P1 cache data RAM 0.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_DATA_RAM0_UPPER                                                     = c_enum(None, 805519360, "Highest address for P1 cache Data RAM 0.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_DATA_RAM1_LOWER                                                     = c_enum(None, 805519360, "Lowest address for P1 cache data RAM 1.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_DATA_RAM1_UPPER                                                     = c_enum(None, 805535744, "Highest address for P1 cache Data RAM 1.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_TAG_RAM_LOWER                                                       = c_enum(None, 805535744, "Lowest address for block    'P1 Cache Tag RAM ACCESS'.", "APPS_SYS_CPUx_DM")
PxD_P1_CACHE_TAG_RAM_UPPER                                                       = c_enum(None, 805537792, "Highest address for block   'P1 Cache Tag RAM ACCESS'.", "APPS_SYS_CPUx_DM")
PxP_SQIFx_CACHED_LOWER                                                           = c_enum(None, 0, "Lowest address for block    'SQIFx CACHED'.", "APPS_SYS_CPUx_PM")
PxP_SQIFx_CACHED_UPPER                                                           = c_enum(None, 8388608, "Highest address for block   'SQIFx CACHED'.", "APPS_SYS_CPUx_PM")
PxP_TCM0_LOWER                                                                   = c_enum(None, 8388608, "Lowest address for block    'TCM0 (RAM = 32kB Region = 32kB)'.", "APPS_SYS_CPUx_PM")
PxP_TCM0_UPPER                                                                   = c_enum(None, 8421376, "Highest address for block   'TCM0 (RAM = 32kB Region = 32kB)'.", "APPS_SYS_CPUx_PM")
PxP_TCM0_SIZE                                                                    = c_enum(None, 32768, "Actual TCM0 size = 32KB", "APPS_SYS_CPUx_PM")
PxP_TCM1_LOWER                                                                   = c_enum(None, 8421376, "Lowest address for block    'TCM1 (RAM = 32kB Region = 32kB)'.", "APPS_SYS_CPUx_PM")
PxP_TCM1_UPPER                                                                   = c_enum(None, 8454144, "Highest address for block   'TCM1 (RAM = 32kB Region = 32kB)'.", "APPS_SYS_CPUx_PM")
PxP_TCM1_SIZE                                                                    = c_enum(None, 32768, "Actual TCM0 size = 32KB", "APPS_SYS_CPUx_PM")
ADDR_SEL_MSB                                                                     = c_enum(None, 31, "", "ADDR_SEL")
ADDR_SEL_LSB                                                                     = c_enum(None, 27, "", "ADDR_SEL")
ADDR_SEL_PM_MSB                                                                  = c_enum(None, 24, "", "ADDR_SEL")
ADDR_SEL_PM_LSB                                                                  = c_enum(None, 15, "", "ADDR_SEL")
ADDR_SEL_CACHE_RAM_MSB                                                           = c_enum(None, 17, "", "ADDR_SEL")
ADDR_SEL_CACHE_RAM_LSB                                                           = c_enum(None, 10, "", "ADDR_SEL")
MAP_REMOTE_REGISTER_SPACE_LOWER                                                  = c_enum(None, 1610612736, "Lowest address for remote register access area.", "APPS_SYS_MEM")
MAP_REMOTE_REGISTER_SPACE_UPPER                                                  = c_enum(None, 1610940416, "Highest address for remote register access area.", "APPS_SYS_MEM")
MAP_SQIF0_CACHED_LOWER                                                           = c_enum(None, 1879048192, "Lowest address for first cache window.", "APPS_SYS_MEM")
MAP_SQIF0_CACHED_UPPER                                                           = c_enum(None, 1887436800, "Highest address for first cache window.", "APPS_SYS_MEM")
MAP_SQIF1_CACHED_LOWER                                                           = c_enum(None, 2013265920, "Lowest address for second cache window.", "APPS_SYS_MEM")
MAP_SQIF1_CACHED_UPPER                                                           = c_enum(None, 2021654528, "Highest address for second cache window.", "APPS_SYS_MEM")
MAP_SQIF0_RAM_LOWER                                                              = c_enum(None, 2147483648, "Lowest address for first SQIF RAM window.", "APPS_SYS_MEM")
MAP_SQIF0_RAM_UPPER                                                              = c_enum(None, 2155872256, "Highest address for first SQIF RAM window.", "APPS_SYS_MEM")
MAP_SQIF1_RAM_LOWER                                                              = c_enum(None, 2281701376, "Lowest address for second SQIF RAM window.", "APPS_SYS_MEM")
MAP_SQIF1_RAM_UPPER                                                              = c_enum(None, 2290089984, "Highest address for second SQIF RAM window.", "APPS_SYS_MEM")
MAP_REMOTE_SS_ACCESS0_LOWER                                                      = c_enum(None, 2415919104, "Lowest address for second remote subsystem access window.", "APPS_SYS_MEM")
MAP_REMOTE_SS_ACCESS0_UPPER                                                      = c_enum(None, 2550136832, "Highest address for second remote subsystem access window.", "APPS_SYS_MEM")
MAP_REMOTE_SS_ACCESS1_LOWER                                                      = c_enum(None, 2550136832, "Lowest address for first remote subsystem access window.", "APPS_SYS_MEM")
MAP_REMOTE_SS_ACCESS1_UPPER                                                      = c_enum(None, 2684354560, "Highest address for first remote subsystem access window.", "APPS_SYS_MEM")
MAP_VM_BUFFER_LOWER                                                              = c_enum(None, 2684354560, "Lowest address for VM buffer space.", "APPS_SYS_MEM")
MAP_VM_BUFFER_UPPER                                                              = c_enum(None, 2952790016, "Highest address for VM buffer space.", "APPS_SYS_MEM")
MAP_SQIF0_DIRECT_LOWER                                                           = c_enum(None, 2952790016, "Lowest address for first SQIF direct (uncached) access.", "APPS_SYS_MEM")
MAP_SQIF0_DIRECT_UPPER                                                           = c_enum(None, 3489660928, "Highest address for first SQIF direct (uncached) access.", "APPS_SYS_MEM")
MAP_SQIF01_DIRECT_LOWER                                                          = c_enum(None, 3489660928, "Lowest address for second SQIF direct (uncached) access.", "APPS_SYS_MEM")
MAP_SQIF01_DIRECT_UPPER                                                          = c_enum(None, 4026531840, "Highest address for second SQIF direct (uncached) access.", "APPS_SYS_MEM")
MAP_REGISTER_SPACE_LOWER                                                         = c_enum(None, 4294942720, "Lowest address for register access area.", "APPS_SYS_MEM")
MAP_REGISTER_SPACE_UPPER                                                         = c_enum(None, 4294967292, "Highest address for register access area.", "APPS_SYS_MEM")
MAP_P0_DM_RAM_LOWER                                                              = c_enum(None, 0, "Lowest address for P0 DM.", "APPS_SYS_MEM")
MAP_P0_DM_RAM_UPPER                                                              = c_enum(None, 49152, "Highest address for P0 DM.", "APPS_SYS_MEM")
MAP_P1_DM_RAM_LOWER                                                              = c_enum(None, 131072, "Lowest address for P1 DM.", "APPS_SYS_MEM")
MAP_P1_DM_RAM_UPPER                                                              = c_enum(None, 212992, "Highest address for P1 DM.", "APPS_SYS_MEM")
MAP_TCM0_LOWER                                                                   = c_enum(None, 536870912, "Lowest address for TCM0.", "APPS_SYS_MEM")
MAP_TCM0_UPPER                                                                   = c_enum(None, 536903680, "Highest address for TCM0.", "APPS_SYS_MEM")
MAP_TCM1_LOWER                                                                   = c_enum(None, 536903680, "Lowest address for TCM1.", "APPS_SYS_MEM")
MAP_TCM1_UPPER                                                                   = c_enum(None, 536936448, "Highest address for TCM1.", "APPS_SYS_MEM")
MAP_P0_CACHE_DATA_RAM_LOWER                                                      = c_enum(None, 805306368, "Lowest address for P0 cache data RAMs.", "APPS_SYS_MEM")
MAP_P0_CACHE_DATA_RAM_UPPER                                                      = c_enum(None, 805339136, "Highest address for P0 cache data RAMs.", "APPS_SYS_MEM")
MAP_P0_CACHE_DATA_RAM0_LOWER                                                     = c_enum(None, 805306368, "Lowest address for P0 cache data RAM 0.", "APPS_SYS_MEM")
MAP_P0_CACHE_DATA_RAM0_UPPER                                                     = c_enum(None, 805322752, "Highest address for P0 cache data RAM 0.", "APPS_SYS_MEM")
MAP_P0_CACHE_DATA_RAM1_LOWER                                                     = c_enum(None, 805322752, "Lowest address for P0 cache data RAM 1.", "APPS_SYS_MEM")
MAP_P0_CACHE_DATA_RAM1_UPPER                                                     = c_enum(None, 805339136, "Highest address for P0 cache data RAM 1.", "APPS_SYS_MEM")
MAP_P0_CACHE_TAG_RAM_LOWER                                                       = c_enum(None, 805339136, "Lowest address for P0 cache tag RAM.", "APPS_SYS_MEM")
MAP_P0_CACHE_TAG_RAM_UPPER                                                       = c_enum(None, 805341184, "Highest address for P0 cache tag RAM.", "APPS_SYS_MEM")
MAP_P1_CACHE_DATA_RAM_LOWER                                                      = c_enum(None, 805502976, "Lowest address for P1 cache data RAMs.", "APPS_SYS_MEM")
MAP_P1_CACHE_DATA_RAM_UPPER                                                      = c_enum(None, 805535744, "Highest address for P1 cache data RAMs.", "APPS_SYS_MEM")
MAP_P1_CACHE_DATA_RAM0_LOWER                                                     = c_enum(None, 805502976, "Lowest address for P1 cache data RAM 0.", "APPS_SYS_MEM")
MAP_P1_CACHE_DATA_RAM0_UPPER                                                     = c_enum(None, 805519360, "Highest address for P1 cache data RAM 0.", "APPS_SYS_MEM")
MAP_P1_CACHE_DATA_RAM1_LOWER                                                     = c_enum(None, 805519360, "Lowest address for P1 cache data RAM 1.", "APPS_SYS_MEM")
MAP_P1_CACHE_DATA_RAM1_UPPER                                                     = c_enum(None, 805535744, "Highest address for P1 cache data RAM 1.", "APPS_SYS_MEM")
MAP_P1_CACHE_TAG_RAM_LOWER                                                       = c_enum(None, 805535744, "Lowest address for P1 cache tag RAM.", "APPS_SYS_MEM")
MAP_P1_CACHE_TAG_RAM_UPPER                                                       = c_enum(None, 805537792, "Highest address for P1 cache tag RAM.", "APPS_SYS_MEM")
MAP_SHARED_DM_RAM_LOWER                                                          = c_enum(None, 268435456, "Lowest address for shared RAM.", "APPS_SYS_MEM")
MAP_SHARED_DM_RAM_UPPER                                                          = c_enum(None, 268500992, "Highest address for shared RAM.", "APPS_SYS_MEM")




APPS_SYS_SQIF_WINDOW_OFFSET                                                      = c_reg(0xffff9b3c, 1, 1, 0, "RW", 32, 0, 0, 0, "apps_sys_sqif_windows", "", "Value of banked offset register. This gets added to the address of all SQIF transactions through one of the datapath master ports.", "", "", 1, 1, "", "APPS_SYS_SQIF_WINDOW_CONTROL", 0)
APPS_SYS_SQIF_WINDOW_OFFSET.APPS_SYS_SQIF_WINDOW_OFFSET                          = c_bits(APPS_SYS_SQIF_WINDOW_OFFSET, 0, 31, 0xffffffff, 32, "RW", "")
CPU0_CACHED_FLASH                                                                = c_enum(None, 0, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
CPU1_CACHED_FLASH                                                                = c_enum(None, 1, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
DMAC_FLASH                                                                       = c_enum(None, 2, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
SQIF0_RAM                                                                        = c_enum(None, 3, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
CPU0_UNCACHED_FLASH                                                              = c_enum(None, 4, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
CPU1_UNCACHED_FLASH                                                              = c_enum(None, 5, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
TBUS_FLASH                                                                       = c_enum(None, 6, "See wiki 'DigitalAppsUsage'", "APPS_SQIF_DATAPATH_PORTS")
SQIF0_CACHE0_WINDOW_OFFSET                                                       = c_enum(None, 0, "Offset register for access to Flash 0 from Cache 0.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_CACHE1_WINDOW_OFFSET                                                       = c_enum(None, 1, "Offset register for access to Flash 0 from Cache 1.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_DMAC_WINDOW_OFFSET                                                         = c_enum(None, 2, "Offset register for access to Flash 0 from DMAC.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_SPI_RAM_WINDOW_OFFSET                                                      = c_enum(None, 3, "Offset register for access to SPI RAM 0 from all masters.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_UNCACHED_CPU0_WINDOW_OFFSET                                                = c_enum(None, 4, "Offset register for access to Uncached Flash 0 from CPU0.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_UNCACHED_CPU1_WINDOW_OFFSET                                                = c_enum(None, 5, "Offset register for access to Uncached Flash 0 from CPU1.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_TBUS0_WINDOW_OFFSET                                                        = c_enum(None, 6, "Offset register for access to Flash 0 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_TBUS1_WINDOW_OFFSET                                                        = c_enum(None, 7, "Offset register for access to Flash 0 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF0_DEBUG_WINDOW_OFFSET                                                        = c_enum(None, 8, "Offset register for access to Flash 0 from remote TBus debug or SPI keyhole.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF_NUM_WINDOW_OFFSETS                                                          = c_enum(None, 9, "Redundant. SQIF1 not built. Number of SQIF window offset registers.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_CACHE0_WINDOW_OFFSET                                                       = c_enum(None, 9, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from Cache 0.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_CACHE1_WINDOW_OFFSET                                                       = c_enum(None, 10, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from Cache 1.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_DMAC_WINDOW_OFFSET                                                         = c_enum(None, 11, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from DMAC.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_SPI_RAM_WINDOW_OFFSET                                                      = c_enum(None, 12, "Redundant. SQIF1 not built. Offset register for access to SPI RAM 1 from all masters.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_UNCACHED_CPU0_WINDOW_OFFSET                                                = c_enum(None, 13, "Redundant. SQIF1 not built. Offset register for access to Uncached Flash 1 from CPU0.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_UNCACHED_CPU1_WINDOW_OFFSET                                                = c_enum(None, 14, "Redundant. SQIF1 not built. Offset register for access to Uncached Flash 1 from CPU1.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_TBUS0_WINDOW_OFFSET                                                        = c_enum(None, 15, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_TBUS1_WINDOW_OFFSET                                                        = c_enum(None, 16, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")
SQIF1_DEBUG_WINDOW_OFFSET                                                        = c_enum(None, 17, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from remote TBus debug or SPI keyhole.", "APPS_SYS_SQIF_WINDOW_OFFSET_INDEX")

APPS_SYS_SQIF0_PRESENT                                                           = c_reg(0xffff99e0, 1, 1, 0, "RW", 2, 3, 0, 0, "apps_sys_sys", "", "Indicate whether the flash and SRAM chips are attached to SQIF datpath 0.", "", "", 1, 1, "", "", 0)
APPS_SYS_SQIF0_PRESENT.APPS_SYS_SQIF0_PRESENT_FLASH                              = c_bits(APPS_SYS_SQIF0_PRESENT, 0, 0, 0x1, 1, "RW", "Flash part is present on SQIF datapath 0 lines.")
APPS_SYS_SQIF0_PRESENT.APPS_SYS_SQIF0_PRESENT_SRAM                               = c_bits(APPS_SYS_SQIF0_PRESENT, 1, 1, 0x2, 1, "RW", "SRAM part is present on SQIF datapath 0 lines. If set, accesses to SRAM on SQIF datapath 0 will be passed to the datapath, otherwise they will not, and reads will return 0.")
APPS_SYS_SQIF1_PRESENT                                                           = c_reg(0xffff99e4, 1, 0, 0, "R", 2, 0, 0, 0, "apps_sys_sys", "", "Always 0 as there is not SQIF1 on Presto. Indicate whether the flash and SRAM chips are attached to SQIF datpath 1.", "", "", 1, 1, "", "", 0)
APPS_SYS_SQIF1_PRESENT.APPS_SYS_SQIF1_PRESENT_FLASH                              = c_bits(APPS_SYS_SQIF1_PRESENT, 0, 0, 0x1, 1, "R", "Flash part is present on SQIF datapath 1 lines. This bit's value will control whether P1's SQIF flash memory regions access datpath 0 (0) or 1 (1).")
APPS_SYS_SQIF1_PRESENT.APPS_SYS_SQIF1_PRESENT_SRAM                               = c_bits(APPS_SYS_SQIF1_PRESENT, 1, 1, 0x2, 1, "R", "SRAM part is present on SQIF datapath 1 lines. If set, accesses to SRAM on SQIF datapath 1 will be passed to the datapath, otherwise they will not, and reads will return 0.")
APPS_SYS_SQIF_SEL                                                                = c_reg(0xffff9b34, 1, 1, 0, "RW", 1, 0, 0, 0, "apps_sys_sys", "", "SHOULD ALWAYS BE SET TO 0 AS SQIF1 IS NOT BUILT. Read/write access to SQIF-related registers is controlled by this bit. Set to 0 to access SQIF 0 or 1 for SQIF 1. The register modules selected are sqif, sqif_datapath, sqif_datapath_banked and sqif_datapath_tbus_bridge", "", "", 1, 1, "SQIF_ACCESS_CTRL,SQIF_CONF,SQIF_CONF2,SQIF_CORR_CFG,SQIF_CTRL,SQIF_DDR_CENTER,SQIF_DDR_DBG_SEL,SQIF_DDR_LOCKED,SQIF_DDR_MARGIN,SQIF_DEBUG_SEL,SQIF_FLASH_SIZE,SQIF_INST,SQIF_MUTEX_LOCK,SQIF_PAD_CAL,SQIF_PAD_DBG,SQIF_PEEK,SQIF_PEEK_GO,SQIF_PHASE_SEL0,SQIF_PHASE_SEL1,SQIF_PHASE_SEL2,SQIF_POKE,SQIF_POKE_LAST,SQIF_RAM_CONF,SQIF_RAM_INST,SQIF_DATAPATH_ACCESS_CTRL,SQIF_DATAPATH_BANK,SQIF_DATAPATH_MUTEX_LOCK,SQIF_DATAPATH_PERF_COUNTER,SQIF_DATAPATH_STATUS,SQIF_DATAPATH_TBUS_BRIDGE_ACCESS_CTRL,SQIF_DATAPATH_TBUS_BRIDGE_ENABLE,SQIF_DATAPATH_TBUS_BRIDGE_MUTEX_LOCK,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_ADDR_OFFSET,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_BLOCK_ID,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_CONFIG,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_CONTROL,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_DATA_LSW,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_DATA_MSW,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_SS_ID,SQIF_DATAPATH_TBUS_BRIDGE_REMOTE_STATUS,SQIF_DATAPATH_TBUS_BRIDGE_WINDOW_LOWER,SQIF_DATAPATH_TBUS_BRIDGE_WINDOW_UPPER", "", 0)
APPS_SYS_SQIF_SEL.APPS_SYS_SQIF_SEL                                              = c_bits(APPS_SYS_SQIF_SEL, 0, 0, 0x1, 1, "RW", "")
APPS_SYS_SQIF_WINDOW_CONTROL                                                     = c_reg(0xffff9b38, 1, 1, 0, "RW", 5, 0, 0, 0, "apps_sys_sys", "", "Index of offset register to be accessed at APPS_SYS_SQIF_WINDOW_OFFSET.", "", "", 1, 1, "APPS_SYS_SQIF_WINDOW_OFFSET", "", 0)
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_CACHE0_WINDOW_OFFSET            = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 0, "Offset register for access to Flash 0 from Cache 0.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_CACHE1_WINDOW_OFFSET            = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 1, "Offset register for access to Flash 0 from Cache 1.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_DMAC_WINDOW_OFFSET              = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 2, "Offset register for access to Flash 0 from DMAC.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_SPI_RAM_WINDOW_OFFSET           = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 3, "Offset register for access to SPI RAM 0 from all masters.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_UNCACHED_CPU0_WINDOW_OFFSET     = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 4, "Offset register for access to Uncached Flash 0 from CPU0.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_UNCACHED_CPU1_WINDOW_OFFSET     = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 5, "Offset register for access to Uncached Flash 0 from CPU1.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_TBUS0_WINDOW_OFFSET             = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 6, "Offset register for access to Flash 0 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_TBUS1_WINDOW_OFFSET             = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 7, "Offset register for access to Flash 0 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF0_DEBUG_WINDOW_OFFSET             = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 8, "Offset register for access to Flash 0 from remote TBus debug or SPI keyhole.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF_NUM_WINDOW_OFFSETS               = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 9, "Redundant. SQIF1 not built. Number of SQIF window offset registers.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_CACHE0_WINDOW_OFFSET            = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 9, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from Cache 0.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_CACHE1_WINDOW_OFFSET            = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 10, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from Cache 1.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_DMAC_WINDOW_OFFSET              = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 11, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from DMAC.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_SPI_RAM_WINDOW_OFFSET           = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 12, "Redundant. SQIF1 not built. Offset register for access to SPI RAM 1 from all masters.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_UNCACHED_CPU0_WINDOW_OFFSET     = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 13, "Redundant. SQIF1 not built. Offset register for access to Uncached Flash 1 from CPU0.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_UNCACHED_CPU1_WINDOW_OFFSET     = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 14, "Redundant. SQIF1 not built. Offset register for access to Uncached Flash 1 from CPU1.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_TBUS0_WINDOW_OFFSET             = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 15, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_TBUS1_WINDOW_OFFSET             = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 16, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from remote TBus master (see register APPS_SYS_TBUS_WINDOW_IDS).", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_SQIF_WINDOW_CONTROL.APPS_SYS_SYS__SQIF1_DEBUG_WINDOW_OFFSET             = c_enum(APPS_SYS_SQIF_WINDOW_CONTROL, 17, "Redundant. SQIF1 not built. Offset register for access to Flash 1 from remote TBus debug or SPI keyhole.", "APPS_SYS_SQIF_WINDOW_CONTROL")
APPS_SYS_TBUS_WINDOW_EN                                                          = c_reg(0xffff918c, 1, 1, 0, "RW", 2, 0, 0, 0, "apps_sys_sys", "", "Remote subsystem memory accesses to the SQIF flash windows will be subject to offsets if their subsystem ID matches one of the two ID fields in the APPS_SYS_TBUS_WINDOW_IDS register, and the corresponding enable bit in this register is set. This will apply one of the APPS_SYS_SYS__SQIF0_TBUS0_WINDOW_OFFSET or APPS_SYS_SYS__SQIF0_TBUS1_WINDOW_OFFSET offset values (see the APPS_SYS_SQIF_WINDOW_OFFSET register for accessing the banking value), depending on which of the matching remote subsystem ID corresponds to. If it matches neither then no offset is applied.", "", "", 1, 1, "", "", 0)
APPS_SYS_TBUS_WINDOW_EN.EN_0                                                     = c_bits(APPS_SYS_TBUS_WINDOW_EN, 0, 0, 0x1, 1, "RW", "ID of remote master 0.")
APPS_SYS_TBUS_WINDOW_EN.EN_1                                                     = c_bits(APPS_SYS_TBUS_WINDOW_EN, 1, 1, 0x2, 1, "RW", "ID of remote master 1.")
APPS_SYS_TBUS_WINDOW_IDS                                                         = c_reg(0xffff9188, 1, 1, 0, "RW", 8, 0, 0, 0, "apps_sys_sys", "", "Remote subsystem IDs which offsets will be applied to TBus memory accesses going to the SQIF flash windows. Only applied when the corresponding enable bit in APPS_SYS_TBUS_WINDOW_EN is set.", "", "", 1, 1, "", "", 0)
APPS_SYS_TBUS_WINDOW_IDS.MASTER_0                                                = c_bits(APPS_SYS_TBUS_WINDOW_IDS, 0, 3, 0xf, 4, "RW", "ID of remote master 0.")
APPS_SYS_TBUS_WINDOW_IDS.MASTER_1                                                = c_bits(APPS_SYS_TBUS_WINDOW_IDS, 4, 7, 0xf0, 4, "RW", "ID of remote master 1.")
APPS_SYS_TCM_LOCK                                                                = c_reg(0xffff9198, 1, 1, 0, "RW", 2, 0, 0, 0, "apps_sys_sys", "", "With these flags, TCM blocks 0 and 1 can be locked to prevent accidental overwrites.", "", "", 1, 1, "", "", 0)
APPS_SYS_TCM_LOCK.TCM0                                                           = c_bits(APPS_SYS_TCM_LOCK, 0, 0, 0x1, 1, "RW", "Set to 1 lock TCM0. Attempts to write will be silently ignored when this bit is 1.")
APPS_SYS_TCM_LOCK.TCM1                                                           = c_bits(APPS_SYS_TCM_LOCK, 1, 1, 0x2, 1, "RW", "Set to 1 lock TCM1. Attempts to write will be silently ignored when this bit is 1.")
APPS_SYS_TEST_REG                                                                = c_reg(0xffff9000, 1, 1, 0, "RW", 32, 0, 0, 0, "apps_sys_sys", "", "General purpose read/write 32-bit register", "", "", 1, 1, "", "", 0)
APPS_SYS_TEST_REG.APPS_SYS_TEST_REG                                              = c_bits(APPS_SYS_TEST_REG, 0, 31, 0xffffffff, 32, "RW", "")
APPS_SYS_CACHE_SEL                                                               = c_reg(0xffff9b30, 1, 1, 0, "RW", 1, 0, 0, 0, "apps_sys_sys", "", "Read/write access to cache-related registers is controlled by this bit. Set to 0 to access cache 0 or 1 for cache 1.", "", "", 1, 1, "KALIMBA_READ_CACHE_ACCESS_CTRL,KALIMBA_READ_CACHE_ARBITRATION_WAIT_COUNTER_DM,KALIMBA_READ_CACHE_ARBITRATION_WAIT_COUNTER_PM,KALIMBA_READ_CACHE_CONTROL,KALIMBA_READ_CACHE_DEBUG_DATA,KALIMBA_READ_CACHE_DEBUG_EN,KALIMBA_READ_CACHE_DM_CONFIG,KALIMBA_READ_CACHE_DM_HIT_COUNTER,KALIMBA_READ_CACHE_DM_MISS_COUNTER,KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_DM,KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_PM,KALIMBA_READ_CACHE_INVALIDATE_CONTROL,KALIMBA_READ_CACHE_INVALIDATE_NUM_LINES,KALIMBA_READ_CACHE_INVALIDATE_START_LINE,KALIMBA_READ_CACHE_MISS_LOG_BASE_ADDR,KALIMBA_READ_CACHE_MISS_LOG_ENABLE,KALIMBA_READ_CACHE_MISS_LOG_INDEX,KALIMBA_READ_CACHE_MISS_LOG_SIZE,KALIMBA_READ_CACHE_MUTEX_LOCK,KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_DM,KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_PM,KALIMBA_READ_CACHE_PARAMS,KALIMBA_READ_CACHE_PM_CONFIG,KALIMBA_READ_CACHE_PM_HIT_COUNTER,KALIMBA_READ_CACHE_PM_MISS_COUNTER,KALIMBA_READ_CACHE_SLAVE_WAIT_COUNTER,KALIMBA_READ_CACHE_SOFT_RESET,KALIMBA_READ_CACHE_TRANSITION_STATUS", "", 0)
APPS_SYS_CACHE_SEL.APPS_SYS_CACHE_SEL                                            = c_bits(APPS_SYS_CACHE_SEL, 0, 0, 0x1, 1, "RW", "")

# -- Bitserializer regs --

# -- Interrupt transaction processing config and status registers --

BUS_INT_ACCESS_CTRL                                                              = c_reg(0xffff907c, 1, 1, 0, "RW", 4, 15, 0, 0, "bus_interrupt", "", "Access control", "", "", 1, 1, "", "", 0)
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P0_ACCESS_PERMISSION                          = c_bits(BUS_INT_ACCESS_CTRL, 0, 0, 0x1, 1, "RW", "Access permission for P0")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P0_ACCESS_PERMISSION.BUS_INTERRUPT__P0_ACCESS_BLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P0_ACCESS_BLOCKED", 0, "P0 does not have read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P0_ACCESS_PERMISSION.BUS_INTERRUPT__P0_ACCESS_UNBLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P0_ACCESS_UNBLOCKED", 1, "P0 has read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P1_ACCESS_PERMISSION                          = c_bits(BUS_INT_ACCESS_CTRL, 1, 1, 0x2, 1, "RW", "Access permission for P1")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P1_ACCESS_PERMISSION.BUS_INTERRUPT__P1_ACCESS_BLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P1_ACCESS_BLOCKED", 0, "P1 does not have read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P1_ACCESS_PERMISSION.BUS_INTERRUPT__P1_ACCESS_UNBLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P1_ACCESS_UNBLOCKED", 1, "P1 has read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P2_ACCESS_PERMISSION                          = c_bits(BUS_INT_ACCESS_CTRL, 2, 2, 0x4, 1, "RW", "Access permission for P2")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P2_ACCESS_PERMISSION.BUS_INTERRUPT__P2_ACCESS_BLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P2_ACCESS_BLOCKED", 0, "P2 does not have read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P2_ACCESS_PERMISSION.BUS_INTERRUPT__P2_ACCESS_UNBLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P2_ACCESS_UNBLOCKED", 1, "P2 has read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P3_ACCESS_PERMISSION                          = c_bits(BUS_INT_ACCESS_CTRL, 3, 3, 0x8, 1, "RW", "Access permission for P3")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P3_ACCESS_PERMISSION.BUS_INTERRUPT__P3_ACCESS_BLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P3_ACCESS_BLOCKED", 0, "P3 does not have read/write access")
BUS_INT_ACCESS_CTRL.BUS_INTERRUPT__P3_ACCESS_PERMISSION.BUS_INTERRUPT__P3_ACCESS_UNBLOCKED = c_value(BUS_INT_ACCESS_CTRL, "BUS_INTERRUPT__P3_ACCESS_UNBLOCKED", 1, "P3 has read/write access")
BUS_INT_CLEAR                                                                    = c_reg(0xffff9058, 1, 1, 0, "RW", 16, 0, 1, 0, "bus_interrupt", "", "Clear the interrupt status bits for the selected identifier in BUS_INT_SELECT.", "", "", 1, 1, "", "", 0)
BUS_INT_CLEAR.BUS_INT_CLEAR                                                      = c_bits(BUS_INT_CLEAR, 0, 15, 0xffff, 16, "RW", "")
BUS_INT_CONFIG                                                                   = c_reg(0xffff9060, 1, 1, 0, "RW", 10, 0, 1, 0, "bus_interrupt", "", "Set the configuration for the interrupt event specified in BUS_INT_SELECT.", "", "", 1, 1, "", "", 0)
BUS_INT_CONFIG.BUS_INT_CONFIG_SUBSYSTEM                                          = c_bits(BUS_INT_CONFIG, 0, 3, 0xf, 4, "RW", "Subsystem ID to match for the interrupt event specified in BUS_INT_SELECT.")
BUS_INT_CONFIG.BUS_INT_CONFIG_BLOCK                                              = c_bits(BUS_INT_CONFIG, 4, 7, 0xf0, 4, "RW", "Block ID to match for the interrupt event specified in BUS_INT_SELECT.")
BUS_INT_CONFIG.BUS_INT_CONFIG_ENABLE                                             = c_bits(BUS_INT_CONFIG, 8, 8, 0x100, 1, "RW", "Allow the generation of the interrupt event specified in BUS_INT_SELECT if the subsystem and block ID matches an incoming interrupt transaction.")
BUS_INT_CONFIG.BUS_INT_CONFIG_STATUS_CLEAR_ON_READ                               = c_bits(BUS_INT_CONFIG, 9, 9, 0x200, 1, "RW", "Enable clearing of the interrupt status specified in BUS_INT_SELECT when reading BUS_INT_STATUS. This clears only the bits specified in BUS_INT_MASK.")
BUS_INT_CONFIG_STATUS                                                            = c_reg(0xffff9064, 1, 0, 0, "R", 10, 0, 0, 0, "bus_interrupt", "", "The value of the config settings for the event specified in BUS_INT_SELECT.", "", "", 1, 1, "", "", 0)
BUS_INT_CONFIG_STATUS.BUS_INT_CONFIG_SUBSYSTEM                                   = c_bits(BUS_INT_CONFIG_STATUS, 0, 3, 0xf, 4, "R", "Subsystem ID to match for the interrupt event specified in BUS_INT_SELECT.")
BUS_INT_CONFIG_STATUS.BUS_INT_CONFIG_BLOCK                                       = c_bits(BUS_INT_CONFIG_STATUS, 4, 7, 0xf0, 4, "R", "Block ID to match for the interrupt event specified in BUS_INT_SELECT.")
BUS_INT_CONFIG_STATUS.BUS_INT_CONFIG_ENABLE                                      = c_bits(BUS_INT_CONFIG_STATUS, 8, 8, 0x100, 1, "R", "Allow the generation of the interrupt event specified in BUS_INT_SELECT if the subsystem and block ID matches an incoming interrupt transaction.")
BUS_INT_CONFIG_STATUS.BUS_INT_CONFIG_STATUS_CLEAR_ON_READ                        = c_bits(BUS_INT_CONFIG_STATUS, 9, 9, 0x200, 1, "R", "Enable clearing of the interrupt status specified in BUS_INT_SELECT when reading BUS_INT_STATUS. This clears only the bits specified in BUS_INT_MASK.")
BUS_INT_MASK                                                                     = c_reg(0xffff9054, 1, 1, 0, "RW", 16, 0, 1, 0, "bus_interrupt", "", "Set the interrupt mask bits for the selected identifier in BUS_INT_SELECT.", "", "", 1, 1, "", "", 0)
BUS_INT_MASK_STATUS                                                              = c_reg(0xffff9068, 1, 0, 0, "R", 16, 0, 0, 0, "bus_interrupt", "", "The value of the mask settings for the event specified in BUS_INT_SELECT.", "", "", 1, 1, "", "", 0)
BUS_INT_MASK_STATUS.BUS_INT_MASK_STATUS                                          = c_bits(BUS_INT_MASK_STATUS, 0, 15, 0xffff, 16, "R", "")
BUS_INT_MUTEX_LOCK                                                               = c_reg(0xffff9078, 1, 1, 0, "RW", 4, 15, 0, 0, "bus_interrupt", "", "Mutex lock", "", "", 1, 1, "", "", 0)
BUS_INT_MUTEX_LOCK.BUS_INTERRUPT__MUTEX_AVAILABLE                                = c_enum(BUS_INT_MUTEX_LOCK, 0, "4'b0000 means mutex available, claim it to access the resouce", "BUS_INT_MUTEX_LOCK")
BUS_INT_MUTEX_LOCK.BUS_INTERRUPT__MUTEX_CLAIMED_BY_P0                            = c_enum(BUS_INT_MUTEX_LOCK, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "BUS_INT_MUTEX_LOCK")
BUS_INT_MUTEX_LOCK.BUS_INTERRUPT__MUTEX_CLAIMED_BY_P1                            = c_enum(BUS_INT_MUTEX_LOCK, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "BUS_INT_MUTEX_LOCK")
BUS_INT_MUTEX_LOCK.BUS_INTERRUPT__MUTEX_CLAIMED_BY_P2                            = c_enum(BUS_INT_MUTEX_LOCK, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "BUS_INT_MUTEX_LOCK")
BUS_INT_MUTEX_LOCK.BUS_INTERRUPT__MUTEX_CLAIMED_BY_P3                            = c_enum(BUS_INT_MUTEX_LOCK, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "BUS_INT_MUTEX_LOCK")
BUS_INT_MUTEX_LOCK.BUS_INTERRUPT__MUTEX_DISABLED                                 = c_enum(BUS_INT_MUTEX_LOCK, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "BUS_INT_MUTEX_LOCK")
BUS_INT_SELECT                                                                   = c_reg(0xffff9050, 1, 1, 0, "RW", 4, 0, 0, 0, "bus_interrupt", "", "Select the interrupt identifier number.", "", "", 1, 1, "", "", 0)
BUS_INT_SELECT.BUS_INT_SELECT                                                    = c_bits(BUS_INT_SELECT, 0, 3, 0xf, 4, "RW", "")
BUS_INT_SEND_INT_CONFIG                                                          = c_reg(0xffff906c, 1, 1, 0, "RW", 12, 0, 0, 0, "bus_interrupt", "", "Configure the destination subsystem for the interrupt transaction.", "", "", 1, 1, "", "", 0)
BUS_INT_SEND_INT_CONFIG.BUS_INT_SEND_INT_CONFIG_SUBSYSTEM                        = c_bits(BUS_INT_SEND_INT_CONFIG, 0, 3, 0xf, 4, "RW", "Specify the destination subsystem.")
BUS_INT_SEND_INT_CONFIG.BUS_INT_SEND_INT_CONFIG_SRC_BLOCK_ID                     = c_bits(BUS_INT_SEND_INT_CONFIG, 4, 7, 0xf0, 4, "RW", "Specify the source block ID for the interrupt.")
BUS_INT_SEND_INT_CONFIG.BUS_INT_SEND_INT_CONFIG_DEST_BLOCK_ID                    = c_bits(BUS_INT_SEND_INT_CONFIG, 8, 11, 0xf00, 4, "RW", "Specify the destination block ID for the interrupt.")
BUS_INT_SEND_INT_SEND_STATUS                                                     = c_reg(0xffff9074, 1, 0, 0, "R", 2, 0, 0, 0, "bus_interrupt", "", "The current state machine status of the interrupt sending state machine. An interrupt should not be sent unless this is 0.", "", "", 1, 1, "", "", 0)
BUS_INT_SEND_INT_SEND_STATUS.BUS_INT_SEND_INT_SEND_STATUS                        = c_bits(BUS_INT_SEND_INT_SEND_STATUS, 0, 1, 0x3, 2, "R", "")
BUS_INT_SEND_INT_STATUS_FIELD                                                    = c_reg(0xffff9070, 1, 1, 0, "RW", 16, 0, 1, 0, "bus_interrupt", "", "Set the status of the interrupt transaction. Writing this causes the interrupt to be sent.", "", "", 1, 1, "", "", 0)
BUS_INT_SEND_INT_STATUS_FIELD.BUS_INT_SEND_INT_STATUS_FIELD                      = c_bits(BUS_INT_SEND_INT_STATUS_FIELD, 0, 15, 0xffff, 16, "RW", "")
BUS_INT_STATUS                                                                   = c_reg(0xffff905c, 1, 0, 0, "R", 16, 0, 0, 1, "bus_interrupt", "", "Interrupt status bits for the selected identifier in BUS_INT_SELECT. If the BUS_INT_CONFIG_STATUS_CLEAR_ON_READ bit is set for the interrupt status being read then that status is cleared immediately following the read otherwise it remains unchanged and must be manually cleared by writing to BUS_INT_CLEAR.", "", "", 1, 1, "", "", 0)
BUS_INT_STATUS.BUS_INT_STATUS                                                    = c_bits(BUS_INT_STATUS, 0, 15, 0xffff, 16, "R", "")
BUS_INT_CONFIG_SUBSYSTEM                                                         = c_enum(None, 0, "Subsystem ID to match for the interrupt event specified in BUS_INT_SELECT.", "BUS_INT_CONFIG_ENUM")
BUS_INT_CONFIG_BLOCK                                                             = c_enum(None, 4, "Block ID to match for the interrupt event specified in BUS_INT_SELECT.", "BUS_INT_CONFIG_ENUM")
BUS_INT_CONFIG_ENABLE                                                            = c_enum(None, 8, "Allow the generation of the interrupt event specified in BUS_INT_SELECT if the subsystem and block ID matches an incoming interrupt transaction.", "BUS_INT_CONFIG_ENUM")
BUS_INT_CONFIG_STATUS_CLEAR_ON_READ                                              = c_enum(None, 9, "Enable clearing of the interrupt status specified in BUS_INT_SELECT when reading BUS_INT_STATUS. This clears only the bits specified in BUS_INT_MASK.", "BUS_INT_CONFIG_ENUM")
BUS_INTERRUPT__P0_ACCESS_PERMISSION                                              = c_enum(None, 0, "Access permission for P0", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P0_ACCESS_BLOCKED                                                 = c_enum(None, 0, "P0 does not have read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P0_ACCESS_UNBLOCKED                                               = c_enum(None, 1, "P0 has read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P1_ACCESS_PERMISSION                                              = c_enum(None, 1, "Access permission for P1", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P1_ACCESS_BLOCKED                                                 = c_enum(None, 0, "P1 does not have read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P1_ACCESS_UNBLOCKED                                               = c_enum(None, 1, "P1 has read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P2_ACCESS_PERMISSION                                              = c_enum(None, 2, "Access permission for P2", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P2_ACCESS_BLOCKED                                                 = c_enum(None, 0, "P2 does not have read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P2_ACCESS_UNBLOCKED                                               = c_enum(None, 1, "P2 has read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P3_ACCESS_PERMISSION                                              = c_enum(None, 3, "Access permission for P3", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P3_ACCESS_BLOCKED                                                 = c_enum(None, 0, "P3 does not have read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__P3_ACCESS_UNBLOCKED                                               = c_enum(None, 1, "P3 has read/write access", "BUS_INTERRUPT__ACCESS_CTRL_ENUM")
BUS_INTERRUPT__MUTEX_AVAILABLE                                                   = c_enum(None, 0, "4'b0000 means mutex available, claim it to access the resouce", "BUS_INTERRUPT__MUTEX_LOCK_ENUM")
BUS_INTERRUPT__MUTEX_CLAIMED_BY_P0                                               = c_enum(None, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "BUS_INTERRUPT__MUTEX_LOCK_ENUM")
BUS_INTERRUPT__MUTEX_CLAIMED_BY_P1                                               = c_enum(None, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "BUS_INTERRUPT__MUTEX_LOCK_ENUM")
BUS_INTERRUPT__MUTEX_CLAIMED_BY_P2                                               = c_enum(None, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "BUS_INTERRUPT__MUTEX_LOCK_ENUM")
BUS_INTERRUPT__MUTEX_CLAIMED_BY_P3                                               = c_enum(None, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "BUS_INTERRUPT__MUTEX_LOCK_ENUM")
BUS_INTERRUPT__MUTEX_DISABLED                                                    = c_enum(None, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "BUS_INTERRUPT__MUTEX_LOCK_ENUM")

HOST_SYS_REG_ACCESS_SUBSYS_IN_ADDR_EN                                            = c_reg(0x6004d05c, 1, 1, 0, "", 16, 1, 0, 0, "", "", "", "", "", 0, 1, "", "", 0)
HOST_SYS_REG_ACCESS_SUBSYS_IN_ADDR_EN.HOST_SYS_REG_ACCESS_SUBSYS_IN_ADDR_EN      = c_bits(HOST_SYS_REG_ACCESS_SUBSYS_IN_ADDR_EN, 0, 15, 0xffff, 16, "", "")

# -- Kalimba 32-bit Core Control registers --
ARITHMETIC_MODE                                                                  = c_reg(0xffff8014, 1, 1, 0, "RW", 5, 0, 0, 0, "k32_core", "", "Configures some arithmetic features of Kalimba's ALU.", "", "", 0, 1, "", "", 0)
ARITHMETIC_MODE.ADDSUB_SATURATE_ON_OVERFLOW                                      = c_bits(ARITHMETIC_MODE, 0, 0, 0x1, 1, "RW", "Enables saturation on overflow for addition or subtraction in the ALU. For example, 0x7FFFFFF0 + 0x15 saturates to 0x7FFFFFFF rather than wrapping around to 0x80000005.")
ARITHMETIC_MODE.ARITHMETIC_16BIT_MODE                                            = c_bits(ARITHMETIC_MODE, 1, 1, 0x2, 1, "RW", "Unsupported on KALIMBA_ARCH 4 &#38; 5")
ARITHMETIC_MODE.DISABLE_UNBIASED_ROUNDING                                        = c_bits(ARITHMETIC_MODE, 2, 2, 0x4, 1, "RW", "Disables unbiased rounding of all internal double-precision values when converting them to 32 bits. Unbiased rounding rounds odd midpoint values away from zero and even midpoint values towards zero. 20.5 (0x00_00000014_80000000) is an example of an even midpoint value, and so would round to 20. -1.5 (0xFF_FFFFFFFE_80000000) is an example of an odd midpoint value, and so would round to -2. Unbiased rounding yields a zero large-sample bias, assuming uniformly distributed values.")
ARITHMETIC_MODE.DISABLE_FRAC_MULT_ROUNDING                                       = c_bits(ARITHMETIC_MODE, 3, 3, 0x8, 1, "RW", "Disables rounding of the result of a fractional multiply when storing to a 32-bit register. With rounding disabled, truncation occurs. For example, 10.75 (0x00_0000000A_C0000000) would round to 11 but be truncated to 10.")
ARITHMETIC_MODE.DISABLE_RMAC_STORE_ROUNDING                                      = c_bits(ARITHMETIC_MODE, 4, 4, 0x10, 1, "RW", "Disables rounding of the rMAC72 value when it is written to memory or a 32-bit register.")
BITREVERSE_ADDR                                                                  = c_reg(0xffff8038, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A read of this register will return the bitreverse of the bottom 31 bits of the data in BITREVERSE_VAL and will copy the MS bit.  This is a useful operation for bit reversing addresses as is required for a radix-2 FFT implementation.", "", "", 0, 1, "", "", 0)
BITREVERSE_ADDR.BITREVERSE_ADDR                                                  = c_bits(BITREVERSE_ADDR, 0, 31, 0xffffffff, 32, "R", "")
BITREVERSE_DATA                                                                  = c_reg(0xffff8030, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A read of this register will return a full 32-bit bitreverse of the data previously written to the  BITREVERSE_VAL register.", "", "", 0, 1, "", "", 0)
BITREVERSE_DATA.BITREVERSE_DATA                                                  = c_bits(BITREVERSE_DATA, 0, 31, 0xffffffff, 32, "R", "")
BITREVERSE_DATA16                                                                = c_reg(0xffff8034, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A read of this register will return the bitreverse of the LS 16 bits of BITREVERSE_VAL. The 16-bit value is then sign extended to 32 bits.", "", "", 0, 1, "", "", 0)
BITREVERSE_DATA16.BITREVERSE_DATA16                                              = c_bits(BITREVERSE_DATA16, 0, 31, 0xffffffff, 32, "R", "")
BITREVERSE_VAL                                                                   = c_reg(0xffff802c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "Data written to this register is passed to the bitreverser hardware. (See BITREVERSE_XXX registers below). This register can be read in order to do context saving (eg during ISR).", "", "", 0, 1, "", "", 0)
BITREVERSE_VAL.BITREVERSE_VAL                                                    = c_bits(BITREVERSE_VAL, 0, 31, 0xffffffff, 32, "RW", "")
DBG_COUNTERS_EN                                                                  = c_reg(0xffff8050, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_core", "", "When set to 1, enables the operation of the NUM_RUN_CLKS, NUM_INSTRS and NUM_STALLS registers.  By default it is disabled to slightly reduce Kalimba's current consumption.", "", "", 0, 1, "", "", 0)
DBG_COUNTERS_EN.DBG_COUNTERS_EN                                                  = c_bits(DBG_COUNTERS_EN, 0, 0, 0x1, 1, "RW", "")
FRAME_POINTER                                                                    = c_reg(0xffff8028, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Memory mapped version of the current frame pointer. Also accessable from the bank 3 register FP.", "", "", 0, 1, "", "", 0)
FRAME_POINTER.FRAME_POINTER                                                      = c_bits(FRAME_POINTER, 0, 31, 0xffffffff, 32, "RW", "")
MM_DOLOOP_END                                                                    = c_reg(0xffff8004, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "End address of the zero overhead loop. This register is set by executing a \"do\" instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_DOLOOP_END.MM_DOLOOP_END                                                      = c_bits(MM_DOLOOP_END, 0, 31, 0xffffffff, 32, "RW", "")
MM_DOLOOP_START                                                                  = c_reg(0xffff8000, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Start address of the zero overhead loop. This register is set by executing a \"do\" instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_DOLOOP_START.MM_DOLOOP_START                                                  = c_bits(MM_DOLOOP_START, 0, 31, 0xffffffff, 32, "RW", "")
MM_QUOTIENT                                                                      = c_reg(0xffff8008, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Quotient result of division instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_QUOTIENT.MM_QUOTIENT                                                          = c_bits(MM_QUOTIENT, 0, 31, 0xffffffff, 32, "RW", "")
MM_REM                                                                           = c_reg(0xffff800c, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Remainder result of division instruction. It is memory mapped to enable context saving and restoring, e.g. in an ISR. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_REM.MM_REM                                                                    = c_bits(MM_REM, 0, 31, 0xffffffff, 32, "RW", "")
MM_RINTLINK                                                                      = c_reg(0xffff8010, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "The return PC address stored in this register is used by the rti instruction. This register can also be accessed from the bank 3 registers by push/pop instructions.", "", "", 0, 1, "", "", 0)
MM_RINTLINK.MM_RINTLINK                                                          = c_bits(MM_RINTLINK, 0, 31, 0xffffffff, 32, "RW", "")
NUM_CORE_STALLS                                                                  = c_reg(0xffff8044, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor core stalls that have occured (this covers instruction decoding related stalls only and does not include stalls due to DM and PM memory bus waits or delays within the prefetch logic).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_CORE_STALLS.NUM_CORE_STALLS                                                  = c_bits(NUM_CORE_STALLS, 0, 31, 0xffffffff, 32, "R", "")
NUM_INSTRS                                                                       = c_reg(0xffff8040, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor instructions that have been executed.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_INSTRS.NUM_INSTRS                                                            = c_bits(NUM_INSTRS, 0, 31, 0xffffffff, 32, "R", "")
NUM_INSTR_EXPAND_STALLS                                                          = c_reg(0xffff804c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor stalls due to expanding of compressed instructions (either: Maxim Push/Pop multiple; or large Minim instructions).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_INSTR_EXPAND_STALLS.NUM_INSTR_EXPAND_STALLS                                  = c_bits(NUM_INSTR_EXPAND_STALLS, 0, 31, 0xffffffff, 32, "R", "")
NUM_MEM_ACCESS_STALLS                                                            = c_reg(0xffff8048, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor stalls due to memory acccesses (either: DM1/DM2 bus waits; IAG1/IAG2/MAIN DM bus overlap waits; or core stalls due to DM address forwarding).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_MEM_ACCESS_STALLS.NUM_MEM_ACCESS_STALLS                                      = c_bits(NUM_MEM_ACCESS_STALLS, 0, 31, 0xffffffff, 32, "R", "")
NUM_RUN_CLKS                                                                     = c_reg(0xffff803c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "A debugging register than reports the number of processor clock cycles that have occured whilst running.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
NUM_RUN_CLKS.NUM_RUN_CLKS                                                        = c_bits(NUM_RUN_CLKS, 0, 31, 0xffffffff, 32, "R", "")
PC_STATUS                                                                        = c_reg(0xffff8054, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "Current value of the processor's program counter. This register still exists for legacy reasons but shouldn't be needed as there are alternative methods of obtaining the current PC.", "", "", 0, 1, "", "", 0)
PC_STATUS.PC_STATUS                                                              = c_bits(PC_STATUS, 0, 31, 0xffffffff, 32, "R", "")
STACK_END_ADDR                                                                   = c_reg(0xffff801c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "Write to this register to set the Stack end address.  Note: It must be greater than the STACK_START_ADDR as stack builds upwards, and must also be word aligned. ", "", "", 0, 1, "", "", 0)
STACK_END_ADDR.STACK_END_ADDR                                                    = c_bits(STACK_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
STACK_OVERFLOW_PC                                                                = c_reg(0xffff8024, 1, 0, 0, "R", 32, 0, 0, 0, "k32_core", "", "Address of the last instruction which generated a stack overflow event. (See INT_EVENT_ERROR).", "", "", 0, 1, "", "", 0)
STACK_OVERFLOW_PC.STACK_OVERFLOW_PC                                              = c_bits(STACK_OVERFLOW_PC, 0, 31, 0xffffffff, 32, "R", "")
STACK_POINTER                                                                    = c_reg(0xffff8020, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_core", "", "Memory mapped version of the current stack pointer. Also accessable from the bank 3 register SP.", "", "", 0, 1, "", "", 0)
STACK_POINTER.STACK_POINTER                                                      = c_bits(STACK_POINTER, 0, 31, 0xffffffff, 32, "RW", "")
STACK_START_ADDR                                                                 = c_reg(0xffff8018, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "Write to this register to set the Stack start address.  Note: The stack must be located at a word boundary (not at a half-word or byte offset).", "", "", 0, 1, "", "", 0)
STACK_START_ADDR.STACK_START_ADDR                                                = c_bits(STACK_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_0                                                                       = c_reg(0xffff8058, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_0.TEST_REG_0                                                            = c_bits(TEST_REG_0, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_1                                                                       = c_reg(0xffff805c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_1.TEST_REG_1                                                            = c_bits(TEST_REG_1, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_2                                                                       = c_reg(0xffff8060, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_2.TEST_REG_2                                                            = c_bits(TEST_REG_2, 0, 31, 0xffffffff, 32, "RW", "")
TEST_REG_3                                                                       = c_reg(0xffff8064, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_core", "", "General purpose register, possibly useful for low level debug.", "", "", 0, 1, "", "", 0)
TEST_REG_3.TEST_REG_3                                                            = c_bits(TEST_REG_3, 0, 31, 0xffffffff, 32, "RW", "")

# -- Kalimba 32-bit Program Flow Debug Control registers. Note: All these registers are only accessable from SPI and T-Bus, not from Kalimba core itself. --

DEBUG                                                                            = c_reg(0xfffffe30, 1, 1, 0, "RW", 19, 0, 0, 0, "k32_debug_prog_flow", "", "A control register for configuring debugger operations.", "", "", 0, 1, "", "", 0)
DEBUG.DEBUG_RUN                                                                  = c_bits(DEBUG, 0, 0, 0x1, 1, "RW", "Setting this bit causes Kalimba to run.  Clearing this bit causes Kalimba to stop.  When running breakpoints being hit will pause execution.")
DEBUG.DEBUG_STEP                                                                 = c_bits(DEBUG, 1, 1, 0x2, 1, "RW", "Provide single stepping operation: To single step this bit must be first set.  After a clock tick the bit can be cleared and a debugger should wait until the STATUS_SINGSTEPCOMP bit goes high, which means that the single step operation has completed.")
DEBUG.DEBUG_DUMMY                                                                = c_bits(DEBUG, 2, 2, 0x4, 1, "RW", "Unused bit (there for legacy purposes).")
DEBUG.DEBUG_PM_BREAK0                                                            = c_bits(DEBUG, 3, 3, 0x8, 1, "RW", "Setting this bit enables Program Breakpoint 0 configured by PM_BREAK0_ADDR.")
DEBUG.DEBUG_PM_BREAK1                                                            = c_bits(DEBUG, 4, 4, 0x10, 1, "RW", "Setting this bit enables Program Breakpoint 1 configured by PM_BREAK1_ADDR.")
DEBUG.DEBUG_PM_BREAK2                                                            = c_bits(DEBUG, 5, 5, 0x20, 1, "RW", "Setting this bit enables Program Breakpoint 2 configured by PM_BREAK2_ADDR.")
DEBUG.DEBUG_PM_BREAK3                                                            = c_bits(DEBUG, 6, 6, 0x40, 1, "RW", "Setting this bit enables Program Breakpoint 3 configured by PM_BREAK3_ADDR.")
DEBUG.DEBUG_PM_BREAK4                                                            = c_bits(DEBUG, 7, 7, 0x80, 1, "RW", "Setting this bit enables Program Breakpoint 4 configured by PM_BREAK4_ADDR.")
DEBUG.DEBUG_PM_BREAK5                                                            = c_bits(DEBUG, 8, 8, 0x100, 1, "RW", "Setting this bit enables Program Breakpoint 5 configured by PM_BREAK5_ADDR.")
DEBUG.DEBUG_PM_BREAK6                                                            = c_bits(DEBUG, 9, 9, 0x200, 1, "RW", "Setting this bit enables Program Breakpoint 6 configured by PM_BREAK6_ADDR.")
DEBUG.DEBUG_PM_BREAK7                                                            = c_bits(DEBUG, 10, 10, 0x400, 1, "RW", "Setting this bit enables Program Breakpoint 7 configured by PM_BREAK7_ADDR.")
DEBUG.DEBUG_DM_WRITE_BREAK0                                                      = c_bits(DEBUG, 11, 11, 0x800, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit on memory writes (see DM_BREAK0_START_ADDR).")
DEBUG.DEBUG_DM_READ_BREAK0                                                       = c_bits(DEBUG, 12, 12, 0x1000, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit on memory reads (see DM_BREAK0_START_ADDR).")
DEBUG.DEBUG_DM_WRITE_BREAK1                                                      = c_bits(DEBUG, 13, 13, 0x2000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit on memory writes (see DM_BREAK1_START_ADDR).")
DEBUG.DEBUG_DM_READ_BREAK1                                                       = c_bits(DEBUG, 14, 14, 0x4000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit on memory reads (see DM_BREAK1_START_ADDR).")
DEBUG.DEBUG_DM_BYTE_MATCH_EN_BREAK0                                              = c_bits(DEBUG, 15, 15, 0x8000, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit only if memory access byte-enables overlap DM_BREAK0_BYTE_SELECT as well.")
DEBUG.DEBUG_DM_DATA_MATCH_EN_BREAK0                                              = c_bits(DEBUG, 16, 16, 0x10000, 1, "RW", "Setting this bit enables Data Breakpoint 0 to be hit only if memory read or write data ANDed with DM_BREAK0_DATA_MASK equal DM_BREAK0_DATA_VALUE as well.")
DEBUG.DEBUG_DM_BYTE_MATCH_EN_BREAK1                                              = c_bits(DEBUG, 17, 17, 0x20000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit only if memory access byte-enables overlap DM_BREAK1_BYTE_SELECT as well.")
DEBUG.DEBUG_DM_DATA_MATCH_EN_BREAK1                                              = c_bits(DEBUG, 18, 18, 0x40000, 1, "RW", "Setting this bit enables Data Breakpoint 1 to be hit only if memory read or write data ANDed with DM_BREAK1_DATA_MASK equal DM_BREAK1_DATA_VALUE as well.")
DEBUG_PM_BREAK7_ENABLED                                                          = c_reg(0xfffffe60, 1, 1, 0, "RW", 7, 0, 1, 1, "k32_debug_prog_flow", "", "A status register indicating which of the other PM breakpoints triggered the enabling of PM breakpoint 7. Clear this by writing bits to zero.", "", "", 0, 1, "", "", 0)
DEBUG_PM_BREAK7_ENABLED.DEBUG_PM_BREAK7_ENABLED                                  = c_bits(DEBUG_PM_BREAK7_ENABLED, 0, 6, 0x7f, 7, "RW", "")
DEBUG_PM_BREAK7_ENABLES                                                          = c_reg(0xfffffe5c, 1, 1, 0, "RW", 7, 0, 0, 0, "k32_debug_prog_flow", "", "A control register for configuring additional enables for PM breakpoint 7. When this register is non-zero, and PM breakpoint 7 is enabled via DEBUG_PM_BREAK7, this breakpoint only becomes enabled once a breakpoint selected by this register has been hit. Note that a breakpoint selected as an enable for breakpoint 7 will not cause a break when it is hit, rather will trigger a write to its corresponding bit in DEBUG_PM_BREAK7_ENABLED. As soon as any bits in DEBUG_PM_BREAK7_ENABLED are set by their corresponding PM breakpoint, then breakpoint 7 is armed and will trigger a breakpoint as per normal operation. When this register is zero then PM breakpoint 7 has no special behaviour.", "", "", 0, 1, "", "", 0)
DEBUG_PM_BREAK7_ENABLES.DEBUG_PM_BREAK7_ENABLES                                  = c_bits(DEBUG_PM_BREAK7_ENABLES, 0, 6, 0x7f, 7, "RW", "")
DM_BREAK0_BYTE_SELECT                                                            = c_reg(0xfffffe40, 1, 1, 0, "RW", 4, 0, 0, 0, "k32_debug_prog_flow", "", "Byte-enables to check for when DEBUG_DM_BYTE_MATCH_EN_BREAK0 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK0_BYTE_SELECT.DM_BREAK0_BYTE_SELECT                                      = c_bits(DM_BREAK0_BYTE_SELECT, 0, 3, 0xf, 4, "RW", "")
DM_BREAK0_DATA_MASK                                                              = c_reg(0xfffffe48, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Mask value (for read data and write data) when DEBUG_DM_DATA_MATCH_EN_BREAK0 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK0_DATA_VALUE                                                             = c_reg(0xfffffe44, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Read data or write data value to check for when DEBUG_DM_DATA_MATCH_EN_BREAK0 is set. Note that data value is always 32-bit so for example to hit on byte value 0xAA at offset 0x1, DM_BREAK0_BYTE_SELECT, DM_BREAK0_DATA_VALUE  and DM_BREAK0_DATA_MASK should be configured to 0x2, 0xAA00 and 0xFF00 respectively.", "", "", 0, 1, "", "", 0)
DM_BREAK0_DATA_VALUE.DM_BREAK0_DATA_VALUE                                        = c_bits(DM_BREAK0_DATA_VALUE, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK0_END_ADDR                                                               = c_reg(0xfffffe04, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "See comments under DM_BREAK0_START_ADDR.", "", "", 0, 1, "", "", 0)
DM_BREAK0_END_ADDR.DM_BREAK0_END_ADDR                                            = c_bits(DM_BREAK0_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK0_START_ADDR                                                             = c_reg(0xfffffe00, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Along with DM_BREAK0_END_ADDR and the control bits in DEBUG these allow a debugger to configure a Data breakpoint that will be fired on data accesses in the address range DM_BREAK0_START_ADDR -> DM_BREAK0_END_ADDR (inclusive). The data breakpoint may be fired on memory reads, memory writes, or either.  This is selected by the appropriate bits (DEBUG_DM_WRITE_BREAK0 and DEBUG_DM_READ_BREAK0) in the DEBUG register.  The LS 2-bits of these address registers must be zero (but you can still trap on an individual byte or halfword using DEBUG_DM_BYTE_MATCH_EN_BREAK0 feature).", "", "", 0, 1, "", "", 0)
DM_BREAK0_START_ADDR.DM_BREAK0_START_ADDR                                        = c_bits(DM_BREAK0_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK1_BYTE_SELECT                                                            = c_reg(0xfffffe4c, 1, 1, 0, "RW", 4, 0, 0, 0, "k32_debug_prog_flow", "", "Byte-enables to check for when when DEBUG_DM_BYTE_MATCH_EN_BREAK1 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK1_BYTE_SELECT.DM_BREAK1_BYTE_SELECT                                      = c_bits(DM_BREAK1_BYTE_SELECT, 0, 3, 0xf, 4, "RW", "")
DM_BREAK1_DATA_MASK                                                              = c_reg(0xfffffe54, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Mask value (for read data and write data) when DEBUG_DM_DATA_MATCH_EN_BREAK1 is set.", "", "", 0, 1, "", "", 0)
DM_BREAK1_DATA_VALUE                                                             = c_reg(0xfffffe50, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "Read data or write data value to check for when DEBUG_DM_DATA_MATCH_EN_BREAK1 is set. Note that data value is always 32-bit so for example to hit on halfword value 0xBBBB at offset 0x2, DM_BREAK1_BYTE_SELECT, DM_BREAK1_DATA_VALUE and DM_BREAK1_DATA_MASK should be configured to 0xC, 0xBBBB0000 and 0xFFFF0000 respectively.", "", "", 0, 1, "", "", 0)
DM_BREAK1_DATA_VALUE.DM_BREAK1_DATA_VALUE                                        = c_bits(DM_BREAK1_DATA_VALUE, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK1_END_ADDR                                                               = c_reg(0xfffffe0c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "See comments under DM_BREAK1_END_ADDR.", "", "", 0, 1, "", "", 0)
DM_BREAK1_END_ADDR.DM_BREAK1_END_ADDR                                            = c_bits(DM_BREAK1_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM_BREAK1_START_ADDR                                                             = c_reg(0xfffffe08, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_prog_flow", "", "This allows a second data breakpoint to be configured.  See comments under DM_BREAK0_START_ADDR.", "", "", 0, 1, "", "", 0)
DM_BREAK1_START_ADDR.DM_BREAK1_START_ADDR                                        = c_bits(DM_BREAK1_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
EXTERNAL_BREAK                                                                   = c_reg(0xfffffe38, 1, 1, 0, "RW", 2, 0, 0, 0, "k32_debug_prog_flow", "", "External breakpoint send/receive enables.", "", "", 0, 1, "", "", 0)
EXTERNAL_BREAK.EXTERNAL_BREAK_RECEIVE_EN                                         = c_bits(EXTERNAL_BREAK, 0, 0, 0x1, 1, "RW", "Enable receiving external breakpoints. When set, the EXTERNAL_BREAK_STATUS register will become set when an external breakpoint event occurs.")
EXTERNAL_BREAK.EXTERNAL_BREAK_SEND_EN                                            = c_bits(EXTERNAL_BREAK, 1, 1, 0x2, 1, "RW", "Enable sending external breakpoints.")
EXTERNAL_BREAK_STATUS                                                            = c_reg(0xfffffe58, 1, 1, 0, "RW", 1, 0, 1, 0, "k32_debug_prog_flow", "", "Status of external breakpoint logic (read only), if set this means the core has received an external breakpoint indication. Whether the core will actually stop depends on EXTERNAL_BREAK_RECEIVE_EN. Write 1 to this bit to clear the status, unstalling the core if it was stalled due to this.", "", "", 0, 1, "", "", 0)
EXTERNAL_BREAK_STATUS.EXTERNAL_BREAK_STATUS                                      = c_bits(EXTERNAL_BREAK_STATUS, 0, 0, 0x1, 1, "RW", "")
INTERPROC_BREAK                                                                  = c_reg(0xfffffe3c, 1, 1, 0, "RW", 2, 0, 0, 0, "k32_debug_prog_flow", "", "Interprocessor breakpoint send/receive enables.", "", "", 0, 1, "", "", 0)
INTERPROC_BREAK.INTERPROC_BREAK_RECEIVE_EN                                       = c_bits(INTERPROC_BREAK, 0, 0, 0x1, 1, "RW", "Enable receiving interprocessor breakpoints.")
INTERPROC_BREAK.INTERPROC_BREAK_SEND_EN                                          = c_bits(INTERPROC_BREAK, 1, 1, 0x2, 1, "RW", "Enable sending interprocessor breakpoints.")
PM_BREAK0_ADDR                                                                   = c_reg(0xfffffe10, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Sets the address (in bytes) of program breakpoint 0.  The breakpoint is enabled by the DEBUG_PM_BREAK0 control bit in the DEBUG register.", "", "", 0, 1, "", "", 0)
PM_BREAK0_ADDR.PM_BREAK0_ADDR                                                    = c_bits(PM_BREAK0_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK1_ADDR                                                                   = c_reg(0xfffffe14, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 1, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK1_ADDR.PM_BREAK1_ADDR                                                    = c_bits(PM_BREAK1_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK2_ADDR                                                                   = c_reg(0xfffffe18, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 2, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK2_ADDR.PM_BREAK2_ADDR                                                    = c_bits(PM_BREAK2_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK3_ADDR                                                                   = c_reg(0xfffffe1c, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 3, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK3_ADDR.PM_BREAK3_ADDR                                                    = c_bits(PM_BREAK3_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK4_ADDR                                                                   = c_reg(0xfffffe20, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 4, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK4_ADDR.PM_BREAK4_ADDR                                                    = c_bits(PM_BREAK4_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK5_ADDR                                                                   = c_reg(0xfffffe24, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 5, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK5_ADDR.PM_BREAK5_ADDR                                                    = c_bits(PM_BREAK5_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK6_ADDR                                                                   = c_reg(0xfffffe28, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 6, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK6_ADDR.PM_BREAK6_ADDR                                                    = c_bits(PM_BREAK6_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_BREAK7_ADDR                                                                   = c_reg(0xfffffe2c, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Program breakpoint 7, configured as for PM_BREAK0_ADDR.", "", "", 0, 1, "", "", 0)
PM_BREAK7_ADDR.PM_BREAK7_ADDR                                                    = c_bits(PM_BREAK7_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_PC                                                                       = c_reg(0xffffff00, 1, 1, 0, "RW", 32, 0, 1, 1, "k32_debug_prog_flow", "", "Reading this register returns the current Program Counter (PC) of Kalimba (as a byte address). Writing to this register will set Kalimba's PC so that execution will commence from that address when it is started.", "", "", 0, 1, "", "", 0)
REGFILE_PC.REGFILE_PC                                                            = c_bits(REGFILE_PC, 0, 31, 0xffffffff, 32, "RW", "")
STATUS                                                                           = c_reg(0xfffffe34, 1, 0, 0, "R", 17, 0, 0, 0, "k32_debug_prog_flow", "", "A status register for the debugger to find out the state of the Processor.", "", "", 0, 1, "", "", 0)
STATUS.STATUS_RUNNING                                                            = c_bits(STATUS, 0, 0, 0x1, 1, "R", "If set indicates that Kalimba is Runing.")
STATUS.STATUS_PM_BREAK                                                           = c_bits(STATUS, 1, 1, 0x2, 1, "R", "If set indicates that Kalimba has hit a Program Memory breakpoint: PM_BREAK0_ADDR to PM_BREAK7_ADDR.")
STATUS.STATUS_DM_BREAK0                                                          = c_bits(STATUS, 2, 2, 0x4, 1, "R", "If set indicates that Data Breakpoint 0 has been hit. See DM_BREAK0_START_ADDR and friends.")
STATUS.STATUS_DM_BREAK1                                                          = c_bits(STATUS, 3, 3, 0x8, 1, "R", "If set indicates that Data Breakpoint 1 has been hit. See DM_BREAK1_START_ADDR and friends.")
STATUS.STATUS_DUMMY                                                              = c_bits(STATUS, 4, 4, 0x10, 1, "R", "Unused bit (there for legacy purposes).")
STATUS.STATUS_PM_WAIT_IN                                                         = c_bits(STATUS, 5, 5, 0x20, 1, "R", "If set indicates that a WAIT signal is being input to Kalimba core on the PM bus.")
STATUS.STATUS_DM1_WAIT_IN                                                        = c_bits(STATUS, 6, 6, 0x40, 1, "R", "If set indicates that a WAIT signal is being input to Kalimba core on the DM1 bus.")
STATUS.STATUS_DM2_WAIT_IN                                                        = c_bits(STATUS, 7, 7, 0x80, 1, "R", "If set indicates that a WAIT signal is being input to Kalimba core on the DM2 bus.")
STATUS.STATUS_RETRYPMREAD                                                        = c_bits(STATUS, 8, 8, 0x100, 1, "R", "Low level debug information: Indicates state of RetryPmRead signal.")
STATUS.STATUS_DLYRUNNING                                                         = c_bits(STATUS, 9, 9, 0x200, 1, "R", "Low level debug information: Indicates state of DlyRunning signal.")
STATUS.STATUS_SINGSTEPCOMP                                                       = c_bits(STATUS, 10, 10, 0x400, 1, "R", "If set indicates that a single step operation has completed. See DEBUG_STEP bit in DEBUG register for more info.")
STATUS.STATUS_PROCESSING                                                         = c_bits(STATUS, 11, 11, 0x800, 1, "R", "Low level debug information: Indicates state of Processing signal.")
STATUS.STATUS_EXECUTING                                                          = c_bits(STATUS, 12, 12, 0x1000, 1, "R", "Low level debug information: Indicates state of Executing signal.")
STATUS.STATUS_STALLEDPM                                                          = c_bits(STATUS, 13, 13, 0x2000, 1, "R", "Low level debug information: Indicates state of StalledPM signal.")
STATUS.STATUS_EXCEPTION_BREAK                                                    = c_bits(STATUS, 14, 14, 0x4000, 1, "R", "If set indicates that an Exception Breakpoint has occured.  This can be cleared by clearing (and re-enabling) the EXCEPTION_EN register.")
STATUS.STATUS_EXTERNAL_BREAK                                                     = c_bits(STATUS, 15, 15, 0x8000, 1, "R", "If set indicates that external subsystem Breakpoint has occured.  This is the same as EXTERNAL_BREAK_STATUS. This can be cleared by writing to EXTERNAL_BREAK_STATUS.")
STATUS.STATUS_INTERPROC_BREAK                                                    = c_bits(STATUS, 16, 16, 0x10000, 1, "R", "If set indicates that interprocessor Breakpoint has occured.  This can be cleared by clearing the breakpoint on the source processor.")

# -- Kalimba 32-bit Register File Debug Control registers.  Note: All these registers are only accessable from SPI and T-Bus, not from Kalimba core itself. --

REGFILE_B0                                                                       = c_reg(0xffffffa4, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B0 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B0.REGFILE_B0                                                            = c_bits(REGFILE_B0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_B1                                                                       = c_reg(0xffffffa8, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B1 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B1.REGFILE_B1                                                            = c_bits(REGFILE_B1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_B4                                                                       = c_reg(0xffffffac, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B4 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B4.REGFILE_B4                                                            = c_bits(REGFILE_B4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_B5                                                                       = c_reg(0xffffffb0, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "B5 register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_B5.REGFILE_B5                                                            = c_bits(REGFILE_B5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_FP                                                                       = c_reg(0xffffffb4, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "FP register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_FP.REGFILE_FP                                                            = c_bits(REGFILE_FP, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I0                                                                       = c_reg(0xffffff4c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I0 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I0.REGFILE_I0                                                            = c_bits(REGFILE_I0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I1                                                                       = c_reg(0xffffff50, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I1 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I1.REGFILE_I1                                                            = c_bits(REGFILE_I1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I2                                                                       = c_reg(0xffffff54, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I2 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I2.REGFILE_I2                                                            = c_bits(REGFILE_I2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I3                                                                       = c_reg(0xffffff58, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I3 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I3.REGFILE_I3                                                            = c_bits(REGFILE_I3, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I4                                                                       = c_reg(0xffffff5c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I4 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I4.REGFILE_I4                                                            = c_bits(REGFILE_I4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I5                                                                       = c_reg(0xffffff60, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I5 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I5.REGFILE_I5                                                            = c_bits(REGFILE_I5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I6                                                                       = c_reg(0xffffff64, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I6 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I6.REGFILE_I6                                                            = c_bits(REGFILE_I6, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_I7                                                                       = c_reg(0xffffff68, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "I7 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_I7.REGFILE_I7                                                            = c_bits(REGFILE_I7, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L0                                                                       = c_reg(0xffffff7c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L0 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L0.REGFILE_L0                                                            = c_bits(REGFILE_L0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L1                                                                       = c_reg(0xffffff80, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L1 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L1.REGFILE_L1                                                            = c_bits(REGFILE_L1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L4                                                                       = c_reg(0xffffff84, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L4 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L4.REGFILE_L4                                                            = c_bits(REGFILE_L4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_L5                                                                       = c_reg(0xffffff88, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "L5 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_L5.REGFILE_L5                                                            = c_bits(REGFILE_L5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M0                                                                       = c_reg(0xffffff6c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M0 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M0.REGFILE_M0                                                            = c_bits(REGFILE_M0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M1                                                                       = c_reg(0xffffff70, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M1 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M1.REGFILE_M1                                                            = c_bits(REGFILE_M1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M2                                                                       = c_reg(0xffffff74, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M2 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M2.REGFILE_M2                                                            = c_bits(REGFILE_M2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_M3                                                                       = c_reg(0xffffff78, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "M3 register in Bank 2.", "", "", 0, 1, "", "", 0)
REGFILE_M3.REGFILE_M3                                                            = c_bits(REGFILE_M3, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_NUM_CORE_STALLS                                                          = c_reg(0xffffff94, 1, 0, 0, "R", 32, 0, 0, 0, "k32_debug_regfile", "", "A debugging register than reports the number of processor core stalls that have occured (this covers instruction decoding related stalls only and does not include stalls due to DM and PM memory bus waits or delays within the prefetch logic).  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
REGFILE_NUM_CORE_STALLS.REGFILE_NUM_CORE_STALLS                                  = c_bits(REGFILE_NUM_CORE_STALLS, 0, 31, 0xffffffff, 32, "R", "")
REGFILE_NUM_INSTRS                                                               = c_reg(0xffffff90, 1, 0, 0, "R", 32, 0, 0, 0, "k32_debug_regfile", "", "A debugging register than reports the number of processor instructions that have been executed.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
REGFILE_NUM_INSTRS.REGFILE_NUM_INSTRS                                            = c_bits(REGFILE_NUM_INSTRS, 0, 31, 0xffffffff, 32, "R", "")
REGFILE_NUM_RUNCLKS                                                              = c_reg(0xffffff8c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_debug_regfile", "", "A debugging register than reports the number of processor clock cycles that have occured whilst running.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will just read as zero if the DBG_COUNTERS_EN register has not been enabled.", "", "", 0, 1, "", "", 0)
REGFILE_NUM_RUNCLKS.REGFILE_NUM_RUNCLKS                                          = c_bits(REGFILE_NUM_RUNCLKS, 0, 31, 0xffffffff, 32, "R", "")
REGFILE_R0                                                                       = c_reg(0xffffff14, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r0 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R0.REGFILE_R0                                                            = c_bits(REGFILE_R0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R1                                                                       = c_reg(0xffffff18, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r1 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R1.REGFILE_R1                                                            = c_bits(REGFILE_R1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R10                                                                      = c_reg(0xffffff3c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r10 register in Bank 1", "", "", 0, 1, "", "", 0)
REGFILE_R10.REGFILE_R10                                                          = c_bits(REGFILE_R10, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R2                                                                       = c_reg(0xffffff1c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r2 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R2.REGFILE_R2                                                            = c_bits(REGFILE_R2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R3                                                                       = c_reg(0xffffff20, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r3 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R3.REGFILE_R3                                                            = c_bits(REGFILE_R3, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R4                                                                       = c_reg(0xffffff24, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r4 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R4.REGFILE_R4                                                            = c_bits(REGFILE_R4, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R5                                                                       = c_reg(0xffffff28, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r5 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R5.REGFILE_R5                                                            = c_bits(REGFILE_R5, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R6                                                                       = c_reg(0xffffff2c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r6 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R6.REGFILE_R6                                                            = c_bits(REGFILE_R6, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R7                                                                       = c_reg(0xffffff30, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r7 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R7.REGFILE_R7                                                            = c_bits(REGFILE_R7, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R8                                                                       = c_reg(0xffffff34, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r8 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R8.REGFILE_R8                                                            = c_bits(REGFILE_R8, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_R9                                                                       = c_reg(0xffffff38, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "r9 register in Bank 1.", "", "", 0, 1, "", "", 0)
REGFILE_R9.REGFILE_R9                                                            = c_bits(REGFILE_R9, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RFLAGS                                                                   = c_reg(0xffffff44, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "rFlags register in Bank 1", "", "", 0, 1, "", "", 0)
REGFILE_RFLAGS.N_FLAG                                                            = c_bits(REGFILE_RFLAGS, 0, 0, 0x1, 1, "RW", "Negative flag (N).  This is set if the result of the instruction is negative, i.e. if the most significant bit is set, and cleared otherwise.")
REGFILE_RFLAGS.Z_FLAG                                                            = c_bits(REGFILE_RFLAGS, 1, 1, 0x2, 1, "RW", "Zero flag (Z).  This is set if the result of the instruction is zero, and cleared otherwise.")
REGFILE_RFLAGS.C_FLAG                                                            = c_bits(REGFILE_RFLAGS, 2, 2, 0x4, 1, "RW", "Carry flag (C).  The state of the carry flag is: For an addition, C is set if the addition produced a carry, i.e. an unsigned overflow, and is cleared otherwise; For a subtraction, C is cleared if the subtraction produces a borrow, i.e. an unsigned underflow, and is set otherwise.  For other operations (including multiply accumulate), C is cleared.")
REGFILE_RFLAGS.V_FLAG                                                            = c_bits(REGFILE_RFLAGS, 3, 3, 0x8, 1, "RW", "oVerflow flag (V).  The state of the overflow flag is: For addition, subtraction, arithmetic shifts, integer multiplies and multiply accumulates, V is set if signed overflow occurred, regarding the operands and result as 2's complement signed integers, and is cleared otherwise; The setting/clearing of the V flag for the rMAC and/or rMACB registers occurs if there is overflow past the 72nd bit, whereas for the 32-bit registers it is if overflow occurs past the 32nd bit; V cleared for other operations.")
REGFILE_RFLAGS.UD_FLAG                                                           = c_bits(REGFILE_RFLAGS, 4, 4, 0x10, 1, "RW", "User Definable flag (UD).  A special USERDEF condition code is TRUE if this flag is set and FALSE if this flag is clear. Use it in code sections to improve speed and code clarity where a particular instruction needs to be executed conditionally.")
REGFILE_RFLAGS.SV_FLAG                                                           = c_bits(REGFILE_RFLAGS, 5, 5, 0x20, 1, "RW", "Sticky oVerflow flag (SV).  Set whenever V is set but can only be cleared by software explicitly writing to the rFlags register.")
REGFILE_RFLAGS.BR_FLAG                                                           = c_bits(REGFILE_RFLAGS, 6, 6, 0x40, 1, "RW", "Bit Reverse flag (BR).  If set, the output of AG1 (index registers I0 to I3) is bit-reversed before being driven to the address bus. Here bitreversing applies to the least significant 31 bits. The most significant bit selects the data memory used so it stays in place.")
REGFILE_RFLAGS.UM_FLAG                                                           = c_bits(REGFILE_RFLAGS, 7, 7, 0x80, 1, "RW", "User Mode flag (UM).  If set, interrupts are serviced. On entry to the interrupt service routine (default PC address 0x0002), this flag is cleared so no further interrupts are serviced unless the flag is manually set, for example to support interrupt priority. Execution of a rti instruction sets this flag to the value of INT_UM_FLAG (normally set unless altered in software).")
REGFILE_RFLAGS.INT_N_FLAG                                                        = c_bits(REGFILE_RFLAGS, 8, 8, 0x100, 1, "RW", "Just before entering the interrupt service routine, each element of rFlags is copied into its interrupt duplicate.  E.g. UM_FLAG is copied into INT_UM_FLAG. With the exception of the UM_FLAG, all bits remain unchanged. UM_FLAG is cleared and remains cleared unless software enables it. When returning from interrupt, using the rti instruction, the interrupt bits are copied back, over-writing the non-interrupt values.")
REGFILE_RFLAGS.INT_Z_FLAG                                                        = c_bits(REGFILE_RFLAGS, 9, 9, 0x200, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_C_FLAG                                                        = c_bits(REGFILE_RFLAGS, 10, 10, 0x400, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_V_FLAG                                                        = c_bits(REGFILE_RFLAGS, 11, 11, 0x800, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_UD_FLAG                                                       = c_bits(REGFILE_RFLAGS, 12, 12, 0x1000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_SV_FLAG                                                       = c_bits(REGFILE_RFLAGS, 13, 13, 0x2000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_BR_FLAG                                                       = c_bits(REGFILE_RFLAGS, 14, 14, 0x4000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.INT_UM_FLAG                                                       = c_bits(REGFILE_RFLAGS, 15, 15, 0x8000, 1, "RW", "see above (INT_N_FLAG)")
REGFILE_RFLAGS.UNUSED                                                            = c_bits(REGFILE_RFLAGS, 16, 31, 0xffff0000, 16, "RW", "Ununsed field in rFLAGS register")
REGFILE_RLINK                                                                    = c_reg(0xffffff40, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "rLink register in Bank 1", "", "", 0, 1, "", "", 0)
REGFILE_RLINK.REGFILE_RLINK                                                      = c_bits(REGFILE_RLINK, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC0                                                                    = c_reg(0xffffff0c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "LS 32-bits (bits 31:0) of the full 72-bit rMAC register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC0.REGFILE_RMAC0                                                      = c_bits(REGFILE_RMAC0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC1                                                                    = c_reg(0xffffff08, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "Middle 32-bits (bits 63:32) of the full 72-bit rMAC register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC1.REGFILE_RMAC1                                                      = c_bits(REGFILE_RMAC1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC2                                                                    = c_reg(0xffffff04, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "MS 8-bits (bits 71:64) of the full 72-bit rMAC register.  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC2.REGFILE_RMAC2                                                      = c_bits(REGFILE_RMAC2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMAC24                                                                   = c_reg(0xffffff10, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "A rounded and saturated 32-bit version of the rMAC register.  This is a bank 1 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMAC24.REGFILE_RMAC24                                                    = c_bits(REGFILE_RMAC24, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB0                                                                   = c_reg(0xffffffa0, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "LS 32-bits (bits 31:0) of the full 72-bit rMACB register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB0.REGFILE_RMACB0                                                    = c_bits(REGFILE_RMACB0, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB1                                                                   = c_reg(0xffffff9c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "Middle 32-bits (bits 63:32) of the full 72-bit rMACB register  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB1.REGFILE_RMACB1                                                    = c_bits(REGFILE_RMACB1, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB2                                                                   = c_reg(0xffffff98, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "MS 8-bits (bits 71:64) of the full 72-bit rMACB register.  This is a bank 3 register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB2.REGFILE_RMACB2                                                    = c_bits(REGFILE_RMACB2, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_RMACB24                                                                  = c_reg(0xffffff48, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "A rounded and saturated 32-bit version of the rMACB register.", "", "", 0, 1, "", "", 0)
REGFILE_RMACB24.REGFILE_RMACB24                                                  = c_bits(REGFILE_RMACB24, 0, 31, 0xffffffff, 32, "RW", "")
REGFILE_SP                                                                       = c_reg(0xffffffb8, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_debug_regfile", "", "SP register in Bank 3.", "", "", 0, 1, "", "", 0)
REGFILE_SP.REGFILE_SP                                                            = c_bits(REGFILE_SP, 0, 31, 0xffffffff, 32, "RW", "")

# -- Kalimba 32-bit DoLoop Cache Control registers. --

DOLOOP_CACHE_CONFIG                                                              = c_reg(0xffff8200, 1, 1, 0, "RW", 2, 3, 0, 0, "k32_doloop_cache", "", "Configures the DoLoop cache for Kalimba.", "", "", 0, 1, "", "", 0)
DOLOOP_CACHE_CONFIG.DOLOOP_CACHE_CONFIG_DOLOOP_EN                                = c_bits(DOLOOP_CACHE_CONFIG, 0, 0, 0x1, 1, "RW", "Enables the flip-flop based caching of the first 32 instructions of do loops.  This should lower power consumption for programs that make heavy use of do loops.")
DOLOOP_CACHE_CONFIG.DOLOOP_CACHE_CONFIG_COUNTERS_EN                              = c_bits(DOLOOP_CACHE_CONFIG, 1, 1, 0x2, 1, "RW", "Enables the cache performance counters (HIT and MISS counts) for use during debugging.")
DOLOOP_CACHE_FILL_COUNT                                                          = c_reg(0xffff8208, 1, 0, 0, "R", 32, 0, 0, 0, "k32_doloop_cache", "", "A debugging register that counts the number of DoLoop cache instruction fills.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will always read as zero if the DOLOOP_CACHE_CONFIG_COUNTERS_EN bit of DOLOOP_CACHE_CONFIG has not been enabled.", "", "", 0, 1, "", "", 0)
DOLOOP_CACHE_FILL_COUNT.DOLOOP_CACHE_FILL_COUNT                                  = c_bits(DOLOOP_CACHE_FILL_COUNT, 0, 31, 0xffffffff, 32, "R", "")
DOLOOP_CACHE_HIT_COUNT                                                           = c_reg(0xffff8204, 1, 0, 0, "R", 32, 0, 0, 0, "k32_doloop_cache", "", "A debugging register that counts the number of DoLoop cache instruction hits.  This register cannot be reset or written to, it just wraps around on overflow.  Note that this register will always read as zero if the DOLOOP_CACHE_CONFIG_COUNTERS_EN bit of DOLOOP_CACHE_CONFIG has not been enabled.", "", "", 0, 1, "", "", 0)
DOLOOP_CACHE_HIT_COUNT.DOLOOP_CACHE_HIT_COUNT                                    = c_bits(DOLOOP_CACHE_HIT_COUNT, 0, 31, 0xffffffff, 32, "R", "")

# -- Kalimba 32-bit Interrupt Controller Control registers --

INT_ACK                                                                          = c_reg(0xffff8114, 1, 1, 0, "RW", 1, 0, 1, 0, "k32_interrupt", "", "Writing to this register acknowledges an interrupt request (writing a 0 removes the interrrupt source from the request list; writing a 1 will leave the interrupt source in the request list.  Most software will hence want to write a 0). It de-asserts the IRQ line to the Kalimba DSP core, and initiates the search for a new interrupt.  Note that until the IntActive signal is deasserted (see INT_LOAD_INFO_INT_ACTIVE) only higher priority interrupts will cause an interrupt to Kalimba.", "", "", 0, 1, "", "", 0)
INT_ACK.INT_ACK                                                                  = c_bits(INT_ACK, 0, 0, 0x1, 1, "RW", "")
INT_ADDR                                                                         = c_reg(0xffff8108, 1, 1, 0, "RW", 32, 8, 0, 0, "k32_interrupt", "", "Sets the address of interrupt handler service routine.", "", "", 0, 1, "", "", 0)
INT_ADDR.INT_ADDR                                                                = c_bits(INT_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
INT_BLOCK_PRIORITY                                                               = c_reg(0xffff813c, 1, 1, 0, "RW", 2, 0, 0, 0, "k32_interrupt", "", "Block interrupts up to, but not including, this priority level. When zero, this register has no effect.", "", "", 0, 1, "", "", 0)
INT_BLOCK_PRIORITY.INT_BLOCK_PRIORITY                                            = c_bits(INT_BLOCK_PRIORITY, 0, 1, 0x3, 2, "RW", "")
INT_CLK_SWITCH_EN                                                                = c_reg(0xffff810c, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_interrupt", "", "Enables switching of the Kalimba clock to a special interrupt clock rate. The interrupt clock rate is specified by INT_CLOCK_DIVIDE_RATE. This clock rate is used from the moment an enabled interrupt event line goes high until the INT_ACK register is written to by the ISR.", "", "", 0, 1, "", "", 0)
INT_CLK_SWITCH_EN.INT_CLK_SWITCH_EN                                              = c_bits(INT_CLK_SWITCH_EN, 0, 0, 0x1, 1, "RW", "")
INT_CLOCK_DIVIDE_RATE                                                            = c_reg(0xffff8110, 1, 1, 0, "RW", 2, 1, 0, 0, "k32_interrupt", "", "Configures the clock frequency used by Kalimba during interrupt processing (See description under INT_CLK_SWITCH_EN).", "", "", 0, 1, "", "", 0)
INT_CLOCK_DIVIDE_RATE.K32_INTERRUPT__CLOCK_STOPPED                               = c_enum(INT_CLOCK_DIVIDE_RATE, 0, "Kalimba clock stopped.", "INT_CLOCK_DIVIDE_RATE")
INT_CLOCK_DIVIDE_RATE.K32_INTERRUPT__CLOCK_RATE_MAX                              = c_enum(INT_CLOCK_DIVIDE_RATE, 1, "Kalimba clocked at max. clock frequency.", "INT_CLOCK_DIVIDE_RATE")
INT_CLOCK_DIVIDE_RATE.K32_INTERRUPT__CLOCK_RATE_HALF                             = c_enum(INT_CLOCK_DIVIDE_RATE, 2, "Kalimba clocked at half of max. clock frequency.", "INT_CLOCK_DIVIDE_RATE")
INT_CLOCK_DIVIDE_RATE.K32_INTERRUPT__CLOCK_RATE_RESERVED                         = c_enum(INT_CLOCK_DIVIDE_RATE, 3, "Reserved. Same as CLOCK_STOPPED.", "INT_CLOCK_DIVIDE_RATE")
INT_GBL_ENABLE                                                                   = c_reg(0xffff8100, 1, 1, 0, "RW", 1, 0, 1, 0, "k32_interrupt", "", "Enables the interrupt controller. Resets interrupt controller state when set to 0.  Disabling will take a few (< 5) instruction cycles to take effect, depending on various factors.  When disabled all interrupt sources will be lost and no interrupts will fire.", "", "", 0, 1, "", "", 0)
INT_GBL_ENABLE.INT_GBL_ENABLE                                                    = c_bits(INT_GBL_ENABLE, 0, 0, 0x1, 1, "RW", "")
INT_LOAD_INFO                                                                    = c_reg(0xffff8128, 1, 1, 0, "RW", 20, 0, 1, 0, "k32_interrupt", "", "For nested interrupts it restores information about the previous lower priority interrupt. Importantly even with non-nested interrupt support this register must be written to clear the IntActive signal (INT_LOAD_INFO_INT_ACTIVE) so that further interrupts of an equal or lower priority than the current interrupt can be serviced.", "", "", 0, 1, "", "", 0)
INT_LOAD_INFO.INT_LOAD_INFO_PRIORITY                                             = c_bits(INT_LOAD_INFO, 0, 1, 0x3, 2, "RW", "Interrupt priority value to restore.")
INT_LOAD_INFO.INT_LOAD_INFO_SOURCE                                               = c_bits(INT_LOAD_INFO, 2, 6, 0x7c, 5, "RW", "Interrupt source number (0-31) to restore.")
INT_LOAD_INFO.INT_LOAD_INFO_UNUSED7                                              = c_bits(INT_LOAD_INFO, 7, 9, 0x380, 3, "RW", "Unused, reads as 0. Bits to maintain field locations.")
INT_LOAD_INFO.INT_LOAD_INFO_INT_ACTIVE                                           = c_bits(INT_LOAD_INFO, 10, 10, 0x400, 1, "RW", "Interrupt active (IntActive) signal state to restore.")
INT_LOAD_INFO.INT_LOAD_INFO_REQUEST                                              = c_bits(INT_LOAD_INFO, 11, 15, 0xf800, 5, "RW", "Interrupt request number (0-31) to optionally clear.")
INT_LOAD_INFO.INT_LOAD_INFO_UNUSED16                                             = c_bits(INT_LOAD_INFO, 16, 18, 0x70000, 3, "RW", "Unused, reads as 0. Bits to maintain field locations.")
INT_LOAD_INFO.INT_LOAD_INFO_DONT_CLEAR                                           = c_bits(INT_LOAD_INFO, 19, 19, 0x80000, 1, "RW", "When set to 0, clears the interrupt request specified in INT_LOAD_INFO_REQUEST. This is useful if software would like to clear registered interrupts before the interrupt control schedules them to be handled. For example, if an error condition is configured to trigger a high priority interrupt, it might make sense to clear various lower priority interrupts before attempting some kind of software reset.")
INT_PRIORITY                                                                     = c_reg(0xffff8124, 1, 1, 0, "RW", 2, 0, 1, 0, "k32_interrupt", "", "Priority for interrupt selected by INT_SELECT. 0 is the lowest priority.", "", "", 0, 1, "", "", 0)
INT_PRIORITY.INT_PRIORITY                                                        = c_bits(INT_PRIORITY, 0, 1, 0x3, 2, "RW", "")
INT_SAVE_INFO                                                                    = c_reg(0xffff812c, 1, 0, 0, "R", 22, 0, 0, 0, "k32_interrupt", "", "Allows saving of information about the interrupt controller state before the current interrupt fired. See INT_LOAD_INFO for then re-loading the interrupt controllers state. This allows nested interrupts to be supported.", "", "", 0, 1, "", "", 0)
INT_SAVE_INFO.INT_SAVE_INFO_PRIORITY                                             = c_bits(INT_SAVE_INFO, 0, 1, 0x3, 2, "R", "Previous (before current interrupt fired) Interrupt priority value to save.")
INT_SAVE_INFO.INT_SAVE_INFO_SOURCE                                               = c_bits(INT_SAVE_INFO, 2, 6, 0x7c, 5, "R", "Previous (before current interrupt fired) Interrupt source number (0-31) to save.")
INT_SAVE_INFO.INT_SAVE_INFO_UNUSED7                                              = c_bits(INT_SAVE_INFO, 7, 9, 0x380, 3, "R", "Unused, reads as 0. Bits to maintain field locations.")
INT_SAVE_INFO.INT_SAVE_INFO_ACTIVE                                               = c_bits(INT_SAVE_INFO, 10, 10, 0x400, 1, "R", "Previous (before current interrupt fired) Interrupt active (IntActive) signal state to save.")
INT_SAVE_INFO.INT_SAVE_INFO_SOURCE_NEW                                           = c_bits(INT_SAVE_INFO, 11, 15, 0xf800, 5, "R", "The new interrupt source at the time that the above values were saved.")
INT_SAVE_INFO.INT_SAVE_INFO_UNUSED16                                             = c_bits(INT_SAVE_INFO, 16, 18, 0x70000, 3, "R", "Unused, reads as 0. Bits to maintain field locations.")
INT_SAVE_INFO.INT_SAVE_INFO_UNUSED19                                             = c_bits(INT_SAVE_INFO, 19, 19, 0x80000, 1, "R", "Unused, reads as 0. This bit is here to keep the layout of this register as close as possible to that of INT_LOAD_INFO.")
INT_SAVE_INFO.INT_SAVE_INFO_PRIORITY_NEW                                         = c_bits(INT_SAVE_INFO, 20, 21, 0x300000, 2, "R", "Priority for interrupt whose index is in field INT_SAVE_INFO_SOURCE_NEW. 0 is the lowest priority.")
INT_SELECT                                                                       = c_reg(0xffff8120, 1, 1, 0, "RW", 5, 0, 0, 0, "k32_interrupt", "", "Banked interrupt select.", "", "", 0, 1, "", "", 0)
INT_SELECT.INT_SELECT                                                            = c_bits(INT_SELECT, 0, 4, 0x1f, 5, "RW", "")
INT_SOURCE                                                                       = c_reg(0xffff8130, 1, 0, 0, "R", 5, 0, 0, 0, "k32_interrupt", "", "Contains current interrupt source index. Will be one of the values in INT_SOURCE_ENUM (see doc for register INT_STATUS).", "", "", 0, 1, "", "", 0)
INT_SOURCE.INT_SOURCE                                                            = c_bits(INT_SOURCE, 0, 4, 0x1f, 5, "R", "")
INT_SOURCES_EN                                                                   = c_reg(0xffff8138, 1, 1, 0, "RW", 32, 0, 1, 0, "k32_interrupt", "", "Interrupt source enables.", "", "", 0, 1, "", "", 0)
INT_SOURCES_EN.INT_SOURCE_TBUS_INT_ADPTR_EVENT                                   = c_bits(INT_SOURCES_EN, 5, 5, 0x20, 1, "RW", "TBus interrupt adapter event 1.")
INT_SOURCES_EN.INT_SOURCE_TBUS_MSG_ADPTR_EVENT                                   = c_bits(INT_SOURCES_EN, 6, 6, 0x40, 1, "RW", "TBus message adapter event.")
INT_SOURCES_EN.INT_SOURCE_OUTBOUND_ACCESS_ERROR_EVENT                            = c_bits(INT_SOURCES_EN, 7, 7, 0x80, 1, "RW", "Access via remote subsystem accessor window failed.")
INT_SOURCES_EN.INT_SOURCE_TIME_UPDATE_EVENT                                      = c_bits(INT_SOURCES_EN, 8, 8, 0x100, 1, "RW", "Subsystem time updated by time sync transaction.")
INT_SOURCES_EN.INT_SOURCE_VML_EVENT                                              = c_bits(INT_SOURCES_EN, 11, 11, 0x800, 1, "RW", "Interrupt from VML.")
INT_SOURCES_EN.INT_SOURCE_DMAC_QUEUE0_EVENT                                      = c_bits(INT_SOURCES_EN, 12, 12, 0x1000, 1, "RW", "Interrupt from DMA Controller's Queue 0")
INT_SOURCES_EN.INT_SOURCE_DMAC_QUEUE1_EVENT                                      = c_bits(INT_SOURCES_EN, 13, 13, 0x2000, 1, "RW", "Interrupt from DMA Controller's Queue 1")
INT_SOURCES_EN.INT_SOURCE_SQIF_ARBITER_EVENT                                     = c_bits(INT_SOURCES_EN, 15, 15, 0x8000, 1, "RW", "Interrupt from SQIF datapath arbiter.")
INT_SOURCES_EN.INT_SOURCE_SQIF_ARBITER1_EVENT                                    = c_bits(INT_SOURCES_EN, 16, 16, 0x10000, 1, "RW", "Interrupt from SQIF datapath arbiter 1.")
INT_SOURCES_EN.INT_SOURCE_CPU1_ACCESS_FAULT_EVENT                                = c_bits(INT_SOURCES_EN, 18, 18, 0x40000, 1, "RW", "Interrupt from CPU1 access restriction logic.")
INT_SOURCES_EN.INT_SOURCE_INTERPROC_EVENT_1                                      = c_bits(INT_SOURCES_EN, 21, 21, 0x200000, 1, "RW", "Interprocessor event from P0.")
INT_SOURCES_EN.INT_SOURCE_INTERPROC_EVENT_2                                      = c_bits(INT_SOURCES_EN, 22, 22, 0x400000, 1, "RW", "Interprocessor event from P1.")
INT_SOURCES_EN.INT_SOURCE_PIO_INT_EVENT_1                                        = c_bits(INT_SOURCES_EN, 23, 23, 0x800000, 1, "RW", "Interrupt from PIO edge detect 1")
INT_SOURCES_EN.INT_SOURCE_PIO_INT_EVENT_2                                        = c_bits(INT_SOURCES_EN, 24, 24, 0x1000000, 1, "RW", "Interrupt from PIO edge detect 2")
INT_SOURCES_EN.INT_SOURCE_PIO_TIMER_EVENT_3                                      = c_bits(INT_SOURCES_EN, 25, 25, 0x2000000, 1, "RW", "Interrupt from PIO timer 3")
INT_SOURCES_EN.INT_SOURCE_CPU1_EXCEPTION                                         = c_bits(INT_SOURCES_EN, 26, 26, 0x4000000, 1, "RW", "An exception has occurred on CPU1. This interrupt is not attached to CPU1.")
INT_SOURCES_EN.INT_SOURCE_LAST                                                   = c_bits(INT_SOURCES_EN, 26, 26, 0x4000000, 1, "RW", "Same as the last interrupt source.")
INT_SOURCES_EN.INT_SOURCE_SDIO_HOST_INTERRUPT_EVENT                              = c_bits(INT_SOURCES_EN, 19, 19, 0x80000, 1, "RW", "Interrupt from sdio host module.")
INT_SOURCES_EN.INT_SOURCE_SDIO_HOST_WAKEUP_EVENT                                 = c_bits(INT_SOURCES_EN, 20, 20, 0x100000, 1, "RW", "Wakeup from sdio host module.")
INT_SOURCES_EN.INT_SOURCE_TIMER1                                                 = c_bits(INT_SOURCES_EN, 0, 0, 0x1, 1, "RW", "Timer 1 trigger event.")
INT_SOURCES_EN.INT_SOURCE_TIMER2                                                 = c_bits(INT_SOURCES_EN, 1, 1, 0x2, 1, "RW", "Timer 2 trigger event.")
INT_SOURCES_EN.INT_SOURCE_SW_ERROR                                               = c_bits(INT_SOURCES_EN, 2, 2, 0x4, 1, "RW", "Software error event (either stack overflow or a memory exception (see STACK_OVERFLOW_PC and EXCEPTION_TYPE).")
INT_SOURCES_EN.INT_SOURCE_SW0                                                    = c_bits(INT_SOURCES_EN, 3, 3, 0x8, 1, "RW", "Software event 0.")
INT_SOURCES_EN.INT_SOURCE_SW1                                                    = c_bits(INT_SOURCES_EN, 4, 4, 0x10, 1, "RW", "Software event 1.")
INT_STATUS                                                                       = c_reg(0xffff8134, 1, 0, 0, "R", 32, 0, 0, 0, "k32_interrupt", "", "Status of interrupt register. Interrupt bit positions as defined by INT_SOURCE_ENUM.", "", "", 0, 1, "", "", 0)
INT_STATUS.INT_SOURCE_TBUS_INT_ADPTR_EVENT                                       = c_bits(INT_STATUS, 5, 5, 0x20, 1, "R", "TBus interrupt adapter event 1.")
INT_STATUS.INT_SOURCE_TBUS_MSG_ADPTR_EVENT                                       = c_bits(INT_STATUS, 6, 6, 0x40, 1, "R", "TBus message adapter event.")
INT_STATUS.INT_SOURCE_OUTBOUND_ACCESS_ERROR_EVENT                                = c_bits(INT_STATUS, 7, 7, 0x80, 1, "R", "Access via remote subsystem accessor window failed.")
INT_STATUS.INT_SOURCE_TIME_UPDATE_EVENT                                          = c_bits(INT_STATUS, 8, 8, 0x100, 1, "R", "Subsystem time updated by time sync transaction.")
INT_STATUS.INT_SOURCE_VML_EVENT                                                  = c_bits(INT_STATUS, 11, 11, 0x800, 1, "R", "Interrupt from VML.")
INT_STATUS.INT_SOURCE_DMAC_QUEUE0_EVENT                                          = c_bits(INT_STATUS, 12, 12, 0x1000, 1, "R", "Interrupt from DMA Controller's Queue 0")
INT_STATUS.INT_SOURCE_DMAC_QUEUE1_EVENT                                          = c_bits(INT_STATUS, 13, 13, 0x2000, 1, "R", "Interrupt from DMA Controller's Queue 1")
INT_STATUS.INT_SOURCE_SQIF_ARBITER_EVENT                                         = c_bits(INT_STATUS, 15, 15, 0x8000, 1, "R", "Interrupt from SQIF datapath arbiter.")
INT_STATUS.INT_SOURCE_SQIF_ARBITER1_EVENT                                        = c_bits(INT_STATUS, 16, 16, 0x10000, 1, "R", "Interrupt from SQIF datapath arbiter 1.")
INT_STATUS.INT_SOURCE_CPU1_ACCESS_FAULT_EVENT                                    = c_bits(INT_STATUS, 18, 18, 0x40000, 1, "R", "Interrupt from CPU1 access restriction logic.")
INT_STATUS.INT_SOURCE_INTERPROC_EVENT_1                                          = c_bits(INT_STATUS, 21, 21, 0x200000, 1, "R", "Interprocessor event from P0.")
INT_STATUS.INT_SOURCE_INTERPROC_EVENT_2                                          = c_bits(INT_STATUS, 22, 22, 0x400000, 1, "R", "Interprocessor event from P1.")
INT_STATUS.INT_SOURCE_PIO_INT_EVENT_1                                            = c_bits(INT_STATUS, 23, 23, 0x800000, 1, "R", "Interrupt from PIO edge detect 1")
INT_STATUS.INT_SOURCE_PIO_INT_EVENT_2                                            = c_bits(INT_STATUS, 24, 24, 0x1000000, 1, "R", "Interrupt from PIO edge detect 2")
INT_STATUS.INT_SOURCE_PIO_TIMER_EVENT_3                                          = c_bits(INT_STATUS, 25, 25, 0x2000000, 1, "R", "Interrupt from PIO timer 3")
INT_STATUS.INT_SOURCE_CPU1_EXCEPTION                                             = c_bits(INT_STATUS, 26, 26, 0x4000000, 1, "R", "An exception has occurred on CPU1. This interrupt is not attached to CPU1.")
INT_STATUS.INT_SOURCE_LAST                                                       = c_bits(INT_STATUS, 26, 26, 0x4000000, 1, "R", "Same as the last interrupt source.")
INT_STATUS.INT_SOURCE_SDIO_HOST_INTERRUPT_EVENT                                  = c_bits(INT_STATUS, 19, 19, 0x80000, 1, "R", "Interrupt from sdio host module.")
INT_STATUS.INT_SOURCE_SDIO_HOST_WAKEUP_EVENT                                     = c_bits(INT_STATUS, 20, 20, 0x100000, 1, "R", "Wakeup from sdio host module.")
INT_STATUS.INT_SOURCE_TIMER1                                                     = c_bits(INT_STATUS, 0, 0, 0x1, 1, "R", "Timer 1 trigger event.")
INT_STATUS.INT_SOURCE_TIMER2                                                     = c_bits(INT_STATUS, 1, 1, 0x2, 1, "R", "Timer 2 trigger event.")
INT_STATUS.INT_SOURCE_SW_ERROR                                                   = c_bits(INT_STATUS, 2, 2, 0x4, 1, "R", "Software error event (either stack overflow or a memory exception (see STACK_OVERFLOW_PC and EXCEPTION_TYPE).")
INT_STATUS.INT_SOURCE_SW0                                                        = c_bits(INT_STATUS, 3, 3, 0x8, 1, "R", "Software event 0.")
INT_STATUS.INT_SOURCE_SW1                                                        = c_bits(INT_STATUS, 4, 4, 0x10, 1, "R", "Software event 1.")
INT_SW0_EVENT                                                                    = c_reg(0xffff8118, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_interrupt", "", "Writing a 1 raises the \"Software Event 0\" line to cause an interrupt request on Kalimba. Writing a 0 lowers the same request signal.", "", "", 0, 1, "", "", 0)
INT_SW0_EVENT.INT_SW0_EVENT                                                      = c_bits(INT_SW0_EVENT, 0, 0, 0x1, 1, "RW", "")
INT_SW1_EVENT                                                                    = c_reg(0xffff811c, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_interrupt", "", "Writing a 1 raises the \"Software Event 1\" line to cause an interrupt request on Kalimba. Writing a 0 lowers the same request signal.", "", "", 0, 1, "", "", 0)
INT_SW1_EVENT.INT_SW1_EVENT                                                      = c_bits(INT_SW1_EVENT, 0, 0, 0x1, 1, "RW", "")
INT_UNBLOCK                                                                      = c_reg(0xffff8104, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_interrupt", "", "When set to 1 enables searching for an interrupt source. Kalimba will not receive an interrupt when this register is set to 0, but active interrupt sources will be latched and an interrupt will fire upon this register being re-enabled.  Clearing and setting of this register will take a few (< 5) instruction cycles to take effect.", "", "", 0, 1, "", "", 0)
INT_UNBLOCK.INT_UNBLOCK                                                          = c_bits(INT_UNBLOCK, 0, 0, 0x1, 1, "RW", "")
INT_SOURCE_TBUS_INT_ADPTR_EVENT                                                  = c_enum(None, 5, "TBus interrupt adapter event 1.", "INT_SOURCE_ENUM")
INT_SOURCE_TBUS_MSG_ADPTR_EVENT                                                  = c_enum(None, 6, "TBus message adapter event.", "INT_SOURCE_ENUM")
INT_SOURCE_OUTBOUND_ACCESS_ERROR_EVENT                                           = c_enum(None, 7, "Access via remote subsystem accessor window failed.", "INT_SOURCE_ENUM")
INT_SOURCE_TIME_UPDATE_EVENT                                                     = c_enum(None, 8, "Subsystem time updated by time sync transaction.", "INT_SOURCE_ENUM")
INT_SOURCE_VML_EVENT                                                             = c_enum(None, 11, "Interrupt from VML.", "INT_SOURCE_ENUM")
INT_SOURCE_DMAC_QUEUE0_EVENT                                                     = c_enum(None, 12, "Interrupt from DMA Controller's Queue 0", "INT_SOURCE_ENUM")
INT_SOURCE_DMAC_QUEUE1_EVENT                                                     = c_enum(None, 13, "Interrupt from DMA Controller's Queue 1", "INT_SOURCE_ENUM")
INT_SOURCE_SQIF_ARBITER_EVENT                                                    = c_enum(None, 15, "Interrupt from SQIF datapath arbiter.", "INT_SOURCE_ENUM")
INT_SOURCE_SQIF_ARBITER1_EVENT                                                   = c_enum(None, 16, "Interrupt from SQIF datapath arbiter 1.", "INT_SOURCE_ENUM")
INT_SOURCE_CPU1_ACCESS_FAULT_EVENT                                               = c_enum(None, 18, "Interrupt from CPU1 access restriction logic.", "INT_SOURCE_ENUM")
INT_SOURCE_INTERPROC_EVENT_1                                                     = c_enum(None, 21, "Interprocessor event from P0.", "INT_SOURCE_ENUM")
INT_SOURCE_INTERPROC_EVENT_2                                                     = c_enum(None, 22, "Interprocessor event from P1.", "INT_SOURCE_ENUM")
INT_SOURCE_PIO_INT_EVENT_1                                                       = c_enum(None, 23, "Interrupt from PIO edge detect 1", "INT_SOURCE_ENUM")
INT_SOURCE_PIO_INT_EVENT_2                                                       = c_enum(None, 24, "Interrupt from PIO edge detect 2", "INT_SOURCE_ENUM")
INT_SOURCE_PIO_TIMER_EVENT_3                                                     = c_enum(None, 25, "Interrupt from PIO timer 3", "INT_SOURCE_ENUM")
INT_SOURCE_CPU1_EXCEPTION                                                        = c_enum(None, 26, "An exception has occurred on CPU1. This interrupt is not attached to CPU1.", "INT_SOURCE_ENUM")
INT_SOURCE_LAST                                                                  = c_enum(None, 26, "Same as the last interrupt source.", "INT_SOURCE_ENUM")
INT_SOURCE_SDIO_HOST_INTERRUPT_EVENT                                             = c_enum(None, 19, "Interrupt from sdio host module.", "INT_SOURCE_ENUM")
INT_SOURCE_SDIO_HOST_WAKEUP_EVENT                                                = c_enum(None, 20, "Wakeup from sdio host module.", "INT_SOURCE_ENUM")
INT_SOURCE_TIMER1                                                                = c_enum(None, 0, "Timer 1 trigger event.", "INT_SOURCE_ENUM")
INT_SOURCE_TIMER2                                                                = c_enum(None, 1, "Timer 2 trigger event.", "INT_SOURCE_ENUM")
INT_SOURCE_SW_ERROR                                                              = c_enum(None, 2, "Software error event (either stack overflow or a memory exception (see STACK_OVERFLOW_PC and EXCEPTION_TYPE).", "INT_SOURCE_ENUM")
INT_SOURCE_SW0                                                                   = c_enum(None, 3, "Software event 0.", "INT_SOURCE_ENUM")
INT_SOURCE_SW1                                                                   = c_enum(None, 4, "Software event 1.", "INT_SOURCE_ENUM")
K32_INTERRUPT__CLOCK_STOPPED                                                     = c_enum(None, 0, "Kalimba clock stopped.", "K32_INTERRUPT__CLOCK_DIVIDE_RATE_ENUM")
K32_INTERRUPT__CLOCK_RATE_MAX                                                    = c_enum(None, 1, "Kalimba clocked at max. clock frequency.", "K32_INTERRUPT__CLOCK_DIVIDE_RATE_ENUM")
K32_INTERRUPT__CLOCK_RATE_HALF                                                   = c_enum(None, 2, "Kalimba clocked at half of max. clock frequency.", "K32_INTERRUPT__CLOCK_DIVIDE_RATE_ENUM")
K32_INTERRUPT__CLOCK_RATE_RESERVED                                               = c_enum(None, 3, "Reserved. Same as CLOCK_STOPPED.", "K32_INTERRUPT__CLOCK_DIVIDE_RATE_ENUM")

# -- Kalimba 32-bit Misc Control registers --

ALLOW_GOTO_SHALLOW_SLEEP                                                         = c_reg(0xffff8098, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_misc", "", "Set this bit to allow CPU to go to shallow sleep.", "", "", 0, 1, "", "", 0)
ALLOW_GOTO_SHALLOW_SLEEP.ALLOW_GOTO_SHALLOW_SLEEP                                = c_bits(ALLOW_GOTO_SHALLOW_SLEEP, 0, 0, 0x1, 1, "RW", "")
CLOCK_CONT_SHALLOW_SLEEP_RATE                                                    = c_reg(0xffff80a8, 1, 1, 0, "RW", 8, 0, 0, 0, "k32_misc", "", "Continuous clock rate when kalimba shallow sleeps, i.e. when CLOCK_DIVIDE_RATE is set to 0. This value controls the counter that generates CLK_CONT. e.g. to generate 1MHz CK_CONT from 240MHz set this register to 239. 0 means maximum clock rate.", "", "", 0, 1, "", "", 0)
CLOCK_CONT_SHALLOW_SLEEP_RATE.CLOCK_CONT_SHALLOW_SLEEP_RATE                      = c_bits(CLOCK_CONT_SHALLOW_SLEEP_RATE, 0, 7, 0xff, 8, "RW", "")
CLOCK_DIVIDE_RATE                                                                = c_reg(0xffff8080, 1, 1, 0, "RW", 2, 1, 0, 0, "k32_misc", "", "Configures the clock frequency used by Kalimba during non-interrupt processing (See INT_CLOCK_DIVIDE_RATE for interrupt version).", "", "", 0, 1, "", "", 0)
CLOCK_DIVIDE_RATE.CLOCK_STOPPED                                                  = c_enum(CLOCK_DIVIDE_RATE, 0, "Kalimba clock stopped.", "CLOCK_DIVIDE_RATE")
CLOCK_DIVIDE_RATE.CLOCK_RATE_MAX                                                 = c_enum(CLOCK_DIVIDE_RATE, 1, "Kalimba clocked at max. clock frequency.", "CLOCK_DIVIDE_RATE")
CLOCK_DIVIDE_RATE.CLOCK_RATE_HALF                                                = c_enum(CLOCK_DIVIDE_RATE, 2, "Kalimba clocked at half of max. clock frequency.", "CLOCK_DIVIDE_RATE")
CLOCK_DIVIDE_RATE.CLOCK_RATE_RESERVED                                            = c_enum(CLOCK_DIVIDE_RATE, 3, "Reserved. Same as CLOCK_STOPPED.", "CLOCK_DIVIDE_RATE")
CLOCK_STOP_WIND_DOWN_SEQUENCE_EN                                                 = c_reg(0xffff8094, 1, 1, 0, "RW", 1, 1, 0, 0, "k32_misc", "", "Ensures the Kalimba's core completes all of its accesses on the bus when the clock is stopped via CLOCK_STOPPED being written to CLOCK_DIVIDE_RATE. This has the added feature of stopping Kalimba from running when it has turned its clock off and debug accesses are made to or through it.", "", "", 0, 1, "", "", 0)
CLOCK_STOP_WIND_DOWN_SEQUENCE_EN.CLOCK_STOP_WIND_DOWN_SEQUENCE_EN                = c_bits(CLOCK_STOP_WIND_DOWN_SEQUENCE_EN, 0, 0, 0x1, 1, "RW", "")
DISABLE_MUTEX_AND_ACCESS_IMMUNITY                                                = c_reg(0xffff80a4, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_misc", "", "When set, disables TBus debug and SPI's immunity to mutex and access restrictions for common registers - they see what kalimba sees. When cleared, TBus debug and SPI can read/write any common register irrespective of ACCESS_CTRL and MUTEX_LOCK settings.", "", "", 0, 1, "", "", 0)
DISABLE_MUTEX_AND_ACCESS_IMMUNITY.DISABLE_MUTEX_AND_ACCESS_IMMUNITY              = c_bits(DISABLE_MUTEX_AND_ACCESS_IMMUNITY, 0, 0, 0x1, 1, "RW", "")
GOTO_SHALLOW_SLEEP                                                               = c_reg(0xffff809c, 0, 1, 0, "W", 1, 0, 1, 0, "k32_misc", "", "Write a 1 to go to shallow sleep (will be effective only if ALLOW_GOTO_SHALLOW_SLEEP is set) and write a 0 to exit shallow sleep.", "", "", 0, 1, "", "", 0)
GOTO_SHALLOW_SLEEP.GOTO_SHALLOW_SLEEP                                            = c_bits(GOTO_SHALLOW_SLEEP, 0, 0, 0x1, 1, "W", "")
PMWIN_ENABLE                                                                     = c_reg(0xffff8084, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_misc", "", "Enables (when set to 1) the mapping of PM RAM into the DM1 space.  When disabled (set to 0) the PM RAM is not accessable from DM1.", "", "", 0, 1, "", "", 0)
PMWIN_ENABLE.PMWIN_ENABLE                                                        = c_bits(PMWIN_ENABLE, 0, 0, 0x1, 1, "RW", "")
PROCESSOR_ID                                                                     = c_reg(0xffff808c, 1, 0, 0, "R", 1, 0, 0, 0, "k32_misc", "", "Read this register to figure out own CPU ID", "", "", 0, 1, "", "", 0)
PROCESSOR_ID.PROCESSOR_ID                                                        = c_bits(PROCESSOR_ID, 0, 0, 0x1, 1, "R", "")
PROC_DEEP_SLEEP_EN                                                               = c_reg(0xffff8088, 1, 1, 0, "RW", 1, 0, 1, 0, "k32_misc", "", "When set, this indicates to the curator that this processor is prepared to enter deep sleep. A register exists in the curator that could cause this bit to be ignored even when set.", "", "", 0, 1, "", "", 0)
PROC_DEEP_SLEEP_EN.PROC_DEEP_SLEEP_EN                                            = c_bits(PROC_DEEP_SLEEP_EN, 0, 0, 0x1, 1, "RW", "")
SHALLOW_SLEEP_STATUS                                                             = c_reg(0xffff80a0, 1, 0, 0, "R", 1, 0, 1, 0, "k32_misc", "", "This bit gets asserted when CPU is in shallow sleep.", "", "", 0, 1, "", "", 0)
SHALLOW_SLEEP_STATUS.SHALLOW_SLEEP_STATUS                                        = c_bits(SHALLOW_SLEEP_STATUS, 0, 0, 0x1, 1, "R", "")
CLOCK_STOPPED                                                                    = c_enum(None, 0, "Kalimba clock stopped.", "CLOCK_DIVIDE_RATE_ENUM")
CLOCK_RATE_MAX                                                                   = c_enum(None, 1, "Kalimba clocked at max. clock frequency.", "CLOCK_DIVIDE_RATE_ENUM")
CLOCK_RATE_HALF                                                                  = c_enum(None, 2, "Kalimba clocked at half of max. clock frequency.", "CLOCK_DIVIDE_RATE_ENUM")
CLOCK_RATE_RESERVED                                                              = c_enum(None, 3, "Reserved. Same as CLOCK_STOPPED.", "CLOCK_DIVIDE_RATE_ENUM")

# -- Kalimba 32-bit Monitor Control registers. --

DM1_PROG_EXCEPTION_REGION_END_ADDR                                               = c_reg(0xffff82b0, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_monitor", "", "End address of the programmable DM1 exception region.", "", "", 0, 1, "", "", 0)
DM1_PROG_EXCEPTION_REGION_END_ADDR.DM1_PROG_EXCEPTION_REGION_END_ADDR            = c_bits(DM1_PROG_EXCEPTION_REGION_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM1_PROG_EXCEPTION_REGION_START_ADDR                                             = c_reg(0xffff82ac, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_monitor", "", "Start address of the programmable DM1 exception region.", "", "", 0, 1, "", "", 0)
DM1_PROG_EXCEPTION_REGION_START_ADDR.DM1_PROG_EXCEPTION_REGION_START_ADDR        = c_bits(DM1_PROG_EXCEPTION_REGION_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM2_PROG_EXCEPTION_REGION_END_ADDR                                               = c_reg(0xffff82b8, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_monitor", "", "End address of the programmable DM2 exception region.", "", "", 0, 1, "", "", 0)
DM2_PROG_EXCEPTION_REGION_END_ADDR.DM2_PROG_EXCEPTION_REGION_END_ADDR            = c_bits(DM2_PROG_EXCEPTION_REGION_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
DM2_PROG_EXCEPTION_REGION_START_ADDR                                             = c_reg(0xffff82b4, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_monitor", "", "Start address of the programmable DM2 exception region.", "", "", 0, 1, "", "", 0)
DM2_PROG_EXCEPTION_REGION_START_ADDR.DM2_PROG_EXCEPTION_REGION_START_ADDR        = c_bits(DM2_PROG_EXCEPTION_REGION_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
EXCEPTION_EN                                                                     = c_reg(0xffff8280, 1, 1, 0, "RW", 2, 0, 0, 0, "k32_monitor", "", "Enables various options for the handling of memory exceptions.", "", "", 0, 1, "", "", 0)
EXCEPTION_EN.EXCEPTION_EN_BREAK                                                  = c_bits(EXCEPTION_EN, 0, 0, 0x1, 1, "RW", "If set then if a memory exception occurs then the processor will pause (just like having hit a breakpoint).  This should typically be enabled for debug software builds.  The debugger (xIDE) will then appropriately inform the user if a memory exception occurs.")
EXCEPTION_EN.EXCEPTION_EN_IRQ                                                    = c_bits(EXCEPTION_EN, 1, 1, 0x2, 1, "RW", "If set then if a memory exception occurs then a SW_ERROR interrupt event will occur.  This should typically be enabled for production software builds.  The ISR can then take appropriate action.")
EXCEPTION_PC                                                                     = c_reg(0xffff82bc, 1, 0, 0, "R", 32, 0, 0, 0, "k32_monitor", "", "Indicates the address of instruction which caused internal exception.", "", "", 0, 1, "", "", 0)
EXCEPTION_PC.EXCEPTION_PC                                                        = c_bits(EXCEPTION_PC, 0, 31, 0xffffffff, 32, "R", "")
EXCEPTION_TYPE                                                                   = c_reg(0xffff8284, 1, 0, 0, "R", 4, 0, 0, 0, "k32_monitor", "", "Indicates the type of memory exception that has occured.", "", "", 0, 1, "", "", 0)
EXCEPTION_TYPE.EXCEPTION_TYPE_NONE                                               = c_enum(EXCEPTION_TYPE, 0, "None", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM1_UNALIGNED_32BIT                                = c_enum(EXCEPTION_TYPE, 1, "An unaligned 32-bit access to DM1.  32-bit accesses should be aligned such that the LS 2 bits of the byte address are 0.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM1_UNALIGNED_16BIT                                = c_enum(EXCEPTION_TYPE, 2, "An unaligned 16-bit access to DM1.  32-bit accesses should be aligned such that the LSB of the byte address is 0.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM1_UNMAPPED                                       = c_enum(EXCEPTION_TYPE, 3, "An unmapped access to DM1.  The memory location accessed is not a valid portion of the memory map.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM2_UNALIGNED_32BIT                                = c_enum(EXCEPTION_TYPE, 4, "An unaligned 32-bit access to DM2.  32-bit accesses should be aligned such that the LS 2 bits of the byte address are 0.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM2_UNALIGNED_16BIT                                = c_enum(EXCEPTION_TYPE, 5, "An unaligned 16-bit access to DM2.  32-bit accesses should be aligned such that the LSB of the byte address is 0.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM2_UNMAPPED                                       = c_enum(EXCEPTION_TYPE, 6, "An unmapped access to DM2.  The memory location accessed is not a valid portion of the memory map.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_PM_UNMAPPED                                        = c_enum(EXCEPTION_TYPE, 7, "An unmapped access to PM.  The memory location accessed is not a valid portion of the memory map.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_PM_PROG_REGION                                     = c_enum(EXCEPTION_TYPE, 8, "Access to programmable PM exception region.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM1_PROG_REGION                                    = c_enum(EXCEPTION_TYPE, 9, "Access to programmable DM1 exception region.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_DM2_PROG_REGION                                    = c_enum(EXCEPTION_TYPE, 10, "Access to programmable DM2 exception region.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_STACK_OVERFLOW                                     = c_enum(EXCEPTION_TYPE, 11, "Stack overflow.", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_OTHER                                              = c_enum(EXCEPTION_TYPE, 12, "Exception caused by something outside of the Kalimba processor (to find out further details you need to read a non-kalimba subsystem register).", "EXCEPTION_TYPE")
EXCEPTION_TYPE.EXCEPTION_TYPE_PM_OUT_OF_BOUNDS                                   = c_enum(EXCEPTION_TYPE, 13, "A program tried to jump to code outside of the program memory bounds.", "EXCEPTION_TYPE")
PM_PROG_EXCEPTION_REGION_END_ADDR                                                = c_reg(0xffff82a8, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_monitor", "", "End address of the programmable PM exception region.", "", "", 0, 1, "", "", 0)
PM_PROG_EXCEPTION_REGION_END_ADDR.PM_PROG_EXCEPTION_REGION_END_ADDR              = c_bits(PM_PROG_EXCEPTION_REGION_END_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PM_PROG_EXCEPTION_REGION_START_ADDR                                              = c_reg(0xffff82a4, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_monitor", "", "Start address of the programmable PM exception region.", "", "", 0, 1, "", "", 0)
PM_PROG_EXCEPTION_REGION_START_ADDR.PM_PROG_EXCEPTION_REGION_START_ADDR          = c_bits(PM_PROG_EXCEPTION_REGION_START_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
PROG_EXCEPTION_REGION_ENABLE                                                     = c_reg(0xffff82a0, 1, 1, 0, "RW", 4, 0, 0, 0, "k32_monitor", "", "", "", "", 0, 1, "", "", 0)
PROG_EXCEPTION_REGION_ENABLE.PM_PROG_EXCEPTION_REGION_ENABLE                     = c_bits(PROG_EXCEPTION_REGION_ENABLE, 0, 0, 0x1, 1, "RW", "Enables programmable PM exception region. Use PM_PROG_EXCEPTION_REGION_START_ADDR and PM_PROG_EXCEPTION_REGION_END_ADDR to define a region in PM, which when accessed fires an exception of type EXCEPTION_TYPE_PM_PROG_REGION. This programmable region can be used to map the cache and catch direct execution of out of cache. Note that enabling or disabling of cache has no bearing on this region being active/inactive.")
PROG_EXCEPTION_REGION_ENABLE.DM1_PROG_EXCEPTION_REGION_ENABLE                    = c_bits(PROG_EXCEPTION_REGION_ENABLE, 1, 1, 0x2, 1, "RW", "Enables programmable DM1 exception region")
PROG_EXCEPTION_REGION_ENABLE.DM2_PROG_EXCEPTION_REGION_ENABLE                    = c_bits(PROG_EXCEPTION_REGION_ENABLE, 2, 2, 0x4, 1, "RW", "Enables programmable DM2 exception region")
PROG_EXCEPTION_REGION_ENABLE.PM_PROG_EXCEPTION_OOB_ENABLE                        = c_bits(PROG_EXCEPTION_REGION_ENABLE, 3, 3, 0x8, 1, "RW", "Enables PM out of bounds exception region")

# -- Kalimba 32-bit Prefetch Control registers. --

PREFETCH_CONFIG                                                                  = c_reg(0xffff8320, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_prefetch", "", "Configures the various prefetch modes of operation.", "", "", 0, 1, "", "", 0)
PREFETCH_CONFIG.PREFETCH_CONFIG_COUNTERS_EN                                      = c_bits(PREFETCH_CONFIG, 0, 0, 0x1, 1, "RW", "Enables the prefetch performance counters (REQUESTs vs PREFETCHs) for use during debugging.")
PREFETCH_DEBUG                                                                   = c_reg(0xffff8334, 1, 0, 0, "R", 25, 0, 0, 0, "k32_prefetch", "", "Configures the various prefetch modes of operation.", "", "", 0, 1, "", "", 0)
PREFETCH_DEBUG.PREFETCH_DEBUG_READ_EN_IN                                         = c_bits(PREFETCH_DEBUG, 0, 0, 0x1, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_WAIT_OUT                                           = c_bits(PREFETCH_DEBUG, 1, 1, 0x2, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_READ_EN_OUT                                        = c_bits(PREFETCH_DEBUG, 2, 2, 0x4, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_WAIT_IN                                            = c_bits(PREFETCH_DEBUG, 3, 3, 0x8, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_MEM_REQUEST                                        = c_bits(PREFETCH_DEBUG, 4, 4, 0x10, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_NEXT_MEMREQUEST                                    = c_bits(PREFETCH_DEBUG, 5, 5, 0x20, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_PMEM_REQUEST                                       = c_bits(PREFETCH_DEBUG, 6, 6, 0x40, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_PM_WAIT_IN_PREV                                    = c_bits(PREFETCH_DEBUG, 7, 7, 0x80, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_MEM_REQUEST_REG                                    = c_bits(PREFETCH_DEBUG, 8, 8, 0x100, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_ALOW_PREFETCHING                                   = c_bits(PREFETCH_DEBUG, 9, 10, 0x600, 2, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_MISS_SEQ_T1                                        = c_bits(PREFETCH_DEBUG, 11, 11, 0x800, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_MISS_SEQ_T2                                        = c_bits(PREFETCH_DEBUG, 12, 12, 0x1000, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_VALID_PREFETCH_DATA                                = c_bits(PREFETCH_DEBUG, 13, 13, 0x2000, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_PREFETCH_VALID                                     = c_bits(PREFETCH_DEBUG, 14, 14, 0x4000, 1, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_PREFETCH_HIT                                       = c_bits(PREFETCH_DEBUG, 15, 19, 0xf8000, 5, "R", "")
PREFETCH_DEBUG.PREFETCH_DEBUG_PREFETCH_VALIDS                                    = c_bits(PREFETCH_DEBUG, 20, 24, 0x1f00000, 5, "R", "")
PREFETCH_DEBUG_ADDR                                                              = c_reg(0xffff8338, 1, 0, 0, "R", 32, 0, 0, 0, "k32_prefetch", "", "Configures the various prefetch modes of operation.", "", "", 0, 1, "", "", 0)
PREFETCH_DEBUG_ADDR.PREFETCH_DEBUG_PMADDRIN                                      = c_bits(PREFETCH_DEBUG_ADDR, 0, 15, 0xffff, 16, "R", "")
PREFETCH_DEBUG_ADDR.PREFETCH_DEBUG_PMADDROUT                                     = c_bits(PREFETCH_DEBUG_ADDR, 16, 31, 0xffff0000, 16, "R", "")
PREFETCH_FLUSH                                                                   = c_reg(0xffff8324, 1, 1, 0, "RW", 1, 0, 1, 0, "k32_prefetch", "", "Writing to this register will invalidate all internal caches within the prefetch block.", "", "", 0, 1, "", "", 0)
PREFETCH_FLUSH.PREFETCH_FLUSH                                                    = c_bits(PREFETCH_FLUSH, 0, 0, 0x1, 1, "RW", "")
PREFETCH_PREFETCH_COUNT                                                          = c_reg(0xffff832c, 1, 0, 0, "R", 32, 0, 0, 0, "k32_prefetch", "", "A debugging register that counts the number of memory accesses requested from the prefetch block (to memory).", "", "", 0, 1, "", "", 0)
PREFETCH_PREFETCH_COUNT.PREFETCH_PREFETCH_COUNT                                  = c_bits(PREFETCH_PREFETCH_COUNT, 0, 31, 0xffffffff, 32, "R", "")
PREFETCH_REQUEST_COUNT                                                           = c_reg(0xffff8328, 1, 0, 0, "R", 32, 0, 0, 0, "k32_prefetch", "", "A debugging register that counts the number of memory accesses requested to the prefetch block (from the DSP core).", "", "", 0, 1, "", "", 0)
PREFETCH_REQUEST_COUNT.PREFETCH_REQUEST_COUNT                                    = c_bits(PREFETCH_REQUEST_COUNT, 0, 31, 0xffffffff, 32, "R", "")
PREFETCH_WAIT_OUT_COUNT                                                          = c_reg(0xffff8330, 1, 0, 0, "R", 32, 0, 0, 0, "k32_prefetch", "", "A debugging register that counts the number of waits send to the DSP core by the prefetch block.", "", "", 0, 1, "", "", 0)
PREFETCH_WAIT_OUT_COUNT.PREFETCH_WAIT_OUT_COUNT                                  = c_bits(PREFETCH_WAIT_OUT_COUNT, 0, 31, 0xffffffff, 32, "R", "")

# -- Kalimba 32-bit Timers Control registers --

TIMER1_EN                                                                        = c_reg(0xffff8184, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_timers", "", "Enables Timer1 interrupt generation (see TIMER1_TRIGGER).  After a Timer1 interrupt has fired this register must be set to 0 to deassert the interrupt controller event line.  To cause a further Timer1 interrupt, TIMER1_TRIGGER should be set, and then this register set to 1 again.", "", "", 0, 1, "", "", 0)
TIMER1_EN.TIMER1_EN                                                              = c_bits(TIMER1_EN, 0, 0, 0x1, 1, "RW", "")
TIMER1_TRIGGER                                                                   = c_reg(0xffff818c, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_timers", "", "Trigger value. If the appropriate enable register, TIMER1_EN, is set then an interrupt is generated when TIMER_TIME >= TIMER1_TRIGGER.", "", "", 0, 1, "", "", 0)
TIMER1_TRIGGER.TIMER1_TRIGGER                                                    = c_bits(TIMER1_TRIGGER, 0, 31, 0xffffffff, 32, "RW", "")
TIMER2_EN                                                                        = c_reg(0xffff8188, 1, 1, 0, "RW", 1, 0, 0, 0, "k32_timers", "", "Enables Timer2 interrupt generation (see TIMER2_TRIGGER).  After a Timer2 interrupt has fired this register must be set to 0 to deassert the interrupt controller event line.  To cause a further Timer2 interrupt, TIMER2_TRIGGER should be set, and then this register set to 1 again.", "", "", 0, 1, "", "", 0)
TIMER2_EN.TIMER2_EN                                                              = c_bits(TIMER2_EN, 0, 0, 0x1, 1, "RW", "")
TIMER2_TRIGGER                                                                   = c_reg(0xffff8190, 1, 1, 0, "RW", 32, 0, 0, 0, "k32_timers", "", "Trigger value. If the appropriate enable register, TIMER2_EN, is set then an interrupt is generated when TIMER_TIME >= TIMER2_TRIGGER.", "", "", 0, 1, "", "", 0)
TIMER2_TRIGGER.TIMER2_TRIGGER                                                    = c_bits(TIMER2_TRIGGER, 0, 31, 0xffffffff, 32, "RW", "")
TIMER_TIME                                                                       = c_reg(0xffff8180, 1, 0, 0, "R", 32, 0, 0, 0, "k32_timers", "", "Timer value that increments every 1us.", "", "", 0, 1, "", "", 0)
TIMER_TIME.TIMER_TIME                                                            = c_bits(TIMER_TIME, 0, 31, 0xffffffff, 32, "R", "")

# -- Kalimba read cache block configuration registers --

KALIMBA_READ_CACHE_CONTROL                                                       = c_reg(0xffffa000, 1, 1, 0, "RW", 7, 0, 0, 0, "kalimba_read_cache", "", "Main control register", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_MODE                       = c_bits(KALIMBA_READ_CACHE_CONTROL, 0, 1, 0x3, 2, "RW", "Selects cache operation mode")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_MODE.KALIMBA_READ_CACHE_MODE_DISABLED = c_value(KALIMBA_READ_CACHE_CONTROL, "KALIMBA_READ_CACHE_MODE_DISABLED", 0, "Bypass mode (bit KALIMBA_READ_CACHE_CONTROL_DISABLE_BUFFER_IN_BYPASS enable/disable the internal buffer")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_MODE.KALIMBA_READ_CACHE_MODE_2WAY = c_value(KALIMBA_READ_CACHE_CONTROL, "KALIMBA_READ_CACHE_MODE_2WAY", 1, "2WAY mode ")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_MODE.KALIMBA_READ_CACHE_MODE_2WAYHALF = c_value(KALIMBA_READ_CACHE_CONTROL, "KALIMBA_READ_CACHE_MODE_2WAYHALF", 2, "2WAY Half mode")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_MODE.KALIMBA_READ_CACHE_MODE_DIRECT = c_value(KALIMBA_READ_CACHE_CONTROL, "KALIMBA_READ_CACHE_MODE_DIRECT", 3, "Direct mode   ")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_ENABLE_PM_COUNTERS         = c_bits(KALIMBA_READ_CACHE_CONTROL, 2, 2, 0x4, 1, "RW", "Enable PM access counters")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_ENABLE_DM_COUNTERS         = c_bits(KALIMBA_READ_CACHE_CONTROL, 3, 3, 0x8, 1, "RW", "Enable DM access counters")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_ENABLE_SLAVE_COUNTERS      = c_bits(KALIMBA_READ_CACHE_CONTROL, 4, 4, 0x10, 1, "RW", "Slave access counters")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_ENABLE_BUFFER_IN_BYPASS    = c_bits(KALIMBA_READ_CACHE_CONTROL, 5, 5, 0x20, 1, "RW", "relevant only in bypass (disabled). 1-Buffer is enabled. 0-buffer is disabled")
KALIMBA_READ_CACHE_CONTROL.KALIMBA_READ_CACHE_CONTROL_ENABLE_MASTER_COUNTERS     = c_bits(KALIMBA_READ_CACHE_CONTROL, 6, 6, 0x40, 1, "RW", "Enable master combined wait counters")
KALIMBA_READ_CACHE_DEBUG_DATA                                                    = c_reg(0xffffa048, 1, 0, 0, "R", 32, 0, 0, 0, "kalimba_read_cache", "", "Debug data- internal inforamtion from fsm, enable only when KALIMBA_READ_CACHE_DEBUG_EN is '1'", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_REQUEST_MODE                    = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 0, 1, 0x3, 2, "R", "Detailes the Master accessing the Cache Rams to check HIT")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_REQUEST_MODE.KALIMBA_READ_CACHE_REQ_FREE = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_REQ_FREE", 0, "No master accesing the rams ")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_REQUEST_MODE.KALIMBA_READ_CACHE_REQ_ILEGAL = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_REQ_ILEGAL", 1, "Ilegal state")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_REQUEST_MODE.KALIMBA_READ_CACHE_REQ_DM_LOCK = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_REQ_DM_LOCK", 2, "DM accesses Cahce rams")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_REQUEST_MODE.KALIMBA_READ_CACHE_REQ_PM_LOCK = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_REQ_PM_LOCK", 3, "PM accesses Cache Rams")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_DUMMY0                          = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 2, 3, 0xc, 2, "R", "Dummy Reg")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_IS_STUCK                        = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 4, 4, 0x10, 1, "R", "Indication whether cache is in Idle but master are waiting for data")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FSM_NOT_BUSY                    = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 5, 5, 0x20, 1, "R", "Indication whether cache is in Idle")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_REQ_CANCELED                    = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 6, 6, 0x40, 1, "R", "Indication whether a request from rams aborted since data exists in Cache buffers")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_DUMMY1                          = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 7, 7, 0x80, 1, "R", "Dummy Reg")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_PM_REQ_STATE                    = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 8, 9, 0x300, 2, "R", "Details the PM access status towrds nvmem - See KALIMBA_READ_CACHE_REQUEST_STATE")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_DM_REQ_STATE                    = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 10, 11, 0xc00, 2, "R", "Details the DM access status towrds nvmem - See KALIMBA_READ_CACHE_REQUEST_STATE")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_DUMMY2                          = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 12, 15, 0xf000, 4, "R", "Dummy Reg")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FETCH_STATE                     = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 16, 16, 0x10000, 1, "R", "Details the Fecth status from Nvmem")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FETCH_STATE.KALIMBA_READ_CACHE_FETCH_IDLE = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_FETCH_IDLE", 0, "IDLE")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FETCH_STATE.KALIMBA_READ_CACHE_FETCH_FETCH = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_FETCH_FETCH", 1, "Fetch data from NVMEM")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FILL_STATE                      = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 17, 17, 0x20000, 1, "R", "Details The status of the Fill towrds Cache Rams")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FILL_STATE.KALIMBA_READ_CACHE_FILL_IDLE = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_FILL_IDLE", 0, "IDLE")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FILL_STATE.KALIMBA_READ_CACHE_FILL_FILL = c_value(KALIMBA_READ_CACHE_DEBUG_DATA, "KALIMBA_READ_CACHE_FILL_FILL", 1, "FIlls data to cache Rams")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FETCH_ID                        = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 18, 18, 0x40000, 1, "R", "Indicate which master is fetching data form nvmem - see KALIMBA_READ_CACHE_PORT_ID_ENUM")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_FILL_ID                         = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 19, 19, 0x80000, 1, "R", "Indicate which master is filling the cahce rams - see KALIMBA_READ_CACHE_PORT_ID_ENUM")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_BUFF_REQ_CNTR                   = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 20, 21, 0x300000, 2, "R", "request buffer allowed range is 0-2")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_BUFF_SAMPLE_CNTR                = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 22, 23, 0xc00000, 2, "R", "sample  buffer allowed range is 0-2")
KALIMBA_READ_CACHE_DEBUG_DATA.REQ_ID_OUT                                         = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 24, 24, 0x1000000, 1, "R", "Indication on Master ID that access the Cache rams")
KALIMBA_READ_CACHE_DEBUG_DATA.REQ_RD_EN_OUT                                      = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 25, 25, 0x2000000, 1, "R", "Indication on ongoing read from the Cache rams")
KALIMBA_READ_CACHE_DEBUG_DATA.REQ_HIT                                            = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 26, 26, 0x4000000, 1, "R", "Hit indication from Cache rams")
KALIMBA_READ_CACHE_DEBUG_DATA.REQ_MISS                                           = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 27, 27, 0x8000000, 1, "R", "Miss indication from Cache rams")
KALIMBA_READ_CACHE_DEBUG_DATA.KALIMBA_READ_CACHE_DUMMY3                          = c_bits(KALIMBA_READ_CACHE_DEBUG_DATA, 28, 31, 0xf0000000, 4, "R", "Dummy Reg")
KALIMBA_READ_CACHE_DEBUG_EN                                                      = c_reg(0xffffa044, 0, 1, 0, "W", 1, 0, 0, 0, "kalimba_read_cache", "", "Enable Debug sample", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_DEBUG_EN.KALIMBA_READ_CACHE_DEBUG_EN                          = c_bits(KALIMBA_READ_CACHE_DEBUG_EN, 0, 0, 0x1, 1, "W", "")
KALIMBA_READ_CACHE_DM_CONFIG                                                     = c_reg(0xffffa008, 1, 1, 0, "RW", 3, 1, 0, 0, "kalimba_read_cache", "", "Controller configuration based on DM behaviour", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_DM_CONFIG.KALIMBA_READ_CACHE_DM_CONFIG_PM_ABORT               = c_bits(KALIMBA_READ_CACHE_DM_CONFIG, 0, 0, 0x1, 1, "RW", "Controller will abort line fills started by DM miss at sub-line valid boundary if subsequent PM access is a cache miss")
KALIMBA_READ_CACHE_DM_CONFIG.KALIMBA_READ_CACHE_DM_CONFIG_DM_ABORT               = c_bits(KALIMBA_READ_CACHE_DM_CONFIG, 1, 1, 0x2, 1, "RW", "Controller will abort line fills started by DM miss at sub-line valid boundary if subsequent DM access is a cache miss")
KALIMBA_READ_CACHE_DM_CONFIG.KALIMBA_READ_CACHE_DM_CONFIG_IDLE_ABORT             = c_bits(KALIMBA_READ_CACHE_DM_CONFIG, 2, 2, 0x4, 1, "RW", "Controller will abort line fills started by DM miss at sub-line valid boundary if DM bus is subsequently idle")
KALIMBA_READ_CACHE_DM_HIT_COUNTER                                                = c_reg(0xffffa014, 1, 1, 0, "RW", 32, 0, 1, 1, "kalimba_read_cache", "", "Data master access hit counter", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_DM_HIT_COUNTER.KALIMBA_READ_CACHE_DM_HIT_COUNTER              = c_bits(KALIMBA_READ_CACHE_DM_HIT_COUNTER, 0, 31, 0xffffffff, 32, "RW", "")
KALIMBA_READ_CACHE_DM_MISS_COUNTER                                               = c_reg(0xffffa018, 1, 1, 0, "RW", 32, 0, 1, 1, "kalimba_read_cache", "", "Data master access miss counter", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_DM_MISS_COUNTER.KALIMBA_READ_CACHE_DM_MISS_COUNTER            = c_bits(KALIMBA_READ_CACHE_DM_MISS_COUNTER, 0, 31, 0xffffffff, 32, "RW", "")
KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_DM                                           = c_reg(0xffffa070, 1, 0, 0, "R", 24, 0, 0, 1, "kalimba_read_cache", "", "Wait states at master DM port incurred while NVMEM port is inactive, presumably because of some internal cache activity.", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_DM.KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_DM    = c_bits(KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_DM, 0, 23, 0xffffff, 24, "R", "")
KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_PM                                           = c_reg(0xffffa074, 1, 0, 0, "R", 24, 0, 0, 1, "kalimba_read_cache", "", "Wait states at master PM port incurred while NVMEM port is inactive, presumably because of some internal cache activity.", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_PM.KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_PM    = c_bits(KALIMBA_READ_CACHE_FSM_WAIT_COUNTER_PM, 0, 23, 0xffffff, 24, "R", "")
KALIMBA_READ_CACHE_INVALIDATE_CONTROL                                            = c_reg(0xffffa020, 1, 1, 0, "RW", 2, 0, 1, 1, "kalimba_read_cache", "", "Writing to this register trigger the invalidate operation. Invalidation can always be done even if cache isn't disabled (except for QCC512X_QCC302X D01, see spec for more detail). Reading this register will return '1' while invalidation is ongoing and '0' when it is IDLE.", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_INVALIDATE_CONTROL.KALIMBA_READ_CACHE_IVALIDATE_ILEGAL_VALUE  = c_enum(KALIMBA_READ_CACHE_INVALIDATE_CONTROL, 0, "Do nothing", "KALIMBA_READ_CACHE_INVALIDATE_CONTROL")
KALIMBA_READ_CACHE_INVALIDATE_CONTROL.KALIMBA_READ_CACHE_INVALIDATE_2WAY_TAG_RAMS = c_enum(KALIMBA_READ_CACHE_INVALIDATE_CONTROL, 1, "Clear 2WAY Tag Rams", "KALIMBA_READ_CACHE_INVALIDATE_CONTROL")
KALIMBA_READ_CACHE_INVALIDATE_CONTROL.KALIMBA_READ_CACHE_INVALIDATE_2WAY_HALF_TAG_RAMS = c_enum(KALIMBA_READ_CACHE_INVALIDATE_CONTROL, 2, "Clear 2WAY Half Tag Rams", "KALIMBA_READ_CACHE_INVALIDATE_CONTROL")
KALIMBA_READ_CACHE_INVALIDATE_CONTROL.KALIMBA_READ_CACHE_INVALIDATE_DIRECT_TAG_FLOPS = c_enum(KALIMBA_READ_CACHE_INVALIDATE_CONTROL, 3, "Clear DIRECT Tag flops", "KALIMBA_READ_CACHE_INVALIDATE_CONTROL")
KALIMBA_READ_CACHE_INVALIDATE_NUM_LINES                                          = c_reg(0xffffa028, 1, 1, 0, "RW", 16, 0, 0, 0, "kalimba_read_cache", "", "Number of lines to be invalidated, Value '0' - clear all Tag lines with care for the cache TAG being cleared. If number of lines exceed the max ram line it will be cropped", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_INVALIDATE_NUM_LINES.KALIMBA_READ_CACHE_INVALIDATE_NUM_LINES  = c_bits(KALIMBA_READ_CACHE_INVALIDATE_NUM_LINES, 0, 15, 0xffff, 16, "RW", "")
KALIMBA_READ_CACHE_INVALIDATE_START_LINE                                         = c_reg(0xffffa024, 1, 1, 0, "RW", 16, 0, 0, 0, "kalimba_read_cache", "", "Start line number when invalidating", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_INVALIDATE_START_LINE.KALIMBA_READ_CACHE_INVALIDATE_START_LINE = c_bits(KALIMBA_READ_CACHE_INVALIDATE_START_LINE, 0, 15, 0xffff, 16, "RW", "")
KALIMBA_READ_CACHE_MISS_LOG_BASE_ADDR                                            = c_reg(0xffffa030, 1, 1, 0, "RW", 32, 0, 0, 0, "kalimba_read_cache", "", "Base memory (byte) address where the cache miss log will be written to", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_MISS_LOG_BASE_ADDR.KALIMBA_READ_CACHE_MISS_LOG_BASE_ADDR      = c_bits(KALIMBA_READ_CACHE_MISS_LOG_BASE_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
KALIMBA_READ_CACHE_MISS_LOG_ENABLE                                               = c_reg(0xffffa02c, 1, 1, 0, "RW", 1, 0, 0, 0, "kalimba_read_cache", "", "Enable miss log functionality", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_MISS_LOG_ENABLE.KALIMBA_READ_CACHE_MISS_LOG_ENABLE            = c_bits(KALIMBA_READ_CACHE_MISS_LOG_ENABLE, 0, 0, 0x1, 1, "RW", "")
KALIMBA_READ_CACHE_MISS_LOG_INDEX                                                = c_reg(0xffffa038, 1, 1, 0, "RW", 16, 0, 1, 1, "kalimba_read_cache", "", "Word number the controller will write the next cache miss log word to", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_MISS_LOG_INDEX.KALIMBA_READ_CACHE_MISS_LOG_INDEX              = c_bits(KALIMBA_READ_CACHE_MISS_LOG_INDEX, 0, 15, 0xffff, 16, "RW", "")
KALIMBA_READ_CACHE_MISS_LOG_SIZE                                                 = c_reg(0xffffa034, 1, 1, 0, "RW", 16, 0, 0, 0, "kalimba_read_cache", "", "Number of log words to be written to memory before wrapping", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_MISS_LOG_SIZE.KALIMBA_READ_CACHE_MISS_LOG_SIZE                = c_bits(KALIMBA_READ_CACHE_MISS_LOG_SIZE, 0, 15, 0xffff, 16, "RW", "")
KALIMBA_READ_CACHE_MUTEX_LOCK                                                    = c_reg(0xffffa04c, 1, 1, 0, "RW", 4, 15, 0, 0, "kalimba_read_cache", "", "Mutex lock", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_MUTEX_LOCK.KALIMBA_READ_CACHE__MUTEX_AVAILABLE                = c_enum(KALIMBA_READ_CACHE_MUTEX_LOCK, 0, "4'b0000 means mutex available, claim it to access the resouce", "KALIMBA_READ_CACHE_MUTEX_LOCK")
KALIMBA_READ_CACHE_MUTEX_LOCK.KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P0            = c_enum(KALIMBA_READ_CACHE_MUTEX_LOCK, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "KALIMBA_READ_CACHE_MUTEX_LOCK")
KALIMBA_READ_CACHE_MUTEX_LOCK.KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P1            = c_enum(KALIMBA_READ_CACHE_MUTEX_LOCK, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "KALIMBA_READ_CACHE_MUTEX_LOCK")
KALIMBA_READ_CACHE_MUTEX_LOCK.KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P2            = c_enum(KALIMBA_READ_CACHE_MUTEX_LOCK, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "KALIMBA_READ_CACHE_MUTEX_LOCK")
KALIMBA_READ_CACHE_MUTEX_LOCK.KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P3            = c_enum(KALIMBA_READ_CACHE_MUTEX_LOCK, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "KALIMBA_READ_CACHE_MUTEX_LOCK")
KALIMBA_READ_CACHE_MUTEX_LOCK.KALIMBA_READ_CACHE__MUTEX_DISABLED                 = c_enum(KALIMBA_READ_CACHE_MUTEX_LOCK, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "KALIMBA_READ_CACHE_MUTEX_LOCK")
KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_DM                                         = c_reg(0xffffa068, 1, 0, 0, "R", 32, 0, 0, 1, "kalimba_read_cache", "", "Wait states at master DM port caused by wait states in NVMEM slave port.", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_DM.KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_DM = c_bits(KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_DM, 0, 31, 0xffffffff, 32, "R", "")
KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_PM                                         = c_reg(0xffffa06c, 1, 0, 0, "R", 32, 0, 0, 1, "kalimba_read_cache", "", "Wait states at master PM port caused by wait states in NVMEM slave port.", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_PM.KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_PM = c_bits(KALIMBA_READ_CACHE_NVMEM_WAIT_COUNTER_PM, 0, 31, 0xffffffff, 32, "R", "")
KALIMBA_READ_CACHE_PARAMS                                                        = c_reg(0xffffa03c, 1, 0, 0, "R", 32, 0, 0, 0, "kalimba_read_cache", "", "Cache configuration (synthesis-time configuration)", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_PARAMS.KALIMBA_READ_CACHE_PARAMS_WORD_WIDTH                   = c_bits(KALIMBA_READ_CACHE_PARAMS, 0, 7, 0xff, 8, "R", "Cache word width (bits)")
KALIMBA_READ_CACHE_PARAMS.KALIMBA_READ_CACHE_PARAMS_DIRECT_LINE_LENGTH           = c_bits(KALIMBA_READ_CACHE_PARAMS, 8, 15, 0xff00, 8, "R", "Line length (bytes) in direct-mapped mode")
KALIMBA_READ_CACHE_PARAMS.KALIMBA_READ_CACHE_PARAMS_2WAY_LINE_LENGTH             = c_bits(KALIMBA_READ_CACHE_PARAMS, 16, 23, 0xff0000, 8, "R", "Line length (bytes) in 2-way mode")
KALIMBA_READ_CACHE_PARAMS.KALIMBA_READ_CACHE_PARAMS_EXTENT                       = c_bits(KALIMBA_READ_CACHE_PARAMS, 24, 31, 0xff000000, 8, "R", "Cache extent (megabytes)")
KALIMBA_READ_CACHE_PM_CONFIG                                                     = c_reg(0xffffa004, 1, 1, 0, "RW", 3, 0, 0, 0, "kalimba_read_cache", "", "Controller configuration based on PM behaviour", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_PM_CONFIG.KALIMBA_READ_CACHE_PM_CONFIG_PM_ABORT               = c_bits(KALIMBA_READ_CACHE_PM_CONFIG, 0, 0, 0x1, 1, "RW", "Controller will abort line fills started by PM miss at sub-line valid boundary if subsequent PM access is a cache miss")
KALIMBA_READ_CACHE_PM_CONFIG.KALIMBA_READ_CACHE_PM_CONFIG_DM_ABORT               = c_bits(KALIMBA_READ_CACHE_PM_CONFIG, 1, 1, 0x2, 1, "RW", "Controller will abort line fills started by PM miss at sub-line valid boundary if subsequent DM access is a cache miss")
KALIMBA_READ_CACHE_PM_CONFIG.KALIMBA_READ_CACHE_PM_CONFIG_IDLE_ABORT             = c_bits(KALIMBA_READ_CACHE_PM_CONFIG, 2, 2, 0x4, 1, "RW", "Controller will abort line fills started by PM miss at sub-line valid boundary if PM bus is subsequently idle")
KALIMBA_READ_CACHE_PM_HIT_COUNTER                                                = c_reg(0xffffa00c, 1, 1, 0, "RW", 32, 0, 1, 1, "kalimba_read_cache", "", "Program master access hit counter", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_PM_HIT_COUNTER.KALIMBA_READ_CACHE_PM_HIT_COUNTER              = c_bits(KALIMBA_READ_CACHE_PM_HIT_COUNTER, 0, 31, 0xffffffff, 32, "RW", "")
KALIMBA_READ_CACHE_PM_MISS_COUNTER                                               = c_reg(0xffffa010, 1, 1, 0, "RW", 32, 0, 1, 1, "kalimba_read_cache", "", "Program master access miss counter", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_PM_MISS_COUNTER.KALIMBA_READ_CACHE_PM_MISS_COUNTER            = c_bits(KALIMBA_READ_CACHE_PM_MISS_COUNTER, 0, 31, 0xffffffff, 32, "RW", "")
KALIMBA_READ_CACHE_SLAVE_WAIT_COUNTER                                            = c_reg(0xffffa01c, 1, 1, 0, "RW", 32, 0, 1, 1, "kalimba_read_cache", "", "Counter of number of cycles spent waiting for slave", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_SLAVE_WAIT_COUNTER.KALIMBA_READ_CACHE_SLAVE_WAIT_COUNTER      = c_bits(KALIMBA_READ_CACHE_SLAVE_WAIT_COUNTER, 0, 31, 0xffffffff, 32, "RW", "")
KALIMBA_READ_CACHE_SOFT_RESET                                                    = c_reg(0xffffa040, 0, 1, 0, "W", 1, 0, 1, 0, "kalimba_read_cache", "", "Generate Soft Reset pulse. Warning: This should not be used under normal circumstances as this can cause the cache to reset while it's active and abort on going memory transactions which is really bad and may have unpredictable consequences. Cache doesn't need soft reset for correct operation or switching modes. For safe reset, cache should be completely inactive which is hard to guarantee (see B-210911 for detail).", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_SOFT_RESET.KALIMBA_READ_CACHE_SOFT_RESET                      = c_bits(KALIMBA_READ_CACHE_SOFT_RESET, 0, 0, 0x1, 1, "W", "")
KALIMBA_READ_CACHE_TRANSITION_STATUS                                             = c_reg(0xffffa054, 1, 0, 0, "R", 4, 0, 0, 0, "kalimba_read_cache", "", "Register give indication on current working mode and if there is a pending change mode or invalidate tag requests", "", "", 1, 1, "", "APPS_SYS_CACHE_SEL", 0)
KALIMBA_READ_CACHE_TRANSITION_STATUS.KALIMBA_READ_CACHE_ACTUAL_CONTROL_MODE      = c_bits(KALIMBA_READ_CACHE_TRANSITION_STATUS, 0, 1, 0x3, 2, "R", "Actual current configuration - to verify if requested configuration is the current configuration")
KALIMBA_READ_CACHE_TRANSITION_STATUS.KALIMBA_READ_CACHE_PENDING_MODE_CHANE       = c_bits(KALIMBA_READ_CACHE_TRANSITION_STATUS, 2, 2, 0x4, 1, "R", "1-Change mode request is pending.0-cache mode is up to date")
KALIMBA_READ_CACHE_TRANSITION_STATUS.KALIMBA_READ_CACHE_PENDING_INVALDIATE       = c_bits(KALIMBA_READ_CACHE_TRANSITION_STATUS, 3, 3, 0x8, 1, "R", "1-Invalidate request is pending. 0-no pending invalidate requests")
KALIMBA_READ_CACHE_PORT_ID_PM                                                    = c_enum(None, 0, "", "KALIMBA_READ_CACHE_PORT_ID_ENUM")
KALIMBA_READ_CACHE_PORT_ID_DM                                                    = c_enum(None, 1, "", "KALIMBA_READ_CACHE_PORT_ID_ENUM")
KALIMBA_READ_CACHE_REQ_STATE_IDLE                                                = c_enum(None, 0, "IDLE  - no access", "KALIMBA_READ_CACHE_REQUEST_STATE")
KALIMBA_READ_CACHE_REQ_STATE_STALL                                               = c_enum(None, 1, "STALL - After miss, NVMEM is still filling prevoius Master request or dealing request from second master", "KALIMBA_READ_CACHE_REQUEST_STATE")
KALIMBA_READ_CACHE_REQ_STATE_ON_PROGRESS                                         = c_enum(None, 2, "On Progress - After Miss, Nvmem fetch data for the Master and will return it soon ", "KALIMBA_READ_CACHE_REQUEST_STATE")
KALIMBA_READ_CACHE_TAG_2WAY_WAY0_SLVB                                            = c_enum(None, 0, "", "KALIMBA_READ_CACHE_TAG_2WAY_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LRU                                                  = c_enum(None, 4, "", "KALIMBA_READ_CACHE_TAG_2WAY_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_WAY0_TAG                                             = c_enum(None, 5, "", "KALIMBA_READ_CACHE_TAG_2WAY_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_WAY1_SLVB                                            = c_enum(None, 16, "", "KALIMBA_READ_CACHE_TAG_2WAY_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_WAY1_RESERVED                                        = c_enum(None, 20, "", "KALIMBA_READ_CACHE_TAG_2WAY_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_WAY1_TAG                                             = c_enum(None, 21, "", "KALIMBA_READ_CACHE_TAG_2WAY_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY0_SLVB                                   = c_enum(None, 0, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY0_LOCKED                                 = c_enum(None, 4, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY0_TAG                                    = c_enum(None, 5, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY0_RESERVED                               = c_enum(None, 15, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY1_SLVB                                   = c_enum(None, 16, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY1_LOCKED                                 = c_enum(None, 20, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_WAY1_TAG                                    = c_enum(None, 21, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_LRU                                         = c_enum(None, 31, "", "KALIMBA_READ_CACHE_TAG_2WAY_LOCKABLE_ENUM")
KALIMBA_READ_CACHE_TAG_DIRECT_SLVB                                               = c_enum(None, 0, "", "KALIMBA_READ_CACHE_TAG_DIRECT_ENUM")
KALIMBA_READ_CACHE_TAG_DIRECT_TAG                                                = c_enum(None, 32, "", "KALIMBA_READ_CACHE_TAG_DIRECT_ENUM")
KALIMBA_READ_CACHE__P0_ACCESS_PERMISSION                                         = c_enum(None, 0, "Access permission for P0", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P0_ACCESS_BLOCKED                                            = c_enum(None, 0, "P0 does not have read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P0_ACCESS_UNBLOCKED                                          = c_enum(None, 1, "P0 has read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P1_ACCESS_PERMISSION                                         = c_enum(None, 1, "Access permission for P1", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P1_ACCESS_BLOCKED                                            = c_enum(None, 0, "P1 does not have read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P1_ACCESS_UNBLOCKED                                          = c_enum(None, 1, "P1 has read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P2_ACCESS_PERMISSION                                         = c_enum(None, 2, "Access permission for P2", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P2_ACCESS_BLOCKED                                            = c_enum(None, 0, "P2 does not have read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P2_ACCESS_UNBLOCKED                                          = c_enum(None, 1, "P2 has read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P3_ACCESS_PERMISSION                                         = c_enum(None, 3, "Access permission for P3", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P3_ACCESS_BLOCKED                                            = c_enum(None, 0, "P3 does not have read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__P3_ACCESS_UNBLOCKED                                          = c_enum(None, 1, "P3 has read/write access", "KALIMBA_READ_CACHE__ACCESS_CTRL_ENUM")
KALIMBA_READ_CACHE__MUTEX_AVAILABLE                                              = c_enum(None, 0, "4'b0000 means mutex available, claim it to access the resouce", "KALIMBA_READ_CACHE__MUTEX_LOCK_ENUM")
KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P0                                          = c_enum(None, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "KALIMBA_READ_CACHE__MUTEX_LOCK_ENUM")
KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P1                                          = c_enum(None, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "KALIMBA_READ_CACHE__MUTEX_LOCK_ENUM")
KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P2                                          = c_enum(None, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "KALIMBA_READ_CACHE__MUTEX_LOCK_ENUM")
KALIMBA_READ_CACHE__MUTEX_CLAIMED_BY_P3                                          = c_enum(None, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "KALIMBA_READ_CACHE__MUTEX_LOCK_ENUM")
KALIMBA_READ_CACHE__MUTEX_DISABLED                                               = c_enum(None, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "KALIMBA_READ_CACHE__MUTEX_LOCK_ENUM")

READ_DECRYPT_CLEARTEXT_BASE                                                      = c_reg(0xffff9504, 1, 1, 0, "RW", 32, 0, 0, 0, "read_decrypt", "", "Cleartext base address in units of 4096 bytes", "", "", 0, 1, "", "", 0)
READ_DECRYPT_CLEARTEXT_BASE.READ_DECRYPT_CLEARTEXT_BASE                          = c_bits(READ_DECRYPT_CLEARTEXT_BASE, 0, 31, 0xffffffff, 32, "RW", "")
READ_DECRYPT_CLEARTEXT_SIZE                                                      = c_reg(0xffff9508, 1, 1, 0, "RW", 32, 0, 0, 0, "read_decrypt", "", "Cleartext size in units of 4096 bytes", "", "", 0, 1, "", "", 0)
READ_DECRYPT_CLEARTEXT_SIZE.READ_DECRYPT_CLEARTEXT_SIZE                          = c_bits(READ_DECRYPT_CLEARTEXT_SIZE, 0, 31, 0xffffffff, 32, "RW", "")
READ_DECRYPT_CONTROL                                                             = c_reg(0xffff9500, 1, 1, 0, "RW", 10, 0, 0, 0, "read_decrypt", "", "Control and configuration flags for the read-decrypt module.", "", "", 0, 1, "", "", 0)
READ_DECRYPT_CONTROL.ENABLE                                                      = c_bits(READ_DECRYPT_CONTROL, 0, 0, 0x1, 1, "RW", "Write 1 to enable decryption. Write 0 to bypass decryption and read straight, unmodified SQIF data.")
READ_DECRYPT_CONTROL.PERF_ENABLE                                                 = c_bits(READ_DECRYPT_CONTROL, 1, 1, 0x2, 1, "RW", "Writing 1 will enable the clocking for the performance counters.")
READ_DECRYPT_CONTROL.PERF_INDEX                                                  = c_bits(READ_DECRYPT_CONTROL, 2, 4, 0x1c, 3, "RW", "Index of the performance counter to be read.")
READ_DECRYPT_CONTROL.DEBUG_SEL                                                   = c_bits(READ_DECRYPT_CONTROL, 5, 5, 0x20, 1, "RW", "Selects one of two sets of debug signals for output.")
READ_DECRYPT_CONTROL.LITTLE_ENDIAN_KEY                                           = c_bits(READ_DECRYPT_CONTROL, 6, 6, 0x40, 1, "RW", "When 1, the bytes of the AES key are ordered in 'little endian' mode before hashing (MS Byte will be on the left side). When 0, 'big endian' ordering is used (LS Byte will be on the left side). Set this flag according to the conventions used in the DMAC and elsewhere in the FW.")
READ_DECRYPT_CONTROL.LITTLE_ENDIAN_ADDRESS                                       = c_bits(READ_DECRYPT_CONTROL, 7, 7, 0x80, 1, "RW", "When 1, the bytes of the AES input ('Address') are ordered in 'little endian' mode before hashing (MS Byte will be on the left side). When 0, 'big endian' ordering is used (LS Byte will be on the left side). Set this flag according to the conventions used in the DMAC and elsewhere in the FW.")
READ_DECRYPT_CONTROL.LITTLE_ENDIAN_HASH                                          = c_bits(READ_DECRYPT_CONTROL, 8, 8, 0x100, 1, "RW", "When 1, the bytes of the AES output ('Hash') are ordered in 'little endian' mode before hashing (MS Byte will be on the left side). When 0, 'big endian' ordering is used (LS Byte will be on the left side). Set this flag according to the conventions used in the DMAC and elsewhere in the FW.")
READ_DECRYPT_CONTROL.RESET                                                       = c_bits(READ_DECRYPT_CONTROL, 9, 9, 0x200, 1, "RW", "Soft reset. The module will remain in reset state as long as this bit is 1.")
READ_DECRYPT_IMAGE_ADDRESS_MASK                                                  = c_reg(0xffff950c, 1, 1, 0, "RW", 16, 65535, 0, 0, "read_decrypt", "", "The high word of every address (bits above 15) is masked with this input before being hashed. This is meant to allow SW images to be written to different 'pages' of the FLASH without having to re-encrypt them.", "", "", 0, 1, "", "", 0)
READ_DECRYPT_KEY                                                                 = c_reg(0xffff9510, 1, 1, 0, "RW", 128, 0, 0, 0, "read_decrypt", "", "Key.", "", "", 0, 1, "", "", 0)
READ_DECRYPT_KEY_ENABLE                                                          = c_reg(0xffff9530, 1, 1, 0, "RW", 1, 0, 0, 0, "read_decrypt", "", "Write 1 to use the key from this registers block, instead of the one from EFUSE.", "", "", 0, 1, "", "", 0)
READ_DECRYPT_KEY_ENABLE.READ_DECRYPT_KEY_ENABLE                                  = c_bits(READ_DECRYPT_KEY_ENABLE, 0, 0, 0x1, 1, "RW", "")
READ_DECRYPT_MUTEX_LOCK                                                          = c_reg(0xffff9534, 1, 1, 0, "RW", 4, 15, 0, 0, "read_decrypt", "", "Mutex lock", "", "", 0, 1, "", "", 0)
READ_DECRYPT_MUTEX_LOCK.READ_DECRYPT__MUTEX_AVAILABLE                            = c_enum(READ_DECRYPT_MUTEX_LOCK, 0, "4'b0000 means mutex available, claim it to access the resouce", "READ_DECRYPT_MUTEX_LOCK")
READ_DECRYPT_MUTEX_LOCK.READ_DECRYPT__MUTEX_CLAIMED_BY_P0                        = c_enum(READ_DECRYPT_MUTEX_LOCK, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "READ_DECRYPT_MUTEX_LOCK")
READ_DECRYPT_MUTEX_LOCK.READ_DECRYPT__MUTEX_CLAIMED_BY_P1                        = c_enum(READ_DECRYPT_MUTEX_LOCK, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "READ_DECRYPT_MUTEX_LOCK")
READ_DECRYPT_MUTEX_LOCK.READ_DECRYPT__MUTEX_CLAIMED_BY_P2                        = c_enum(READ_DECRYPT_MUTEX_LOCK, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "READ_DECRYPT_MUTEX_LOCK")
READ_DECRYPT_MUTEX_LOCK.READ_DECRYPT__MUTEX_CLAIMED_BY_P3                        = c_enum(READ_DECRYPT_MUTEX_LOCK, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "READ_DECRYPT_MUTEX_LOCK")
READ_DECRYPT_MUTEX_LOCK.READ_DECRYPT__MUTEX_DISABLED                             = c_enum(READ_DECRYPT_MUTEX_LOCK, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "READ_DECRYPT_MUTEX_LOCK")
READ_DECRYPT_NONCE                                                               = c_reg(0xffff9520, 1, 1, 0, "RW", 128, 0, 0, 0, "read_decrypt", "", "Nonce.", "", "", 0, 1, "", "", 0)
READ_DECRYPT_PERFORMANCE                                                         = c_reg(0xffff953c, 1, 0, 0, "R", 32, 0, 0, 0, "read_decrypt", "", "Control register for performance counters.", "", "", 0, 1, "", "", 0)
READ_DECRYPT_PERFORMANCE.READ_DECRYPT_PERFORMANCE                                = c_bits(READ_DECRYPT_PERFORMANCE, 0, 31, 0xffffffff, 32, "R", "")
READ_DECRYPT__P0_ACCESS_PERMISSION                                               = c_enum(None, 0, "Access permission for P0", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P0_ACCESS_BLOCKED                                                  = c_enum(None, 0, "P0 does not have read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P0_ACCESS_UNBLOCKED                                                = c_enum(None, 1, "P0 has read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P1_ACCESS_PERMISSION                                               = c_enum(None, 1, "Access permission for P1", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P1_ACCESS_BLOCKED                                                  = c_enum(None, 0, "P1 does not have read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P1_ACCESS_UNBLOCKED                                                = c_enum(None, 1, "P1 has read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P2_ACCESS_PERMISSION                                               = c_enum(None, 2, "Access permission for P2", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P2_ACCESS_BLOCKED                                                  = c_enum(None, 0, "P2 does not have read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P2_ACCESS_UNBLOCKED                                                = c_enum(None, 1, "P2 has read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P3_ACCESS_PERMISSION                                               = c_enum(None, 3, "Access permission for P3", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P3_ACCESS_BLOCKED                                                  = c_enum(None, 0, "P3 does not have read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__P3_ACCESS_UNBLOCKED                                                = c_enum(None, 1, "P3 has read/write access", "READ_DECRYPT__ACCESS_CTRL_ENUM")
READ_DECRYPT__MUTEX_AVAILABLE                                                    = c_enum(None, 0, "4'b0000 means mutex available, claim it to access the resouce", "READ_DECRYPT__MUTEX_LOCK_ENUM")
READ_DECRYPT__MUTEX_CLAIMED_BY_P0                                                = c_enum(None, 1, "4'b0001 means mutex claimed by P0, only P0 can access the resource", "READ_DECRYPT__MUTEX_LOCK_ENUM")
READ_DECRYPT__MUTEX_CLAIMED_BY_P1                                                = c_enum(None, 2, "4'b0010 means mutex claimed by P1, only P1 can access the resource", "READ_DECRYPT__MUTEX_LOCK_ENUM")
READ_DECRYPT__MUTEX_CLAIMED_BY_P2                                                = c_enum(None, 4, "4'b0100 means mutex claimed by P2, only P2 can access the resource", "READ_DECRYPT__MUTEX_LOCK_ENUM")
READ_DECRYPT__MUTEX_CLAIMED_BY_P3                                                = c_enum(None, 8, "4'b1000 means mutex claimed by P3, only P3 can access the resource", "READ_DECRYPT__MUTEX_LOCK_ENUM")
READ_DECRYPT__MUTEX_DISABLED                                                     = c_enum(None, 15, "4'b1111 means mutex disabled, no need to claim mutex. Note that any CPU that has access permission defined by ACCESS_CTRL can still claim mutex or clear it to enable mutex. Also note that writing any value other than the defined enums (e.g. 4'b0011, 4'b1101, etc) will lock out the resource for everyone and will require a reset to unlock it.", "READ_DECRYPT__MUTEX_LOCK_ENUM")



USB2_ENDPOINT_SELECT                                                             = c_reg(0x60041240, 1, 1, 0, "RW", 6, 0, 0, 0, "usb2_per_ss", "", "Select endpoint index to configure", "", "", 0, 1, "USB2_EP_CONFIG_BYTES_RCVD_THIS_TRANSFER,USB2_EP_CONFIG_CLEAR,USB2_EP_CONFIG_DATA_SEQUENCE,USB2_EP_CONFIG_DEVICE_ADDRESS,USB2_EP_CONFIG_DEVICE_ADDRESS_READ,USB2_EP_CONFIG_ENABLES,USB2_EP_CONFIG_ENABLES_READ,USB2_EP_CONFIG_ENDPOINT_NUMBER_AND_TYPE,USB2_EP_CONFIG_ENDPOINT_NUMBER_AND_TYPE_READ,USB2_EP_CONFIG_MAX_PACKET_SIZE,USB2_EP_CONFIG_MAX_PACKET_SIZE_READ,USB2_EP_CONFIG_NUM_PACKETS_RCVD_THIS_TRANSFER,USB2_EP_CONFIG_PROTOCOL,USB2_EP_CONFIG_PROTOCOL_READ,USB2_EP_CONFIG_RX_ADD_BUFFER_SPACE,USB2_EP_CONFIG_RX_FREE_SPACE_IN_BUFFER,USB2_EP_CONFIG_RX_MMU_BUFFER_HANDLE,USB2_EP_CONFIG_RX_MMU_BUFFER_HANDLE_READ,USB2_EP_CONFIG_RX_PACKETS_PER_TRANSFER,USB2_EP_CONFIG_RX_PACKETS_PER_TRANSFER_READ,USB2_EP_CONFIG_SSID_READ,USB2_EP_CONFIG_STATUS,USB2_EP_CONFIG_TX_ISOCH_MAX_PACKETS,USB2_EP_CONFIG_TX_ISOCH_MAX_PACKETS_READ,USB2_EP_CONFIG_TX_TD_BUFFER,USB2_EP_CONFIG_TX_TD_BUFFER_READ,USB2_TX_EP_STATUS", "", 0)
USB2_ENDPOINT_SELECT.USB2_ENDPOINT_SELECT_INDEX                                  = c_bits(USB2_ENDPOINT_SELECT, 0, 4, 0x1f, 5, "RW", "Endpoint Index")
USB2_ENDPOINT_SELECT.USB2_ENDPOINT_SELECT_RX_NOT_TX                              = c_bits(USB2_ENDPOINT_SELECT, 5, 5, 0x20, 1, "RW", "1: OUT/Rx endpoints. 0: IN/Tx endpoints. ")

VM_FREE_LIST_ADDR                                                                = c_reg(0xffff9a00, 1, 1, 0, "RW", 32, 0, 1, 0, "", "", "", "", "", 1, 1, "", "", 0)
VM_FREE_LIST_ADDR.VM_FREE_LIST_ADDR                                              = c_bits(VM_FREE_LIST_ADDR, 0, 31, 0xffffffff, 32, "RW", "")
MMU_FREE_LIST_ADDR                                                               = VM_FREE_LIST_ADDR
 