############################################################################
# CONFIDENTIAL
#
# Copyright (c) 2014-2020 Qualcomm Technologies International, Ltd.
#
############################################################################
'''
Provides a mixin HasFPGARegs to allow access to FPGA registers.

Caveat: whereas you might think a chip should be derived from this in fact
this implementation assumes it is the device that derives from this
because it tries to access the apps_subsystem and curator_subsytem members
thereof.
'''


import os
from csr.wheels import gstrm
from csr.wheels.global_streams import iprint
from csr.wheels.bitsandbobs import dwords_to_bytes, bytes_to_dwords, \
    bytes_to_words, pack_unpack_data_le, hex_array_str_columns
from csr.wheels.importer import import_source_module_from_path
from csr.dev.model import interface
from csr.dev.adaptor.text_adaptor import TextAdaptor
from csr.dev.hw.address_space import AddressMungingAccessView

class HasFPGARegs(object):
    """
    Simple mixin class that adds the FPGA registers which exist on emulators,
    but not ASICs.
    These are usually accessed via the Apps subsystem.
    Their documentation is found in the autogenerated digital docs at
    ext_regs/fpga/doc/main.html
    For example:
    http://engweb/~ce03/jenkins_generated/ext_regs/fpga/doc/main.html

    Derived classes should call __init__().
    """

    def __init__(self):
        self._fpga_regs = None
        self.efuse_data = None

    @property
    def efuse_reg_info(self):
        'Accessor to the efuse register info for the chip'
        return self.curator_subsystem.efuse_reg_info

    @property
    def fpga_regs(self):
        ''' Reads the register information for the fpga
        '''
        if (not hasattr(self, '_fpga_regs')) or not self._fpga_regs:
            fpga_regs = dict()

            if self.emulator_build is not None:
                if not isinstance(self.emulator_build, str):
                    if len(self.emulator_build) != 1:
                        raise ValueError(
                            "HasFPGARegs expects exactly one "
                            "emulator build path to be supplied")
                    emulator_build = self.emulator_build[0]
                else:
                    emulator_build = self.emulator_build
                custom_digits_path = os.path.join(
                    emulator_build,
                    "ext_regs", "fpga",
                    "python")
                io_struct_file = os.path.join(
                    custom_digits_path, "io_struct.py")
                if not os.path.isfile(io_struct_file):
                    iprint("No such io_struct file '%s'. "
                           "Falling back to checked-in "
                           "io_struct" % io_struct_file)
                    custom_digits_path = None
            else:
                custom_digits_path = None
            if custom_digits_path is not None:
                search_path = custom_digits_path
                io_struct_name = "io_struct"
            else:
                search_path = os.path.join(
                    os.path.dirname(__file__), "..", "..", "io")
                io_struct_name = self.FPGA_REGS_NAME

            fpga_io_struct = import_source_module_from_path(
                search_path, io_struct_name, allow_replacement=True)
            for attr in dir(fpga_io_struct):
                if attr.startswith("FPGA_"):
                    fpga_regs[attr] = getattr(fpga_io_struct, attr).addr

            self._fpga_regs = fpga_regs
        return self._fpga_regs

    def fpga_version(self):
        ''' Return the FPGA version build date '''
        return (self.fpga_reg_read("FPGA_BUILD_ID_LH") |
                (self.fpga_reg_read("FPGA_BUILD_ID_UH")<<16))

    @property
    def _fpga_reg_offset(self):
        """
        The offset to apply before submitting the register accesses to TRB
        """
        #pylint: disable=protected-access
        if self.apps_subsystem._view_type == AddressMungingAccessView:
            return 0x7fff0000
        return 0xffff0000

    def fpga_reg_read(self, address):
        r''' Write to a register in the FPGA ext regs area
        See emulator_releases\dev\csra68100_partial_emu_1_140331_13\
        digital_results\ext_regs\fpga\doc\main.html for details.
        '''
        if isinstance(address, str):
            address = self.fpga_regs[address]
        byte_address = self._fpga_reg_offset + address
        # Note: there's no explicit fundamental space for the FPGA regs: the
        # TRB will just route this straight out
        return bytes_to_dwords(
            self.apps_subsystem.trb_in[byte_address:byte_address+4])[0]

    def fpga_get_reg_byte_address(self, reg_name_or_address):
        ''' Get the equivalent address for a register name.
        '''
        if isinstance(reg_name_or_address, str):
            address = self.fpga_regs[reg_name_or_address]
        else:
            address = reg_name_or_address

        return self._fpga_reg_offset + address

    def fpga_reg_write(self, address, value):
        r''' Write to a register in the FPGA ext regs area
        See emulator_releases\dev\csra68100_partial_emu_1_140331_13\
        digital_results\ext_regs\fpga\doc\main.html for details.
        '''
        if isinstance(address, str):
            address = self.fpga_regs[address]
        byte_address = self._fpga_reg_offset + address
        self.apps_subsystem.trb_in[byte_address:byte_address+4] = (
            dwords_to_bytes([value]))

    def fpga_chip_reset(self):
        '''
        Use the FPGA register to do a chip reset. Obviously this won't work
        on an ASIC.
        '''
        self.fpga_reg_write("FPGA_RESET_CORE_DIGITS", 1)
        iprint('Reset core digits, (but not FPGA ones).')

    def dump_efuse(self, report=False):
        '''
        Show the contents of the efuse emulation
        '''
        #pylint: disable=unused-variable
        self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)
        primary_words = [self.fpga_reg_read("FPGA_EFUSE_PRIMARY_RD_DATA")
                         for i in range(16)]
        self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)
        security_words = [self.fpga_reg_read("FPGA_EFUSE_SECURITY_RD_DATA")
                          for i in range(16)]
        self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)

        efuse = pack_unpack_data_le(primary_words, 16, 8)
        efuse_key = pack_unpack_data_le(security_words, 16, 8)

        efuse_output = interface.Group("Primary")
        efuse_output.append(interface.Code(hex_array_str_columns(efuse)))
        efuse_key_output = interface.Group("Security/Secondary")
        efuse_key_output.append(
            interface.Code(hex_array_str_columns(efuse_key)))

        output = interface.Group("E Fuse")
        output.append(efuse_output)
        output.append(efuse_key_output)

        try:
            tertiary_words = [self.fpga_reg_read("FPGA_EFUSE_TERTIARY_RD_DATA")
                              for i in range(16)]
            self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)
            efuse3 = pack_unpack_data_le(tertiary_words, 16, 8)
            efuse_output = interface.Group("Tertiary")
            efuse_output.append(interface.Code(hex_array_str_columns(efuse3)))
            output.append(efuse_output)
            try:
                quaternary_words = [
                    self.fpga_reg_read(
                        "FPGA_EFUSE_QUARTENARY_RD_DATA") #sic
                    for i in range(16)]
                efuse4 = pack_unpack_data_le(quaternary_words, 16, 8)
                efuse_output = interface.Group("Quaternary")
                efuse_output.append(
                    interface.Code(hex_array_str_columns(efuse4)))
                output.append(efuse_output)
            except KeyError:
                efuse4 = None
        except KeyError:
            efuse3 = None

        if report is True:
            return output
        TextAdaptor(output, gstrm.iout)
        return None

    def efuse_set_bit(self, efuse_bit_number, value, bank="PRIMARY"):
        '''
        Use the fpga registers to set to value the efuse_bit_number security bit
        in the emulated bank efuse, which defaults to "PRIMARY".
        Other values for bank, if the chip supports them, are:
        "SECURITY", "TERTIARY", "QUARTENARY" (sic),
        when those are used the efuse_bit_number on receipt is adjusted by
        subtracting size of preceding bank bits (n.b. SECURITY bank size is 128)
        '''
        delend = 0
        if bank != 'PRIMARY':
            ranges = {
                'SECURITY':
                    self.efuse_reg_info.primary_bit_range,
                'TERTIARY':
                    (self.efuse_reg_info.primary_bit_range +
                     self.efuse_reg_info.secondary_bit_range),
                'QUARTENARY':
                    (self.efuse_reg_info.primary_bit_range +
                     self.efuse_reg_info.secondary_bit_range +
                     self.efuse_reg_info.tertiary_bit_range)
                }
            try:
                delend = ranges[bank]
            except KeyError:
                raise ValueError('Unsupported bank parameter value')

        word_number = (efuse_bit_number - delend) / 16
        bit_number = efuse_bit_number % 16
        bit_mask = 0xffff ^ (1 << bit_number)
        bit_set = value << bit_number

        efuse = []
        self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)
        for i in range(word_number+1): #pylint: disable=unused-variable
            efuse.append(
                self.fpga_reg_read("FPGA_EFUSE_{}_RD_DATA".format(bank)))

        efuse[word_number] = (efuse[word_number] & bit_mask) | bit_set

        self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)
        for word in efuse:
            self.fpga_reg_write("FPGA_EFUSE_{}_WR_DATA".format(bank), word)

    def efuse_set_primary_bit(self, efuse_bit_number, value):
        '''
        Use the fpga registers to set to value the efuse_bit_number security bit
        in the emulated efuse primary bank.
        '''
        self.efuse_set_bit(efuse_bit_number, value, bank="PRIMARY")

    def efuse_set_secondary_bit(self, efuse_bit_number, value):
        '''
        Use the fpga registers to set to value the efuse_bit_number security bit
        in the emulated efuse secondary bank.
        '''
        self.efuse_set_bit(efuse_bit_number, value, bank="SECURITY")

    def efuse_set_tertiary_bit(self, efuse_bit_number, value):
        '''
        Use the fpga registers to set to value the efuse_bit_number security bit
        in the emulated efuse tertiary bank.
        '''
        self.efuse_set_bit(efuse_bit_number, value, bank="TERTIARY")

    def efuse_set_quaternary_bit(self, efuse_bit_number, value):
        '''
        Use the fpga registers to set to value the efuse_bit_number security bit
        in the emulated efuse quaternary bank.
        '''
        self.efuse_set_bit(efuse_bit_number, value, bank="QUARTENARY")

    def set_security_efuse(self, key_bytes):
        '''
        Use the fpga registers to set the given security key in the efuse
        emulation and turn on the security bit in the emulated primary efuse
        '''
        self.efuse_set_bit(self.efuse_reg_info.security_bit, 1)

        self.fpga_reg_write("FPGA_EFUSE_ADDR_RESET", 1)
        for word in bytes_to_words(key_bytes):
            self.fpga_reg_write("FPGA_EFUSE_SECURITY_WR_DATA", word)

    def clear_security_efuse(self):
        '''
        Use the fpga registers to set the security bit in the emulated efuse
        '''
        self.efuse_set_bit(self.efuse_reg_info.security_bit, 0)
