from __future__ import print_function
import site
import os
import re
import sys


def stderr_print(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

FILE_DIR = os.path.dirname(os.path.abspath(__file__))
site.addsitedir(FILE_DIR)


ADK_ROOT_FILE = 'sdk.xml'


def walk_up(start):
    """ like os.walk, but in reverse, goes up the directory tree.
        Unlike os.walk, doesn't differentiate files and folders """
    current = os.path.realpath(start)
    previous = ''

    while current != previous:
        try:
            yield current, os.listdir(current)
        except (IOError, OSError):
            return
        previous = current
        current = os.path.realpath(os.path.join(current, '..'))


def find_adk_root():
    try:
        adk_root = os.environ['ADK_ROOT']
    except KeyError:
        python_dir = os.path.dirname(sys.executable)

        for current_dir, contents in walk_up(python_dir):
            if ADK_ROOT_FILE in contents:
                adk_root = current_dir
                break
        else:
            adk_root = ''

    return os.path.normpath(adk_root).strip()


def find_tcl():
    python_dir = os.path.dirname(sys.executable)
    tcl_dir = os.path.join(python_dir, 'tcl', 'tcl8.5')
    if os.path.isdir(tcl_dir):
        return tcl_dir
    else:
        return ''


os.environ['ADK_ROOT'] = find_adk_root()
os.environ['TCL_LIBRARY'] = find_tcl()


def get_adk_modules():
    adk_modules = []
    pathfiles = [f for f in os.listdir(FILE_DIR) if f.endswith('.pth')]
    for pathfile in pathfiles:
        pathfile = os.path.abspath(os.path.join(FILE_DIR, pathfile))
        with open(pathfile, 'r') as pf:
            for _, line in enumerate(pf):
                if line.startswith("#"):
                    continue
                tail = line.rsplit('../')[-1]
                adk_modules.append(os.path.normcase(tail.strip()))
    return adk_modules


def add_devkit_packages_to_sys_path():
    adk_modules = get_adk_modules()
    current_sys_path = set(sys.path)
    for module in adk_modules:
        found = any(module in path for path in current_sys_path)
        if not found:
            sys.path.append(os.path.join(os.environ['ADK_ROOT'], module))


def add_workspace_packages_to_sys_path(workspace_path=None):
    """ Insert workspace packages to pythonpath's first entry so it will be preferred

    Takes a workspace file path and if it has an accompanying '.tools' file with the same name
    as the workspace it reads it for paths (one path per line) and then adds those paths
    in order to the pythonpath.
    The order of precedence to pick up the workspace file is:
        1. The argument passed to this function
        2. The value of the -w option passed to the script being run with this python interpreter
        3. The value of the __WORKSPACE_PATH__ environment variable

    Each path is inserted at position 0 when read from the '.tools' file,
    e.g. if a file has 3 lines:
        ..\..\..\path1
        ..\path2
        ..\..\path3

    the order they end up in pythonpath is reversed, latter has priority:
        ..\..\path3
        ..\path2
        ..\..\..\path1
    """

    if not workspace_path:
        fake_sys_argv = read_raw_args()
        if not hasattr(sys, 'argv') and fake_sys_argv:
            sys.argv = read_raw_args()

            import argparse
            parser = argparse.ArgumentParser(add_help=False)
            parser.add_argument('-w', '--workspace_file',
                                default=os.environ.get('__WORKSPACE_PATH__'),
                                help=argparse.SUPPRESS)

            known_args, _ = parser.parse_known_args()

            workspace_path = known_args.workspace_file

    if not workspace_path:
        return

    workspace_path = workspace_path.strip('\"')
    tools_file = os.path.splitext(workspace_path)[0] + ".tools"

    if not os.path.isfile(tools_file):
        return

    with open(tools_file) as t:
        lines = [l for l in t.readlines() if not l.startswith("#")]

    for line in lines:
        toolpath = os.path.normpath(os.path.join(os.path.dirname(workspace_path), line)).strip()

        if os.path.isdir(toolpath):
            sys.path.insert(0, toolpath)


def read_raw_args():
    """ Windows only! Reads raw arguments from command line and returns a fake sys.argv like list
        raw_args has the python executable as first element and any interpreter options follow
        e.g.:
            python.exe -v -i <script>.py arg1 arg2 -a A -b B
            python.exe -v -m <module>.<name> arg1 arg2 -a A -b B
        but sys.argv have <script>.py as its first element
        So remove the python executable and its options before parsing
    """
    import ctypes
    pstring = ctypes.windll.kernel32.GetCommandLineW()
    raw_args = ctypes.c_wchar_p(pstring).value.split()

    fake_sys_argv = []
    for i, arg in enumerate(raw_args):
        if arg.endswith(".py"):
            fake_sys_argv = raw_args[i:]
            break
        elif "-m" == arg:
            fake_sys_argv = raw_args[i+1:]
            break

    return fake_sys_argv


add_devkit_packages_to_sys_path()

add_workspace_packages_to_sys_path()
